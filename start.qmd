# Il primo assaggio {#sec-basics}

```{r}
#| echo: false
source("_common.R")
```

## Una bella calcolatrice

Iniziamo a prendere confidenza con la console di R, utilizzandola come una calcolatrice, e scriviamo

```{r}
#| eval: true

2 + 3
```

R, in tutta la sua potenza, dovrebbe produrre

```         
[1] 5
```

Questo significa che il risultato Ã¨ un vettore composto da un solo elemento, e tale elemento Ã¨ pari a 5.

Possiamo anche eseguire calcoli su vettori: definiamo un vettore di 100 elementi che contiene gli interi da 1 a 100, e aggiungiamo 2 a ciascuno di essi.

```{r}
#| eval: true

1:100 + 2
```

Se volessimo ripetere il calcolo ma aggiungendo 3 invece di 2, possiamo cliccare sulla console, schiacciare il tasto ðŸ”¼ per richiamare l'ultimo comando eseguito, modificare il 2 in 3 e premere Invio. Tuttavia, Ã¨ preferibile assegnare il vettore contenente i 100 elementi a una variabile che chiameremo

```{r}
#| eval: true

a <- 1:100
```

a questo punto possiamo fare

```{r}
#| eval: true

a + 3
```

Possiamo usare la variabile `a` per altri calcoli. Per esempio, eleviamo al quadrato tutti gli elementi associati alla variabile `a`:

```{r}
#| eval: true

a^2
```

Il valore di una variabile puÃ² essere sovrascritto con una nuova assegnazione, come nel caso riportato di seguito:

```{r}
#| eval: true

a <- "Bella zio: sto usando R!"
```

Nella creazione di variabili Ã¨ bene fare caso ad alcune regole:

- R Ã¨ *case sensitive*, quindi `f` ed `F` sono due variabili diverse;
- non sono ammesse variabili che iniziano con numeri (come `1variabile`);
- non sono ammessi caratteri diversi da lettere, numeri e *underscore*, compresi gli spazi;
- sono ammessi caratteri accentati, ma il loro uso puÃ² complicare molto la vita.

Durante il corso utilizzeremo nomi di variabili e funzioni scritti in caratteri minuscoli e senza lettere accentate, utilizzando gli *underscore* al posto degli spazi (notazione *snake_case*).

## Funzioni

Le funzioni sono una parte fondamentale di R e consentono di eseguire una serie di operazioni dati degli *input*, per ottenere nessuno, uno o piÃ¹ *output*. Si tratta di una definizione generale, perchÃ© le funzioni sono elementi estremamente versatili e le incontreremo ovunque. Durante il corso non distingueremo tra funzioni e metodi (dove le prime danno *output* e le seconde no): per noi, qualunque contenitore di operazioni applicate a un *input* sarÃ  una funzione.

R offre giÃ  molte funzioni pronte all'uso. Per esempio, possiamo assegnare alcuni numeri a una variabile e calcolarne la somma:

```{r}
#| eval: true

b <- c(2, 3, 5)
sum(b)
```

Gli input delle funzioni vengono specificati all'interno di parentesi tonde. Alcune funzioni richiedono pochi *input*, altre che ne richiedono di piÃ¹. Nella @sec-help vedremo come acquisire informazioni sull'utilizzo di una funzione.

Oltre alle funzioni predefinite, possiamo scrivere funzioni personalizzate. Scrivere funzioni efficienti, robuste e ben documentate richiede pratica, ma la sintassi di base Ã¨:

```{r}
#| eval: true
#| error: true

# la funzione fammi_il_caffe prende come argomenti due stringa di caratteri:
# la prima definisce il tipo e puÃ² essere "caffÃ¨" o "orzo"
# la seconda definisce la modalitÃ  e puÃ² essere "corto", "lungo" o "macchiato"
# l'output Ã¨ una stringa di testo
fammi_il_caffe <- function(tipo = "caffÃ¨",
                           modo = "corto"){
  # controllo che l'input abbia le caratteristiche desiderate
  stopifnot(is.character(tipo))
  stopifnot(is.character(modo))
  stopifnot(tipo %in% c("caffÃ¨", "orzo"))
  stopifnot(modo %in% c("corto", "lungo", "macchiato"))
  
  # determino il prezzo scegliendo un numero casuale tra 1 e 2 con intervallo 0.1
  prezzo <- sample(seq(from = 1, to = 2, by = 0.1), 1)
  # formatto il caffÃ© e il prezzo
  prodotto_txt <- paste("Ecco a lei il suo", tipo, modo, sep = " ")
  prezzo_txt <- paste("Sono", prezzo, "â‚¬.", sep = " ")
  
  # il risultato Ã¨ l'ultimo comando della funzione
  paste(prodotto_txt, prezzo_txt, sep = ". ")
}

# utilizzo della funzione
fammi_il_caffe()
fammi_il_caffe("orzo", "lungo")
fammi_il_caffe("orzo", "corretto")
```

Gli argomenti (o *input*) della funzione sono racchiusi tra parentesi tonde, con eventuali valori predefiniti dichiarati dopo l'uguale. Il corpo della funzione Ã¨ racchiuso tra parentesi graffe e tipicamente contiene:

- una parte di validazione degli argomenti, per assicurarsi che la funzione non venga utilizzata correttamente;
- una parte in cui vengono eseguiti i calcoli;
- una parte finale che restituisce il risultato.

## Il primo script

Nella sezione precedente abbiamo visto codice che si estende su piÃ¹ righe: inserirlo riga per riga nella console puÃ² diventare scomodo, e si rischia di dimenticare cosa si Ã¨ fatto poco prima.

Per questo motivo, possiamo creare un `file.R` in cui elencare in ordine i comandi da eseguire.
Per farlo, in RStudio basta cliccare sull'icona ![](images/newfile.png){height=25} in alto a sinistra, selezionare "R Script" e salvare il file. All'interno di questo file possiamo scrivere, ad esempio, le seguenti istruzioni:

```{r}
#| output: false
# richiamo un dataset di R
iris

# ho visto che il dataset Ã¨ composto da misurazioni di lunghezze e larghezze di
# petali e sepali di tre diverse specie di iris. Le specie considerate sono
# setosa, versicolor e virginica: per ogni specie sono presenti 50 record.

# faccio un grafico tra coppie di variabili
plot(iris, col = iris$Species)

# noto che le misurazioni relative a una specie sono ben distinte dalle altre due,
# quest'ultime mostrano un certo grado di sovrapposizione. Vediamo se il calcolo
# dei quartili eseguita sulle singole variabili per i diversi gruppi mi aiuta a
# identificare i gruppi che mostrano sovrapposizione parziale nelle misure.

# definisco una funzione per il calcolo dei quartili a partire da generici
# percentili
quartili <- function(valori){
  stopifnot(is.vector(valori))
  
  # uso la funzione predefinita quantile
  quantile(valori, probs = c(0.25, 0.50, 0.75))
}

# la funzione aggregate divide una serie di dati in gruppi, applica la funzione
# desiderata a ogni gruppo e poi ricombina i risultati
aggregate(. ~ Species, data = iris, FUN = quartili)

# la specie setosa risulta ben disinguibile dalle specie versicolor e virginica,
# quest'ultime mostrano dimensioni simili.
# Le variabili che permettono di distinguere meglio le tre specie sono 
# la lunghezza e la larghezza dei petali.
```


Con gli script Ã¨ possibile tenere traccia di quanto Ã¨ stato fatto, commentando il codice per renderlo maggiormente comprensibile a sÃ© stessi e ai colleghi. D'ora in poi, gli script saranno il nostro principale strumento di lavoro. Nei prossimi capitoli vedremo inoltre come includere gli script in un documento completo, migliorando ulteriormente la riproducibilitÃ  di un'analisi.

## Chiedere aiuto {#sec-help}

Questa Ã¨ la sezione piÃ¹ importante dell'intero corso, poichÃ© insegna come muoversi sulle proprie gambe, cadendo senza farsi troppo male e cercando di rialzarsi.

R offre un ottimo aiuto in linea: ogni pacchetto, dataset e funzione Ã¨ documentato, contenendo tutte le informazioni necessarie per comprenderne gli ambiti e le modalitÃ  di utilizzo. Per accedere a queste informazioni, Ã¨ sufficiente anteporre un punto interrogativo `?` all'elemento del quale si desidera sapere di piÃ¹:

```{r}
#| output: false
?sum()
?iris
```

Se l'elemento di cui si vuole sapere di piÃ¹ Ã¨ presente in un pacchetto noto, ma non attualmente caricato, sarÃ  necessario specificare il pacchetto di appartenenza anteponendolo con `::`:

```{r}
#| output: false
?ggplot2::geom_point()
```

Se l'elemento Ã¨ presente in un pacchetto installato ma non attualmente caricato e non si conosce esattamente a quale pacchetto appartenga, si puÃ² effettuare una ricerca tra i pacchetti installati anteponendo due punti interrogativi `??` all'elemento stesso e selezionando la voce di interesse:

```{r}
#| output: false
??geom_point()
```

All'interno della sezione di *help* si trova una descrizione iniziale dell'elemento e, se si tratta di una funzione, i diversi *input* richiesti; seguono poi sezioni che spesso spiegato il funzionamento della funziona, per concludere con utili esempi d'uso.

A volte l'aiuto in linea potrebbe non essere sufficiente; in tal caso si consiglia di rivolgersi a Google o qualche large language model (LLM) come DeepSeek, ChatGPT o Perplexity. Questi strumenti di intelligenza artificiale permettono, a fronte di richieste dettagliate e ben strutturate di farsi scrivere e spiegare interi programmi, anche complessi, richiedendo poche rifiniture manuali.

In alternativa o in completamento all'uso di strumenti di intelligenza artificiale, esistono forum dedicati alla programmazione e con una folta comunitÃ  di preparatissimi (e spesso burberi) utilizzatori di R. Tra questi [StackOverflow](https://stackoverflow.com/questions) risulta particolarmente ricco di spunti e risorse. Per utilizzarlo al meglio:

-   cercate con cura se la vostra domanda sia giÃ  stata posta in passato;
-   prendete spunto da domande simili per strutturare con cura la vostra richiesta;
-   create un esempio minimo riproducibile (*reprex*).

Quest'ultimo punto ha lo scopo di rendere il vostro codice riproducibile e facilmente leggibile da chi vi dovrÃ  aiutare: inserite nel codice tutte le librerie e variabili utilizzate, e togliete tutto ciÃ² che non Ã¨ indispensabile per riprodurre il problema su cui state chiedendo aiuto.

:::: {.panel-tabset}

## Esercizio

- Documentarsi sull'utilizzo della funzione `aggregate`;
- calcolare la media di tutte le quattro tipologie di misure delle tre specie nel dataset `iris`.

## Soluzione

```{r}
?aggregate()    # 1.
aggregate(. ~ Species, data = iris, FUN = mean)    # 2.
```
::::