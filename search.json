[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Corso di R: dalle basi alla prima analisi dei dati",
    "section": "",
    "text": "Prefazione\nQuesto documento raccoglie il materiale presentato durante l’omonimo corso tenuto in ARPAL nel 2025.\nIl corso e l’annesso documento nascono dalla volontà degli autori di condividere con i colleghi la potenza e la bellezza di utilizzare un linguaggio di programmazione nell’analisi dei dati.\nIl linguaggio di programmazione scelto è R, in quanto permette sin da subito di eseguire semplici analisi di dati, richiedendo l’apprendimento di una sintassi intuitiva e di alcune funzioni, in gran parte già pronte o disponibili in librerie specializzate. Inoltre, con R è facile creare grafici efficaci e ricchi di contenuto.\nQuesto documento è rilasciato gratuitamente con licenza Creative Commons CC BY-NC-SA 4.0.",
    "crumbs": [
      "Prefazione"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Attenzione",
    "section": "",
    "text": "2 Introduzione\nLo scopo del corso è fornire gli strumenti necessari per eseguire semplici analisi dei dati utilizzando il linguaggio R.\nIl corso si conclude con una piccola analisi guidata svolta dai partecipanti e strutturata in un documento a sé stante.\nDurante il proseguo del corso impareremo a:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Attenzione</span>"
    ]
  },
  {
    "objectID": "intro.html#quanta-fatica",
    "href": "intro.html#quanta-fatica",
    "title": "1  Attenzione",
    "section": "2.1 Quanta fatica",
    "text": "2.1 Quanta fatica\nL’utilizzo di un linguaggio di programmazione richiede un importante investimento iniziale per apprenderne le basi, le funzioni principali e il loro campo di applicazione. Tuttavia, l’impegno profuso viene ampiamente ripagato dalla possibilità di riutilizzare e adattare il codice, nonché di ripetere le analisi con poco sforzo, rendendo l’intero processo riproducibile e documentabile.\nInoltre, imparare un linguaggio di programmazione apre numerose porte e può semplificare il lavoro quotidiano in molti ambiti. Per esempio, con R è possibile realizzare:\n\ndocumenti dinamici parametrizzati;\napplicazioni interattive accessibili via browser;\ninterfacce di programmazione (API) per l’esecuzione di funzioni da remoto.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Attenzione</span>"
    ]
  },
  {
    "objectID": "intro.html#prerequisiti",
    "href": "intro.html#prerequisiti",
    "title": "1  Attenzione",
    "section": "2.2 Prerequisiti",
    "text": "2.2 Prerequisiti\nIl corso è aperto a chiunque abbia una certa dimestichezza con il computer e una conoscenza di base della logica. Il candidato ideale ha già svolto qualche analisi su dati numerici, utilizzando strumenti statistici di base e fogli di calcolo. La conoscenza di un linguaggio di programmazione diverso da R non è necessaria, ma sicuramente rappresenta un vantaggio.\nPer eseguire il codice presentato durante il corso, è necessario installare R, RStudio e i seguenti pacchetti data.table, readxl, ggplot2, glue e gt.\n\n2.2.1 R\nR può essere scaricato dal Comprensive R Archive Network (CRAN), seguendo le istruzioni relative al proprio sistema operativo. Ogni anno viene rilasciata una nuova versione principale, accompagnata da circa tre aggiornamenti minori: se si intende usare R regolarmente, è consigliabile mantenere il software aggiornato.\nR è un software libero, distribuito sotto una combinazione di licenze GNU General Public License v2 e v3 e GNU Lesser General Public License v2.1.\n\n\n2.2.2 RStudio\nRStudio è l’ambiente di sviluppo integrato (IDE) più diffuso per R: permette la gestione completa di un progetto, la connessione a sorgenti dati esterne come database e l’integrazione con sistemi di gestione delle versioni come git. Può essere scaricato dal sito ufficiale di Posit.\nAnche RStudio è un software libero, rilasciato sotto licenza GNU Affero General Public License v3.\n\n\n\n\n\n\n\n\nFigura 2.1: Schermata di RStudio: in alto, da sinistra a destra, si trova il pannello dedicato al codice sorgente, al suo fianco il pannello dedicato agli ambienti e allo storico. In basso, da sinistra a destra, si trova la console e il pannello dedicato agli output.\n\n\n\n\n\nL’uso di RStudio o di un altro IDE non è strettamente necessario per utilizzare R, ma ne semplifica notevolmente l’impiego. Altri IDE comunemente utilizzati con R sono Visual Studio Code, Vim ed Emacs.\n\n\n2.2.3 I pacchetti di R\nLe funzionalità di R possono essere ampliate tramite pacchetti. La lista completa, molto ampia e variegata, è presente sul sito del CRAN. Alcuni di questi pacchetti sono sviluppati da appassionati, altri da statistici e ingegneri del software di fama mondiale. Tutte le funzioni e i dati contenuti in un pacchetto sono documentati, il codice sorgente è completamente consultabile e spesso è possibile collaborare direttamente allo sviluppo su piattaforme come GitHub. Molti pacchetti sono inoltre collegati a libri di testo o articoli scientifici.\nI pacchetti si installano in R con il comando:\n\ninstall.packages(\"pacchetto\")\n\nDurante il corso utilizzeremo alcuni pacchetti molto diffusi:\n\ndata.table: consente di caricare e manipolare efficientemente grandi insiemi di dati, con una sintassi particolare ma intuitiva;\nggplot2: il pacchetto di riferimento per la creazione di grafici;\nreadxl: utile per importare dati da fogli Excel;\nglue: semplifica la concatenazione di stringhe, anche se lo useremo raramente in modo diretto;\ngt: utilizzato per produrre tabelle di alta qualità. Le tabelle che vedrete nel corso saranno realizzate con questo pacchetto, anche se raramente lo useremo direttamente;\nR.utils: lo utilizzeremo solo per importare dati da file gz.\n\nInstalliamo i pacchetti richiesti racchiudendoli all’interno di un vettore con il comando c() e scrivendo il seguente comando all’interno della console di R, dopo il simbolo &gt;:\n\ninstall.packages(c(\"data.table\", \"readxl\", \"ggplot2\", \"glue\", \"gt\", \"R.utils\"))\n\nQuando ne avremo bisogno saremo pronti a caricare e usare tali pacchetti.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Attenzione</span>"
    ]
  },
  {
    "objectID": "intro.html#per-approfondire",
    "href": "intro.html#per-approfondire",
    "title": "1  Attenzione",
    "section": "2.3 Per approfondire",
    "text": "2.3 Per approfondire\nSe il materiale presentato nel corso non fosse sufficiente o non rispondesse pienamente alle vostre esigenze, in rete è possibile trovare numerosi testi gratuiti di alta qualità. Tra questi si segnalano:\n\nHands-On Rrogramming with R scritto da Garrett Grolemund;\nR for Data Science scritto da Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund;\nAdvanced R scritto da Hadley Wickham.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Attenzione</span>"
    ]
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Le basi",
    "section": "",
    "text": "In questa prima parte inizieremo a prendere dimestichezza con le basi di R:\n\nnel primo capitolo partiremo dall’interazione con la console fino a scrivere ed eseguire il nostro primo script;\nnel secondo capitolo ci concentreremo sull’uso delle diverse tipologie di oggetti di R;\nnel terzo capitolo importeremo dati da file esterni;\nnel quarto capitolo inizieremo a fare i primi esperimenti di trasformazione dei dati con la libreria data.table.",
    "crumbs": [
      "Le basi"
    ]
  },
  {
    "objectID": "start.html",
    "href": "start.html",
    "title": "2  Il primo assaggio",
    "section": "",
    "text": "2.1 Una bella calcolatrice\nIniziamo a prendere confidenza con la console di R, utilizzandola come una calcolatrice, e scriviamo\n2 + 3\n#&gt; [1] 5\nR, in tutta la sua potenza, dovrebbe produrre\nQuesto significa che il risultato è un vettore composto da un solo elemento, e tale elemento è pari a 5.\nPossiamo anche eseguire calcoli su vettori: definiamo un vettore di 100 elementi che contiene gli interi da 1 a 100, e aggiungiamo 2 a ciascuno di essi.\n1:100 + 2\n#&gt;   [1]   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20\n#&gt;  [19]  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38\n#&gt;  [37]  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56\n#&gt;  [55]  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74\n#&gt;  [73]  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92\n#&gt;  [91]  93  94  95  96  97  98  99 100 101 102\nSe volessimo ripetere il calcolo ma aggiungendo 3 invece di 2, possiamo cliccare sulla console, schiacciare il tasto 🔼 per richiamare l’ultimo comando eseguito, modificare il 2 in 3 e premere Invio. Tuttavia, è preferibile assegnare il vettore contenente i 100 elementi a una variabile che chiameremo\na &lt;- 1:100\na questo punto possiamo fare\na + 3\n#&gt;   [1]   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21\n#&gt;  [19]  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39\n#&gt;  [37]  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57\n#&gt;  [55]  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75\n#&gt;  [73]  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93\n#&gt;  [91]  94  95  96  97  98  99 100 101 102 103\nPossiamo usare la variabile a per altri calcoli. Per esempio, eleviamo al quadrato tutti gli elementi associati alla variabile a:\na^2\n#&gt;   [1]     1     4     9    16    25    36    49    64    81   100   121   144\n#&gt;  [13]   169   196   225   256   289   324   361   400   441   484   529   576\n#&gt;  [25]   625   676   729   784   841   900   961  1024  1089  1156  1225  1296\n#&gt;  [37]  1369  1444  1521  1600  1681  1764  1849  1936  2025  2116  2209  2304\n#&gt;  [49]  2401  2500  2601  2704  2809  2916  3025  3136  3249  3364  3481  3600\n#&gt;  [61]  3721  3844  3969  4096  4225  4356  4489  4624  4761  4900  5041  5184\n#&gt;  [73]  5329  5476  5625  5776  5929  6084  6241  6400  6561  6724  6889  7056\n#&gt;  [85]  7225  7396  7569  7744  7921  8100  8281  8464  8649  8836  9025  9216\n#&gt;  [97]  9409  9604  9801 10000\nIl valore di una variabile può essere sovrascritto con una nuova assegnazione, come nel caso riportato di seguito:\na &lt;- \"Bella zio: sto usando R!\"\nNella creazione di variabili è bene fare caso ad alcune regole:\nDurante il corso utilizzeremo nomi di variabili e funzioni scritti in caratteri minuscoli e senza lettere accentate, utilizzando gli underscore al posto degli spazi (notazione snake_case).",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#una-bella-calcolatrice",
    "href": "start.html#una-bella-calcolatrice",
    "title": "2  Il primo assaggio",
    "section": "",
    "text": "[1] 5\n\n\n\n\n\n\n\n\n\n\n\n\n\nR è case sensitive, quindi f ed F sono due variabili diverse;\nnon sono ammesse variabili che iniziano con numeri (come 1variabile);\nnon sono ammessi caratteri diversi da lettere, numeri e underscore, compresi gli spazi;\nsono ammessi caratteri accentati, ma il loro uso può complicare molto la vita.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#funzioni",
    "href": "start.html#funzioni",
    "title": "2  Il primo assaggio",
    "section": "2.2 Funzioni",
    "text": "2.2 Funzioni\nLe funzioni sono una parte fondamentale di R e consentono di eseguire una serie di operazioni dati degli input, per ottenere nessuno, uno o più output. Si tratta di una definizione generale, perché le funzioni sono elementi estremamente versatili e le incontreremo ovunque. Durante il corso non distingueremo tra funzioni e metodi (dove le prime danno output e le seconde no): per noi, qualunque contenitore di operazioni applicate a un input sarà una funzione.\nR offre già molte funzioni pronte all’uso. Per esempio, possiamo assegnare alcuni numeri a una variabile e calcolarne la somma:\n\nb &lt;- c(2, 3, 5)\nsum(b)\n#&gt; [1] 10\n\nGli input delle funzioni vengono specificati all’interno di parentesi tonde. Alcune funzioni richiedono pochi input, altre che ne richiedono di più. Nella Sezione 2.4 vedremo come acquisire informazioni sull’utilizzo di una funzione.\nOltre alle funzioni predefinite, possiamo scrivere funzioni personalizzate. Scrivere funzioni efficienti, robuste e ben documentate richiede pratica, ma la sintassi di base è:\n\n# la funzione fammi_il_caffe prende come argomenti due stringa di caratteri:\n# la prima definisce il tipo e può essere \"caffè\" o \"orzo\"\n# la seconda definisce la modalità e può essere \"corto\", \"lungo\" o \"macchiato\"\n# l'output è una stringa di testo\nfammi_il_caffe &lt;- function(tipo = \"caffè\",\n                           modo = \"corto\"){\n  # controllo che l'input abbia le caratteristiche desiderate\n  stopifnot(is.character(tipo))\n  stopifnot(is.character(modo))\n  stopifnot(tipo %in% c(\"caffè\", \"orzo\"))\n  stopifnot(modo %in% c(\"corto\", \"lungo\", \"macchiato\"))\n  \n  # determino il prezzo scegliendo un numero casuale tra 1 e 2 con intervallo 0.1\n  prezzo &lt;- sample(seq(from = 1, to = 2, by = 0.1), 1)\n  # formatto il caffé e il prezzo\n  prodotto_txt &lt;- paste(\"Ecco a lei il suo\", tipo, modo, sep = \" \")\n  prezzo_txt &lt;- paste(\"Sono\", prezzo, \"€.\", sep = \" \")\n  \n  # il risultato è l'ultimo comando della funzione\n  paste(prodotto_txt, prezzo_txt, sep = \". \")\n}\n\n# utilizzo della funzione\nfammi_il_caffe()\n#&gt; [1] \"Ecco a lei il suo caffè corto. Sono 1.6 €.\"\nfammi_il_caffe(\"orzo\", \"lungo\")\n#&gt; [1] \"Ecco a lei il suo orzo lungo. Sono 1.4 €.\"\nfammi_il_caffe(\"orzo\", \"corretto\")\n#&gt; Error in fammi_il_caffe(\"orzo\", \"corretto\"): modo %in% c(\"corto\", \"lungo\", \"macchiato\") is not TRUE\n\nGli argomenti (o input) della funzione sono racchiusi tra parentesi tonde, con eventuali valori predefiniti dichiarati dopo l’uguale. Il corpo della funzione è racchiuso tra parentesi graffe e tipicamente contiene:\n\nuna parte di validazione degli argomenti, per assicurarsi che la funzione non venga utilizzata correttamente;\nuna parte in cui vengono eseguiti i calcoli;\nuna parte finale che restituisce il risultato.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#il-primo-script",
    "href": "start.html#il-primo-script",
    "title": "2  Il primo assaggio",
    "section": "2.3 Il primo script",
    "text": "2.3 Il primo script\nNella sezione precedente abbiamo visto codice che si estende su più righe: inserirlo riga per riga nella console può diventare scomodo, e si rischia di dimenticare cosa si è fatto poco prima.\nPer questo motivo, possiamo creare un file.R in cui elencare in ordine i comandi da eseguire. Per farlo, in RStudio basta cliccare sull’icona  in alto a sinistra, selezionare “R Script” e salvare il file. All’interno di questo file possiamo scrivere, ad esempio, le seguenti istruzioni:\n\n# richiamo un dataset di R\niris\n\n# ho visto che il dataset è composto da misurazioni di lunghezze e larghezze di\n# petali e sepali di tre diverse specie di iris. Le specie considerate sono\n# setosa, versicolor e virginica: per ogni specie sono presenti 50 record.\n\n# faccio un grafico tra coppie di variabili\nplot(iris, col = iris$Species)\n\n# noto che le misurazioni relative a una specie sono ben distinte dalle altre due,\n# quest'ultime mostrano un certo grado di sovrapposizione. Vediamo se il calcolo\n# dei quartili eseguita sulle singole variabili per i diversi gruppi mi aiuta a\n# identificare i gruppi che mostrano sovrapposizione parziale nelle misure.\n\n# definisco una funzione per il calcolo dei quartili a partire da generici\n# percentili\nquartili &lt;- function(valori){\n  stopifnot(is.vector(valori))\n  \n  # uso la funzione predefinita quantile\n  quantile(valori, probs = c(0.25, 0.50, 0.75))\n}\n\n# la funzione aggregate divide una serie di dati in gruppi, applica la funzione\n# desiderata a ogni gruppo e poi ricombina i risultati\naggregate(. ~ Species, data = iris, FUN = quartili)\n\n# la specie setosa risulta ben disinguibile dalle specie versicolor e virginica,\n# quest'ultime mostrano dimensioni simili.\n# Le variabili che permettono di distinguere meglio le tre specie sono \n# la lunghezza e la larghezza dei petali.\n\nCon gli script è possibile tenere traccia di quanto è stato fatto, commentando il codice per renderlo maggiormente comprensibile a sé stessi e ai colleghi. D’ora in poi, gli script saranno il nostro principale strumento di lavoro. Nei prossimi capitoli vedremo inoltre come includere gli script in un documento completo, migliorando ulteriormente la riproducibilità di un’analisi.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#sec-help",
    "href": "start.html#sec-help",
    "title": "2  Il primo assaggio",
    "section": "2.4 Chiedere aiuto",
    "text": "2.4 Chiedere aiuto\nQuesta è la sezione più importante dell’intero corso, poiché insegna come muoversi sulle proprie gambe, cadendo senza farsi troppo male e cercando di rialzarsi.\nR offre un ottimo aiuto in linea: ogni pacchetto, dataset e funzione è documentato, contenendo tutte le informazioni necessarie per comprenderne gli ambiti e le modalità di utilizzo. Per accedere a queste informazioni, è sufficiente anteporre un punto interrogativo ? all’elemento del quale si desidera sapere di più:\n\n?sum()\n?iris\n\nSe l’elemento di cui si vuole sapere di più è presente in un pacchetto noto, ma non attualmente caricato, sarà necessario specificare il pacchetto di appartenenza anteponendolo con :::\n\n?ggplot2::geom_point()\n\nSe l’elemento è presente in un pacchetto installato ma non attualmente caricato e non si conosce esattamente a quale pacchetto appartenga, si può effettuare una ricerca tra i pacchetti installati anteponendo due punti interrogativi ?? all’elemento stesso e selezionando la voce di interesse:\n\n??geom_point()\n\nAll’interno della sezione di help si trova una descrizione iniziale dell’elemento e, se si tratta di una funzione, i diversi input richiesti; seguono poi sezioni che spesso spiegato il funzionamento della funziona, per concludere con utili esempi d’uso.\nA volte l’aiuto in linea potrebbe non essere sufficiente; in tal caso si consiglia di rivolgersi a Google o qualche large language model (LLM) come DeepSeek, ChatGPT o Perplexity. Questi strumenti di intelligenza artificiale permettono, a fronte di richieste dettagliate e ben strutturate di farsi scrivere e spiegare interi programmi, anche complessi, richiedendo poche rifiniture manuali.\nIn alternativa o in completamento all’uso di strumenti di intelligenza artificiale, esistono forum dedicati alla programmazione e con una folta comunità di preparatissimi (e spesso burberi) utilizzatori di R. Tra questi StackOverflow risulta particolarmente ricco di spunti e risorse. Per utilizzarlo al meglio:\n\ncercate con cura se la vostra domanda sia già stata posta in passato;\nprendete spunto da domande simili per strutturare con cura la vostra richiesta;\ncreate un esempio minimo riproducibile (reprex).\n\nQuest’ultimo punto ha lo scopo di rendere il vostro codice riproducibile e facilmente leggibile da chi vi dovrà aiutare: inserite nel codice tutte le librerie e variabili utilizzate, e togliete tutto ciò che non è indispensabile per riprodurre il problema su cui state chiedendo aiuto.\n\nEsercizioSoluzione\n\n\n\nDocumentarsi sull’utilizzo della funzione aggregate;\ncalcolare la media di tutte le quattro tipologie di misure delle tre specie nel dataset iris.\n\n\n\n\n?aggregate()    # 1.\naggregate(. ~ Species, data = iris, FUN = mean)    # 2.\n#&gt;      Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n#&gt; 1     setosa        5.006       3.428        1.462       0.246\n#&gt; 2 versicolor        5.936       2.770        4.260       1.326\n#&gt; 3  virginica        6.588       2.974        5.552       2.026",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "3  Oggetti di R",
    "section": "",
    "text": "3.1 Tipologie di elementi\nPrima di vedere le classi di oggetti di R, che possiamo pensare come diverse tipologie di contenitori, è bene dare uno sguardo alle tipologie di elementi che possiamo inserire in questi contenitori.\nQuando saremo in dubbio sulla tipologia di un dato elemento possiamo usare la funzione typeof().",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "objects.html#sec-typeof",
    "href": "objects.html#sec-typeof",
    "title": "3  Oggetti di R",
    "section": "",
    "text": "3.1.1 Numeri\nR gestisce diverse tipologie di numeri, ma utilizzeremo principalmente la tipologia double, abbreviazione di double-precision floating-point format: che definisce come in informatica vengono archiviati e manipolati gli elementi esprimibili con una parte decimale. Ogni misura - ad eccezione dei conteggi puri - ricade in questa tipologia, anche se dovesse avere valore intero (es. 5). L’Utilizzo di elementi di tipo double è semplice:\n\na &lt;- c(2, 2.1, 2.5)\n\nPiù raramente, dovremo definire degli interi, che appartengono alla tipologia integer e si indicano facendo seguire una L maiuscola al numero:\n\nb &lt;- c(1L, 5L)\n\nAltre tipologie di numeri più rare comprendono i tipi complex e raw, rispettivamente per numeri complessi e bytes: non le utilizzeremo.\nAlcune operazioni matematiche possono generare numeri particolari come NaN (not a number), Inf e -Inf. Il primo si ottiene, ad esempio, dividendo zero per zero, mentre gli ultimi dividendo un numero positivo o negativo per zero. Per verificare se un numero è NaN o Inf, si usano rispettivamente le funzioni is.nan() e is.infinite().\n\n\n3.1.2 Testo\nR usa una singola tipologia per le stringhe di testo: indipendentemente dalla loro lunghezza saranno tutte character e si creano racchiudendo il testo tra virgolette (singole o doppie; in questo corso utilizzeremo sempre le doppie virgolette):\n\nc &lt;- \"roba\"\n\nTalvolta, i numeri possono essere erroneamente archiviati come testo. Questo è un risultato indesiderato ma abbastanza frequente quando si importano dati non ben ripulit. Per riconvertirli in numeri, si usa la funzione as.numeric().\n\n\n3.1.3 Logici\nGli elementi logici possono assumere esclusivamente valore TRUE o FALSE. Raramente vengono assegnati direttamente a una variabile, ma compaiono spesso a seguito di un’operazione logica:\n\nd &lt;- 3 &lt; 5\nd\n#&gt; [1] TRUE\ntypeof(d)\n#&gt; [1] \"logical\"\n\ne &lt;- 3 == 3L\n\nInternamente, R li tratta come interi pari a 1 (TRUE) o 0 (FALSE).\n\n\n3.1.4 Elementi mancanti ed elementi nulli\nR identifica gli elementi mancanti con NA (not available). NA rappresenta una tipologia particolare, in quanto diventa di tipo testo, numero o valore logico a seconda del contesto. In genere, le operazioni eseguite su gruppi di elementi in cui uno o più elementi sono NA restituiscono NA. Si può verificare se un elemento è di tipo NA con la funzione is.na().\nTalvolta, R può restituire un elemento di tipo NULL quando si tenta di estrarre un elemento inesistente da un oggetto. Più comunemente, è possibile assegnare il valore NULL a un oggetto per eliminarne il contenuto:\n\nc()\n#&gt; NULL\n\na\n#&gt; [1] 2.0 2.1 2.5\na &lt;- NULL\na\n#&gt; NULL",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "objects.html#sec-classes",
    "href": "objects.html#sec-classes",
    "title": "3  Oggetti di R",
    "section": "3.2 Tipologie di contenitori",
    "text": "3.2 Tipologie di contenitori\n\n3.2.1 Vettori\nUn vettore è un insieme ordinato di valori, tutti appartenenti alla stessa tipologia. Tutte le variabili create nella Sezione 3.1 sono esempi di vettori: anche se alcuni contengono solo numeri, testo o valori logici, essi non contengono mai elementi di tipologie diverse e possiedono una sola dimensione.\nTecnicamente, i vettori non sono catalogati da R all’interno di una classe, tuttavia è comodo vederli come la più semplice delle classi, intendendo con questo termine - per semplicità - una tipologia di contenitore di elementi.\nÈ possibile accedere ai diversi elementi di un vettore utilizzando la notazione: vettore[indici] dove indici è a sua volta un vettore di elementi da includere o escludere. Esempi:\n\nf &lt;- c(\"a\", \"b\", \"c\", NA, \"e\")\nf[1] # seleziona il primo elemento\n#&gt; [1] \"a\"\n\nf[-1] # seleziona tutti gli elementi tranne il primo\n#&gt; [1] \"b\" \"c\" NA  \"e\"\n\nf[2:4] # seleziona gli elementi dal secondo al quarto, estremi compresi\n#&gt; [1] \"b\" \"c\" NA\n\nf[-(2:4)] # seleziona tutti gli elementi tranne quelli dal secondo al quarto\n#&gt; [1] \"a\" \"e\"\n\nf[c(2,4)] # seleziona il secondo e quarto elemento\n#&gt; [1] \"b\" NA\n\nf[-c(2,4)] # seleziona tutti gli elementi tranne il secondo e il quarto\n#&gt; [1] \"a\" \"c\" \"e\"\n\ng &lt;- c(3,5)\nf[g] # seleziona il terzo e quinto elemento\n#&gt; [1] \"c\" \"e\"\n\nf[-g] # seleziona tutti gli elementi tranne il terzo e il quinto\n#&gt; [1] \"a\" \"b\" NA\n\nf[is.na(f)] # seleziona solo gli elementi NA\n#&gt; [1] NA\n\nf[!is.na(f)] # seleziona solo gli elementi non NA\n#&gt; [1] \"a\" \"b\" \"c\" \"e\"\n\nPer verificare se un oggetto è un vettore si può usare la funzione is.vector(), mentre per conoscerne il numero di elementi si usa la funzione length().\nCon i vettori possiamo iniziare a fare qualche calcolo con funzioni quali max(), min(), sum(), mean(), median(), quantile(), which.min() e which.max() e molte altre.\nSpesso è utile generare vettori casuali; a tale scopo, le funzioni forse più usate sono sample() e rnorm(). La prima estrae un numero casuale di elementi da un vettore, la seconda genera valori da una distribuzione normale con parametri noti. Esempio:\n\nsorprendimi &lt;- sample(1:1000, 30, replace = TRUE) # 30 valori indipendenti da 1 a 1000.\nmax(sorprendimi) # trova il valore massimo\n#&gt; [1] 998\nwhich.max(sorprendimi) # trova la posizione del valore massimo\n#&gt; [1] 11\nm &lt;- which.max(sorprendimi)\nsorprendimi[m]\n#&gt; [1] 998\nmax(sorprendimi) == sorprendimi[m] # funziona!\n#&gt; [1] TRUE\n\nrnorm(1000, mean = 10, sd = 3) |&gt; # si usa la pipe per concatenare le funzioni\n  hist()\n\n\n\n\n\n\n\n\nGli elementi di un vettore possono essere associati a un nome tramite l’attributo names():\n\ng\n#&gt; [1] 3 5\nnames(g) &lt;- c(\"tre\", \"cinque\")\ng\n#&gt;    tre cinque \n#&gt;      3      5\nnames(g) &lt;- NULL\ng\n#&gt; [1] 3 5\n\n\n\n3.2.2 Matrici ed array\nLa naturale estensione dei vettori sono le matrici e gli array multidimensionali, creati organizzando i vettori su righe e colonne.\nL’estrazione di elementi da una matrice avviene con la notazione matrice[righe, colonne], come mostrato nell’esempio riportato di seguito:\n\nmatrice &lt;- matrix(1:100, nrow = 20)\nmatrice[5:7, 3:5]\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]   45   65   85\n#&gt; [2,]   46   66   86\n#&gt; [3,]   47   67   87\nmatrice[, 3]\n#&gt;  [1] 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\n\nSi può determinare e modificare la dimensione di una matrice con il comando dim():\n\ndim(matrice)\n#&gt; [1] 20  5\ndim(matrice) &lt;- c(5, 20)\n\nSu vettori e matrici di tipo numerico è possibile eseguire operazioni di algebra lineare, come il prodotto righe per colonne, utilizzando l’operatore %*%, o il calcolo dell’inversa con il comando inv() del pacchetto MASS. Tuttavia, raramente sarà necessario eseguire queste operazioni manualmente, poiché numerosissimi algoritmi sono già implementati in modo molto efficiente in funzioni e pacchetti dedicati.\n\n\n3.2.3 Fattori\nUn fattore è un tipo di dato che può assumere solo valori finiti e noti. Ad esempio, il colore dei capelli dei bambini di una classe è un fattore, così come le tipologie di acque analizzate dal laboratorio (acque di mare, potabili, sotterranee, ecc.). I valori distinti che un fattore può assumere si chiamano livelli.\nGli esempi di fattori visti in precedenza non sono ordinati, ma alcuni possono esserlo, come i giudizi di un esame: insufficiente, sufficiente, buono, distinto, ottimo.\nInternamente, R tratta i fattori come interi a cui associa etichette di testo. Per i fattori ordinati, gli interi seguono l’ordine specificato durante la definizione dei livelli; per i fattori non ordinati, gli interi sono assegnati in ordine alfabetico o di apparizione. Esempio:\n\nterza_c &lt;- c(\"ottimo\", \"ottimo\", \"buono\", \"insufficiente\", \"buono\", \"buono\")\n\n# fattore senza specifica dei livelli\nfactor(terza_c)\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: buono insufficiente ottimo\n\n# fattore con livelli specificato ma non ordinati\nfactor(terza_c,\n       levels = c(\"insufficiente\", \"sufficiente\", \"buono\", \"distinto\", \"ottimo\"))\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: insufficiente sufficiente buono distinto ottimo\n\n# fattore ordinato\nfactor(terza_c,\n       ordered = TRUE,\n       levels = c(\"insufficiente\", \"sufficiente\", \"buono\", \"distinto\", \"ottimo\"))\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: insufficiente &lt; sufficiente &lt; buono &lt; distinto &lt; ottimo\n\n\n\n3.2.4 Liste\nI contenitori visti finora sono ottimi per raggruppare elementi della stessa tipologia. Le liste, invece, permettono di raggruppare elementi di tipi diversi mantenendoli comunque ordinati:\n\nlista &lt;- list(numeri = 1:20,\n              testo = c(\"pippo\", \"ciccio\", \"riccio\"),\n              giudizi = terza_c,\n              matrice = matrice)\nstr(lista)\n#&gt; List of 4\n#&gt;  $ numeri : int [1:20] 1 2 3 4 5 6 7 8 9 10 ...\n#&gt;  $ testo  : chr [1:3] \"pippo\" \"ciccio\" \"riccio\"\n#&gt;  $ giudizi: chr [1:6] \"ottimo\" \"ottimo\" \"buono\" \"insufficiente\" ...\n#&gt;  $ matrice: int [1:5, 1:20] 1 2 3 4 5 6 7 8 9 10 ...\n\nPer accedere alla struttura di una lista si usa il comando str(), utile anche con altri tipi di contenitori.\nI singoli gruppi si estraggono per posizione con la sintassi lista[[gruppo]] o per nome con la sintassi lista$gruppo. All’interno del gruppo posso accedere ai singoli elementi come visto nelle sezioni precedenti:\n\nlista[[2]]\n#&gt; [1] \"pippo\"  \"ciccio\" \"riccio\"\nlista$testo\n#&gt; [1] \"pippo\"  \"ciccio\" \"riccio\"\nlista$testo[2]\n#&gt; [1] \"ciccio\"\nlista[[4]][2,]\n#&gt;  [1]  2  7 12 17 22 27 32 37 42 47 52 57 62 67 72 77 82 87 92 97\nlista[[4]][2,3]\n#&gt; [1] 12\nlista[[3]] &lt;- NULL\n\n\n\n3.2.5 Data frames\nI data.frame sono tabelle di dati che possono contenere colonne di diverse tipologie. Rispetto alle liste, offrono una maggiore facilità di consultazione, ma non permettono di immagazzinare gruppi di diversa lunghezza. Sono la tipologia di dati più frequentemente utilizzata.\nInternamente, R tratta le colonne di un data.frame come gruppi di una lista.\nEsempio con il dataset iris:\n\nstr(iris)\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#&gt;  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#&gt;  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#&gt;  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n#&gt;  $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nCreazione e modifica di un data frame:\n\ndf &lt;- data.frame(lettere = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"),\n                 interi = 1:6,\n                 numeri = rnorm(6))\ndf$numeri\n#&gt; [1] -0.1829260 -1.3792578  1.2506006 -1.8762368 -0.3687876 -2.1292973\ndf$lettere[3]\n#&gt; [1] \"c\"\ndf$lettere[3] &lt;- \"g\"\ndf$sopra3 &lt;- df$interi &gt; 3\ndf$interi &lt;- NULL\n\nI nomi delle colonne si estraggono o modificano con la funzione colnames():\n\ncolnames(df)\n#&gt; [1] \"lettere\" \"numeri\"  \"sopra3\"\ncolnames(df)[3] &lt;- \"random\"\n\nI data.frame possono anche avere nomi per ogni riga, ma è consigliabile evitarlo.\nLa sintassi base di R rende spesso complicato filtrare o eseguire operazioni complesse sui data frame. Per questo motivo sono nati pacchetti dedicati, tra cui:\n\ndplyr permette di manipolare i dati concatenando funzioni con nomi descrittivi come filter(), mutate(), group_by(), ecc.\ndata.table nato per la manipolazione efficiente di grandi quantità di dati, propone una sintassi estesa rispetto a quella base di R: lo vedremo nel prossimo capitolo.\n\n\nEsercizioSoluzione\n\n\nPiero ha effettuato 10 prove indipendenti per la misura della concentrazione di nitrati su un campione di acqua, ottenendo i seguenti risultati: 0.77, 0.69, 0.89, 0.75, 0.93, 0.81, 0.91, 1.06, 0.98 mg/l. Una delle prove non ha dato risultati validi.\n\ncreare uno script contenente commenti esplicativi di ogni passaggio;\ncalcolare media, deviazione standard e intervallo di confidenza (\\(\\alpha\\) = 0.95).\n\nPina ha preparato altre 10 prove indipendenti dello stesso campione di acqua per la misura della concentrazione di nitrati, ottenendo i seguenti risultati: 1.09, 0.89, 0.74, 1.07, 0.68, 0.89, 1.25, 1.10, 0.86, 0.88 mg/l.\n\nampliare lo script sviluppato nell’esercizio precedente;\nunire i risultati ottenuti dai due operatori nello stesso oggetto di R;\ncalcolare gli intervalli di confidenza per ciascun operatore;\nValutare statisticamente la presenza di differenze significative tra i valori ottenuti dai due operatori.\n\nPer praticità, assumiamo che: - i dati seguano una distribuzione normale; - le varianze dei due gruppi siano omogenee.\n\n\n\n# 1\npiero &lt;- c(0.77, 0.69, 0.89, 0.75, 0.93, 0.81, 0.91, 1.06, 0.98, NA)\nmean(piero, na.rm = TRUE)\n#&gt; [1] 0.8655556\nsd(piero, na.rm = TRUE)\n#&gt; [1] 0.119385\nn &lt;- piero[!is.na(piero)] |&gt; length() # immaginate un altro modo\n\nci &lt;- function(data, alfa = 0.975){\n  stopifnot(is.numeric(data))\n  stopifnot(is.numeric(alfa))\n  stopifnot(alfa &gt; 0 &  alfa &lt;= 1)\n  \n  n &lt;- sum(!is.na(data))\n  dof &lt;- n - 1\n  avg &lt;- mean(data, na.rm = TRUE)\n  std_error &lt;- sd(data, na.rm = TRUE) / sqrt(n)\n  t_val &lt;- qt(alfa, dof)\n  \n  avg + c(-1, +1) * t_val * std_error\n}\n\nci(piero)\n#&gt; [1] 0.7737881 0.9573230\n\n# 2\n# In seguito vedremo come questo modo di organizzare i dati non sia ottimale\nrisultati &lt;- data.frame(piero = piero,\n                        pina = c(1.09, 0.89, 0.74, 1.07, 0.68,\n                                 0.89, 1.25, 1.10, 0.86, 0.88))\nlapply(risultati, ci)\n#&gt; $piero\n#&gt; [1] 0.7737881 0.9573230\n#&gt; \n#&gt; $pina\n#&gt; [1] 0.8180479 1.0719521\nt.test(risultati$piero, risultati$pina)\n#&gt; \n#&gt;  Welch Two Sample t-test\n#&gt; \n#&gt; data:  risultati$piero and risultati$pina\n#&gt; t = -1.1548, df = 15.825, p-value = 0.2653\n#&gt; alternative hypothesis: true difference in means is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;  -0.22541955  0.06653066\n#&gt; sample estimates:\n#&gt; mean of x mean of y \n#&gt; 0.8655556 0.9450000",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "transform.html",
    "href": "transform.html",
    "title": "4  Manipolare i dati con data.table",
    "section": "",
    "text": "4.1 Il pacchetto data.table\nRispetto ai tradizionali data.frame trattati nella Sezione 3.2.5, il pacchetto data.table offre uno strumento più potente, efficiente e flessibile per gestire e manipolare i dati.\nCreare una data.table è semplice e molto simile a creare un data.frame. Ecco un esempio:\nlibrary(data.table) # carico il pacchetto\n\ndt &lt;- data.table(\n  id = rep(c(\"a\", \"b\", \"c\", \"d\", \"e\"), each = 10),\n  a = sample(letters, 50, replace = TRUE),\n  b = rnorm(50)\n)\nSe si ha già un data.frame, è possibile convertirlo in una data.table usando la funzione setDT().\nLa sintassi di base del pacchetto data.table si ispira, con buona dose di creatività, al linguaggio SQL, integrandolo con il sistema di indicizzazione di base di R per selezionare e modificare i dati:\ndt[i, j, by]\nTutti e tre gli argomenti sono opzionali: se omessi, vengono restituiti tutti i dati.\nIn altre parole, l’istruzione data si legge così:\nVediamo subito un esempio pratico:\n# prendi dt, ordina per id in ordine decrescente e calcola la media di b per ogni id\ndt[order(-id), .(avg = mean(b)), by = id]\n#&gt;        id         avg\n#&gt;    &lt;char&gt;       &lt;num&gt;\n#&gt; 1:      e  0.62033804\n#&gt; 2:      d -0.34352763\n#&gt; 3:      c  0.14841647\n#&gt; 4:      b  0.19524443\n#&gt; 5:      a  0.06563361\nPer sfruttare appieno le potenzialità di data.table, il passo successivo sarà imparare a importare dati da file esterni.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "transform.html#sec-load",
    "href": "transform.html#sec-load",
    "title": "4  Manipolare i dati con data.table",
    "section": "",
    "text": "i serve per filtrare o ordinare le righe (simile a WHERE e ORDER BY in SQL);\nj permette di selezionare o modificare colonne (come SELECT e UPDATE in SQL);\nby consente di ripetere le operazioni per ogni gruppo di dati (equivalente a GROUP BY in SQL).\n\n\n\n\nprendi la data.table dt, filtra o ordina le righe con i, seleziona o calcola j e ripeti l’operazione per ogni gruppo definito da by.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "transform.html#importare-i-dati",
    "href": "transform.html#importare-i-dati",
    "title": "4  Manipolare i dati con data.table",
    "section": "4.2 Importare i dati",
    "text": "4.2 Importare i dati\n\n4.2.1 File .csv, .tsv e .gz\nLa funzione fread() del pacchetto data.table consente di importare facilmente dati in formato .csv, .tsv. Inoltre, supporta anche l’importazione di file compressi, come quelli con estensione .gz, grazie al supporto del pacchetto R.utils.\nfread() cerca di riconoscere automaticamente il tipo di dati nelle varie colonne (numeri, date, testi), ma è sempre buona pratica verificare il risultato dell’importazione.\nEcco un esempio:\n\npm_genova &lt;- fread(\"data/2025-04-24_pm1025_ambiente_liguria.csv.gz\",\n                   skip = \"Codice europeo\", # salta fino alla riga contenente \"Codice europeo\"\n                   encoding = \"Latin-1\") # gestisce accenti e caratteri speciali\n# Il dataset proviene da Ambiente in Liguria ed è stato modificato a scopo di didattico\n\nstr(pm_genova)\n#&gt; Classes 'data.table' and 'data.frame':   122376 obs. of  10 variables:\n#&gt;  $ Codice europeo : chr  \"IT2302A\" \"IT2302A\" \"IT1698A\" \"IT1698A\" ...\n#&gt;  $ Inquinante     : chr  \"PM10\" \"PM2,5\" \"PM10\" \"PM2,5\" ...\n#&gt;  $ Metodo         : chr  \"CAMP. CONTINUO, RAGGI BETA\" \"CAMP. CONTINUO, RAGGI BETA\" \"CAMP. CONTINUO, RAGGI BETA\" \"CAMP. CONTINUO, RAGGI BETA\" ...\n#&gt;  $ Unità di misura: chr  \"microg/m3\" \"microg/m3\" \"microg/m3\" \"microg/m3\" ...\n#&gt;  $ Data inizio    : chr  \"31/12/2024 23:00\" \"31/12/2024 23:00\" \"31/12/2024 23:00\" \"31/12/2024 23:00\" ...\n#&gt;  $ Data fine      : chr  \"01/01/2025 00:00\" \"01/01/2025 00:00\" \"01/01/2025 00:00\" \"01/01/2025 00:00\" ...\n#&gt;  $ Valore         : num  17.5 13.9 50.7 31.1 12.8 12.4 48.5 37.7 66.5 60.3 ...\n#&gt;  $ Valido         : chr  \"SI\" \"SI\" \"SI\" \"SI\" ...\n#&gt;  $ Validato COR   : chr  \"SI\" \"SI\" \"SI\" \"SI\" ...\n#&gt;  $ Certificato    : chr  \"ancora da esaminare\" \"ancora da esaminare\" \"ancora da esaminare\" \"ancora da esaminare\" ...\n#&gt;  - attr(*, \".internal.selfref\")=&lt;externalptr&gt;\n\nNel dataset importato è possibile notare che sono state distinte le colonne numeriche da quelle testuali, ma ci sono ancora aspetti da migliorare:\n\ni nomi delle colonne contengono spazi e lettere maiuscole;\nl’unità di misura è riportata come \\(microg/m3\\) e non come \\(\\mu g/m^3\\);\nle colonne Data inizio e Data fine sono riconosciute come testo anziché come date e ore;\nle colonne Valido, Validato COR e Certificato andrebbero codificare come valori logici;\nl’unica informazione sul punto di prelievo è fornita dal codice europeo.\n\nNelle prossime sezioni verranno affrontati e risolti questi problemi.\n\n\n4.2.2 File xlsx\nPer importare file Excel è necessario utilizzare il pacchetto readxl, come mostrato nell’esempio:\n\nlibrary(readxl)\n\nstazioni &lt;- read_excel(\"data/2025-04-24_anagrafica_stazioni.xlsx\",\n                       sheet = \"Tabella 1\") |&gt; \n  setDT() # converte il dataset in data.table\n# Il dataset proviene dalla sezione Dati e indicatori - Aria del sito di ISPRA\n# ed è stato modificato a scopo didattico\n\nstr(stazioni)\n#&gt; Classes 'data.table' and 'data.frame':   596 obs. of  11 variables:\n#&gt;  $ id_regione     : num  1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  $ id_provincia   : num  1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  $ id_comune      : num  1e+06 1e+06 1e+06 1e+06 1e+06 ...\n#&gt;  $ station_eu_code: chr  \"IT1128A\" \"IT1963A\" \"IT2101A\" \"IT1121A\" ...\n#&gt;  $ station_code   : num  1e+05 1e+05 1e+05 1e+05 1e+05 ...\n#&gt;  $ regione        : chr  \"Piemonte\" \"Piemonte\" \"Piemonte\" \"Piemonte\" ...\n#&gt;  $ provincia      : chr  \"Torino\" \"Torino\" \"Torino\" \"Torino\" ...\n#&gt;  $ comune         : chr  \"Borgaro Torinese\" \"Ceresole Reale\" \"Chieri\" \"Druento\" ...\n#&gt;  $ nome_stazione  : chr  \"Borgaro T. - Caduti\" \"Ceresole Reale - Diga\" \"Chieri - Bersezio\" \"Druento - La Mandria\" ...\n#&gt;  $ tipo_zona      : chr  \"S\" \"R\" \"S\" \"R\" ...\n#&gt;  $ tipo_stazione  : chr  \"F\" \"F\" \"F\" \"F\" ...\n#&gt;  - attr(*, \".internal.selfref\")=&lt;externalptr&gt;\n\nAnche in questo caso, read_excel() cerca di identificare automaticamente i tipi di dati nelle diverse colonne: distingue senza problemi tra numeri e caratteri, ma non riconosce tipo_zona come fattore. A differenza di fread(), read_excel() non restituisce direttamente una data.table.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "transform.html#sec-filter",
    "href": "transform.html#sec-filter",
    "title": "4  Manipolare i dati con data.table",
    "section": "4.3 Filtrare i dati",
    "text": "4.3 Filtrare i dati\nApplicare un filtro ai dati è uno dei modi più semplici per concentrarsi sulle informazioni di interesse. Con data.table, i filtri si applicano sempre sull’elemento i della sintassi dt[i, j, by].\nIn generale, un filtro può essere scritto come\ndt[elemento %operatore% valore, ]\n\ndove: - dt è la data.table da filtrare; - variabile è tipicamente il nome di una colonna di dt; - %operatore% indica il tipo di confronto o filtro da applicare; - valore è il valore con cui confrontare le variabile.\nLa condizione variabile %operatore% valore definisce quali righe saranno selezionate.\nAd esempio, per filtrare le stazioni della Liguria nella data.table stazioni, si scrive:\n\nstazioni[regione == \"Liguria\", ]\n#&gt;     id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;          &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;  &lt;char&gt;\n#&gt;  1:          7            8   7008055         IT1882A       700806 Liguria\n#&gt;  2:          7            9   7009002         IT2038A       700972 Liguria\n#&gt;  3:          7            9   7009010         IT2303A       700979 Liguria\n#&gt;  4:          7            9   7009015         IT2107A       700973 Liguria\n#&gt;  5:          7            9   7009015         IT2108A       700974 Liguria\n#&gt;  6:          7            9   7009015         IT2299A       700978 Liguria\n#&gt;  7:          7            9   7009023         IT2155A       700975 Liguria\n#&gt;  8:          7            9   7009052         IT1144A       700909 Liguria\n#&gt;  9:          7            9   7009056         IT1145A       700903 Liguria\n#&gt; 10:          7            9   7009056         IT1883A       700971 Liguria\n#&gt; 11:          7            9   7009056         IT2304A       700980 Liguria\n#&gt; 12:          7            9   7009064         IT1143A       700910 Liguria\n#&gt; 13:          7            9   7009064         IT2286A       700977 Liguria\n#&gt; 14:          7           10   7010006         IT2323A       701082 Liguria\n#&gt; 15:          7           10   7010009         IT1549A       701028 Liguria\n#&gt; 16:          7           10   7010015         IT2302A       701081 Liguria\n#&gt; 17:          7           10   7010025         IT0852A       701014 Liguria\n#&gt; 18:          7           10   7010025         IT0854A       701009 Liguria\n#&gt; 19:          7           10   7010025         IT0858A       701016 Liguria\n#&gt; 20:          7           10   7010025         IT1698A       701068 Liguria\n#&gt; 21:          7           10   7010025         IT1884A       701073 Liguria\n#&gt; 22:          7           10   7010032         IT2298A       701080 Liguria\n#&gt; 23:          7           10   7010046         IT2039A       701078 Liguria\n#&gt; 24:          7           11   7011015         IT1456A       701105 Liguria\n#&gt; 25:          7           11   7011015         IT1457A       701106 Liguria\n#&gt; 26:          7           11   7011015         IT1536A       701113 Liguria\n#&gt; 27:          7           11   7011015         IT1544A       701112 Liguria\n#&gt; 28:          7           11   7011015         IT1886A       701175 Liguria\n#&gt; 29:          7           11   7011026         IT1661A       701173 Liguria\n#&gt; 30:          7           11   7011027         IT2229A       701176 Liguria\n#&gt;     id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;     provincia                 comune                          nome_stazione\n#&gt;        &lt;char&gt;                 &lt;char&gt;                                 &lt;char&gt;\n#&gt;  1:   Imperia                Sanremo              PIAZZA BATTISTI - SANREMO\n#&gt;  2:    Savona                Albenga              REGIONE CAVALLO - ALBENGA\n#&gt;  3:    Savona               Bergeggi                BERGEGGI SV - CAPO VADO\n#&gt;  4:    Savona       Cairo Montenotte  LOCALITA' MAZZUCCA - CAIRO MONTENOTTE\n#&gt;  5:    Savona       Cairo Montenotte    LOCALITA' BRAGNO - CAIRO MONTENOTTE\n#&gt;  6:    Savona       Cairo Montenotte        CAIRO M. SV - VILLA SANGUINETTI\n#&gt;  7:    Savona                 Cengio                 CENGIO - RIO PARASACCO\n#&gt;  8:    Savona               Quiliano            MERCATO GENERALE - QUILIANO\n#&gt;  9:    Savona                 Savona                   CORSO RICCI - SAVONA\n#&gt; 10:    Savona                 Savona                       VARALDO - SAVONA\n#&gt; 11:    Savona                 Savona             SAVONA - MONTE SAN GIORGIO\n#&gt; 12:    Savona            Vado Ligure   VIA AURELIA - VIA FERRARIS - VADO L.\n#&gt; 13:    Savona            Vado Ligure             VIA DE LITTA - VADO LIGURE\n#&gt; 14:    Genova                Busalla                    BUSALLA GE - SUARDI\n#&gt; 15:    Genova            Campomorone                  CAMPORA - CAMPOMORONE\n#&gt; 16:    Genova               Chiavari                   CHIAVARI GE - DEVOTO\n#&gt; 17:    Genova                 Genova               MULTEDO - PEGLI - GENOVA\n#&gt; 18:    Genova                 Genova                 CORSO FIRENZE - GENOVA\n#&gt; 19:    Genova                 Genova                        QUARTO - GENOVA\n#&gt; 20:    Genova                 Genova CORSO EUROPA - VIA S. MARTINO - GENOVA\n#&gt; 21:    Genova                 Genova            CORSO BUENOS AIRES - GENOVA\n#&gt; 22:    Genova                 Masone                              MASONE GE\n#&gt; 23:    Genova                Rapallo        CAMPO SPORTIVO MACERA - RAPALLO\n#&gt; 24: La Spezia              La Spezia     SAN CIPRIANO - LIBERTA - LA SPEZIA\n#&gt; 25: La Spezia              La Spezia                   AMENDOLA - LA SPEZIA\n#&gt; 26: La Spezia              La Spezia                 MAGGIOLINA - LA SPEZIA\n#&gt; 27: La Spezia              La Spezia                FOSSAMASTRA - LA SPEZIA\n#&gt; 28: La Spezia              La Spezia           PIAZZA SAINT BON - LA SPEZIA\n#&gt; 29: La Spezia Santo Stefano di Magra                    SANTO STEFANO MAGRA\n#&gt; 30: La Spezia                Sarzana                LARGO PERTINI - SARZANA\n#&gt;     provincia                 comune                          nome_stazione\n#&gt;           tipo_zona tipo_stazione\n#&gt;              &lt;char&gt;        &lt;char&gt;\n#&gt;  1:               U             T\n#&gt;  2:               U             T\n#&gt;  3:               S             I\n#&gt;  4:               S             I\n#&gt;  5:               S             I\n#&gt;  6:               U             F\n#&gt;  7: RURALE-NEARCITY             F\n#&gt;  8:               S             I\n#&gt;  9:               U             T\n#&gt; 10:               U             F\n#&gt; 11:               R             I\n#&gt; 12:               U             T\n#&gt; 13:               S             I\n#&gt; 14:               U             T\n#&gt; 15:               S             F\n#&gt; 16:               U             F\n#&gt; 17:               U             T\n#&gt; 18:               U             F\n#&gt; 19:               U             F\n#&gt; 20:               U             T\n#&gt; 21:               U             T\n#&gt; 22:               S             F\n#&gt; 23:               U             T\n#&gt; 24:               U             T\n#&gt; 25:               U             T\n#&gt; 26:               U             F\n#&gt; 27:               U             I\n#&gt; 28:               U             T\n#&gt; 29:               S             T\n#&gt; 30:               U             T\n#&gt;           tipo_zona tipo_stazione\n\nGli operatori più comuni sono:\n\n==, &lt;, &lt;=, &gt;, &gt;=, !=: confrontano la variabile con il valore e selezionano rispettivamente righe con valori uguali, minori, minori o uguali, maggiori, maggiori o uguali, o diversi dal valore. Questi operatori funzionano sia con valori numerici sia con stringhe di testo. Attenzione: usare &lt; o &gt; con testo permette di filtrare per ordine alfabetico, ma questo uso non è consigliato.\n%like%: permette di cercare corrispondenze parziali all’interno di stringhe. Per esempio, nella colonna nome_stazione della data.table stazioni, si vogliono estrarre le informazioni relative alle stazioni identificate come LOCALITA’ MAZZUCCA - CAIRO MONTENOTTE, LOCALITA’ BRAGNO - CAIRO MONTENOTTE, CAIRO M. SV - VILLA SANGUINETTI. Non è possibile usare == CAIRO, perché il valore CAIRO può comparire in posizioni diverse o in forma abbreviata nel nome. Si può risolvere così:\n\n\nstazioni[nome_stazione %like% \"CAIR\",]\n#&gt;    id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;         &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;  &lt;char&gt;\n#&gt; 1:          7            9   7009015         IT2107A       700973 Liguria\n#&gt; 2:          7            9   7009015         IT2108A       700974 Liguria\n#&gt; 3:          7            9   7009015         IT2299A       700978 Liguria\n#&gt;    provincia           comune                         nome_stazione tipo_zona\n#&gt;       &lt;char&gt;           &lt;char&gt;                                &lt;char&gt;    &lt;char&gt;\n#&gt; 1:    Savona Cairo Montenotte LOCALITA' MAZZUCCA - CAIRO MONTENOTTE         S\n#&gt; 2:    Savona Cairo Montenotte   LOCALITA' BRAGNO - CAIRO MONTENOTTE         S\n#&gt; 3:    Savona Cairo Montenotte       CAIRO M. SV - VILLA SANGUINETTI         U\n#&gt;    tipo_stazione\n#&gt;           &lt;char&gt;\n#&gt; 1:             I\n#&gt; 2:             I\n#&gt; 3:             F\n\nPer selezionare invece tutte le righe che non contengono “CAIR”, si usa:\n\nstazioni[!(nome_stazione %like% \"CAIR\"),]\n#&gt;      id_regione id_provincia id_comune station_eu_code station_code  regione\n#&gt;           &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;   &lt;char&gt;\n#&gt;   1:          1            1   1001028         IT1128A       100114 Piemonte\n#&gt;   2:          1            1   1001073         IT1963A       100168 Piemonte\n#&gt;   3:          1            1   1001078         IT2101A       100171 Piemonte\n#&gt;   4:          1            1   1001099         IT1121A       100122 Piemonte\n#&gt;   5:          1            1   1001125         IT1788A       100165 Piemonte\n#&gt;  ---                                                                        \n#&gt; 589:         20          111  20111057         IT1273A      2009207 Sardegna\n#&gt; 590:         20          111  20111057         IT1575A      2009221 Sardegna\n#&gt; 591:         20          111  20111057         IT1576A      2009222 Sardegna\n#&gt; 592:         20          111  20111062         IT1994A      2010601 Sardegna\n#&gt; 593:         20          111  20111082         IT2011A      2009239 Sardegna\n#&gt;         provincia              comune         nome_stazione     tipo_zona\n#&gt;            &lt;char&gt;              &lt;char&gt;                &lt;char&gt;        &lt;char&gt;\n#&gt;   1:       Torino    Borgaro Torinese   Borgaro T. - Caduti             S\n#&gt;   2:       Torino      Ceresole Reale Ceresole Reale - Diga             R\n#&gt;   3:       Torino              Chieri     Chieri - Bersezio             S\n#&gt;   4:       Torino             Druento  Druento - La Mandria             R\n#&gt;   5:       Torino               Ivrea   Ivrea - Liberazione             S\n#&gt;  ---                                                                     \n#&gt; 589: Sud Sardegna          Portoscuso                CENPS4             S\n#&gt; 590: Sud Sardegna          Portoscuso                CENPS6             S\n#&gt; 591: Sud Sardegna          Portoscuso                CENPS7             S\n#&gt; 592: Sud Sardegna San Gavino Monreale                CENSG3             U\n#&gt; 593: Sud Sardegna               Seulo                CENSE0 RURALE-REMOTA\n#&gt;      tipo_stazione\n#&gt;             &lt;char&gt;\n#&gt;   1:             F\n#&gt;   2:             F\n#&gt;   3:             F\n#&gt;   4:             F\n#&gt;   5:             F\n#&gt;  ---              \n#&gt; 589:             F\n#&gt; 590:             I\n#&gt; 591:             F\n#&gt; 592:             F\n#&gt; 593:             F\n\n\n%in% e %notin%: selezionano righe in cui il valore della variabile è rispettivamente presente o assente in un vettore di valori. Per esempio, per filtrare le stazioni dei comuni di Vado Ligure e Quiliano:\n\n\nstazioni[comune %in% c(\"Vado Ligure\", \"Quiliano\"),]\n#&gt;    id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;         &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;  &lt;char&gt;\n#&gt; 1:          7            9   7009052         IT1144A       700909 Liguria\n#&gt; 2:          7            9   7009064         IT1143A       700910 Liguria\n#&gt; 3:          7            9   7009064         IT2286A       700977 Liguria\n#&gt;    provincia      comune                        nome_stazione tipo_zona\n#&gt;       &lt;char&gt;      &lt;char&gt;                               &lt;char&gt;    &lt;char&gt;\n#&gt; 1:    Savona    Quiliano          MERCATO GENERALE - QUILIANO         S\n#&gt; 2:    Savona Vado Ligure VIA AURELIA - VIA FERRARIS - VADO L.         U\n#&gt; 3:    Savona Vado Ligure           VIA DE LITTA - VADO LIGURE         S\n#&gt;    tipo_stazione\n#&gt;           &lt;char&gt;\n#&gt; 1:             I\n#&gt; 2:             T\n#&gt; 3:             I\n\nÈ possibile combinare più condizioni usando gli operatori logici & (e) e | (o):\n\n& seleziona righe che soddisfano tutte le condizioni;\n| seleziona righe che soddisfano almeno una.\n\nAd esempio, per filtrare le stazioni nella provincia di Savona o nel comune di Sanremo:\n\nstazioni[provincia == \"Savona\" | comune == \"Sanremo\",]\n#&gt;     id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;          &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;  &lt;char&gt;\n#&gt;  1:          7            8   7008055         IT1882A       700806 Liguria\n#&gt;  2:          7            9   7009002         IT2038A       700972 Liguria\n#&gt;  3:          7            9   7009010         IT2303A       700979 Liguria\n#&gt;  4:          7            9   7009015         IT2107A       700973 Liguria\n#&gt;  5:          7            9   7009015         IT2108A       700974 Liguria\n#&gt;  6:          7            9   7009015         IT2299A       700978 Liguria\n#&gt;  7:          7            9   7009023         IT2155A       700975 Liguria\n#&gt;  8:          7            9   7009052         IT1144A       700909 Liguria\n#&gt;  9:          7            9   7009056         IT1145A       700903 Liguria\n#&gt; 10:          7            9   7009056         IT1883A       700971 Liguria\n#&gt; 11:          7            9   7009056         IT2304A       700980 Liguria\n#&gt; 12:          7            9   7009064         IT1143A       700910 Liguria\n#&gt; 13:          7            9   7009064         IT2286A       700977 Liguria\n#&gt;     provincia           comune                         nome_stazione\n#&gt;        &lt;char&gt;           &lt;char&gt;                                &lt;char&gt;\n#&gt;  1:   Imperia          Sanremo             PIAZZA BATTISTI - SANREMO\n#&gt;  2:    Savona          Albenga             REGIONE CAVALLO - ALBENGA\n#&gt;  3:    Savona         Bergeggi               BERGEGGI SV - CAPO VADO\n#&gt;  4:    Savona Cairo Montenotte LOCALITA' MAZZUCCA - CAIRO MONTENOTTE\n#&gt;  5:    Savona Cairo Montenotte   LOCALITA' BRAGNO - CAIRO MONTENOTTE\n#&gt;  6:    Savona Cairo Montenotte       CAIRO M. SV - VILLA SANGUINETTI\n#&gt;  7:    Savona           Cengio                CENGIO - RIO PARASACCO\n#&gt;  8:    Savona         Quiliano           MERCATO GENERALE - QUILIANO\n#&gt;  9:    Savona           Savona                  CORSO RICCI - SAVONA\n#&gt; 10:    Savona           Savona                      VARALDO - SAVONA\n#&gt; 11:    Savona           Savona            SAVONA - MONTE SAN GIORGIO\n#&gt; 12:    Savona      Vado Ligure  VIA AURELIA - VIA FERRARIS - VADO L.\n#&gt; 13:    Savona      Vado Ligure            VIA DE LITTA - VADO LIGURE\n#&gt;           tipo_zona tipo_stazione\n#&gt;              &lt;char&gt;        &lt;char&gt;\n#&gt;  1:               U             T\n#&gt;  2:               U             T\n#&gt;  3:               S             I\n#&gt;  4:               S             I\n#&gt;  5:               S             I\n#&gt;  6:               U             F\n#&gt;  7: RURALE-NEARCITY             F\n#&gt;  8:               S             I\n#&gt;  9:               U             T\n#&gt; 10:               U             F\n#&gt; 11:               R             I\n#&gt; 12:               U             T\n#&gt; 13:               S             I",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "transform.html#selezionare-le-colonne",
    "href": "transform.html#selezionare-le-colonne",
    "title": "4  Manipolare i dati con data.table",
    "section": "4.4 Selezionare le colonne",
    "text": "4.4 Selezionare le colonne\nI filtri visti nella Sezione 4.3 agiscono sulle righe del dataset, ma non permettono di di selezionare direttamente le colonne di interesse. Per fare questo, si utilizza l’elemento j della sintassi dt[i, j, by].\nAd esempio, per estrarre i codici europei delle stazioni liguri:\n\nstazioni[regione == \"Liguria\", station_eu_code]\n#&gt;  [1] \"IT1882A\" \"IT2038A\" \"IT2303A\" \"IT2107A\" \"IT2108A\" \"IT2299A\" \"IT2155A\"\n#&gt;  [8] \"IT1144A\" \"IT1145A\" \"IT1883A\" \"IT2304A\" \"IT1143A\" \"IT2286A\" \"IT2323A\"\n#&gt; [15] \"IT1549A\" \"IT2302A\" \"IT0852A\" \"IT0854A\" \"IT0858A\" \"IT1698A\" \"IT1884A\"\n#&gt; [22] \"IT2298A\" \"IT2039A\" \"IT1456A\" \"IT1457A\" \"IT1536A\" \"IT1544A\" \"IT1886A\"\n#&gt; [29] \"IT1661A\" \"IT2229A\"\n\nQuesto restituisce un vettore. Se invece si vuole mantenere la struttura di una data.table (utile per ulteriori elaborazioni), è necessario racchiudere la colonna in .():\n\nstazioni[regione == \"Liguria\", .(station_eu_code)]\n#&gt;     station_eu_code\n#&gt;              &lt;char&gt;\n#&gt;  1:         IT1882A\n#&gt;  2:         IT2038A\n#&gt;  3:         IT2303A\n#&gt;  4:         IT2107A\n#&gt;  5:         IT2108A\n#&gt;  6:         IT2299A\n#&gt;  7:         IT2155A\n#&gt;  8:         IT1144A\n#&gt;  9:         IT1145A\n#&gt; 10:         IT1883A\n#&gt; 11:         IT2304A\n#&gt; 12:         IT1143A\n#&gt; 13:         IT2286A\n#&gt; 14:         IT2323A\n#&gt; 15:         IT1549A\n#&gt; 16:         IT2302A\n#&gt; 17:         IT0852A\n#&gt; 18:         IT0854A\n#&gt; 19:         IT0858A\n#&gt; 20:         IT1698A\n#&gt; 21:         IT1884A\n#&gt; 22:         IT2298A\n#&gt; 23:         IT2039A\n#&gt; 24:         IT1456A\n#&gt; 25:         IT1457A\n#&gt; 26:         IT1536A\n#&gt; 27:         IT1544A\n#&gt; 28:         IT1886A\n#&gt; 29:         IT1661A\n#&gt; 30:         IT2229A\n#&gt;     station_eu_code\n\nAll’interno di .() è possibile elencare più colonne, rinominarle o applicare operazioni. Il risultato verrà mostrato a video, ma non salvato a meno che non venga assegnato a una variabile.\nEcco alcuni esempi:\n\n# seleziona due colonne\nstazioni[regione == \"Liguria\", .(station_eu_code, id_comune)]\n#&gt;     station_eu_code id_comune\n#&gt;              &lt;char&gt;     &lt;num&gt;\n#&gt;  1:         IT1882A   7008055\n#&gt;  2:         IT2038A   7009002\n#&gt;  3:         IT2303A   7009010\n#&gt;  4:         IT2107A   7009015\n#&gt;  5:         IT2108A   7009015\n#&gt;  6:         IT2299A   7009015\n#&gt;  7:         IT2155A   7009023\n#&gt;  8:         IT1144A   7009052\n#&gt;  9:         IT1145A   7009056\n#&gt; 10:         IT1883A   7009056\n#&gt; 11:         IT2304A   7009056\n#&gt; 12:         IT1143A   7009064\n#&gt; 13:         IT2286A   7009064\n#&gt; 14:         IT2323A   7010006\n#&gt; 15:         IT1549A   7010009\n#&gt; 16:         IT2302A   7010015\n#&gt; 17:         IT0852A   7010025\n#&gt; 18:         IT0854A   7010025\n#&gt; 19:         IT0858A   7010025\n#&gt; 20:         IT1698A   7010025\n#&gt; 21:         IT1884A   7010025\n#&gt; 22:         IT2298A   7010032\n#&gt; 23:         IT2039A   7010046\n#&gt; 24:         IT1456A   7011015\n#&gt; 25:         IT1457A   7011015\n#&gt; 26:         IT1536A   7011015\n#&gt; 27:         IT1544A   7011015\n#&gt; 28:         IT1886A   7011015\n#&gt; 29:         IT1661A   7011026\n#&gt; 30:         IT2229A   7011027\n#&gt;     station_eu_code id_comune\n\n# rinomina le colonne\nstazioni[regione == \"Liguria\", .(eu_id = station_eu_code, \n                                 municipality_id = id_comune)]\n#&gt;       eu_id municipality_id\n#&gt;      &lt;char&gt;           &lt;num&gt;\n#&gt;  1: IT1882A         7008055\n#&gt;  2: IT2038A         7009002\n#&gt;  3: IT2303A         7009010\n#&gt;  4: IT2107A         7009015\n#&gt;  5: IT2108A         7009015\n#&gt;  6: IT2299A         7009015\n#&gt;  7: IT2155A         7009023\n#&gt;  8: IT1144A         7009052\n#&gt;  9: IT1145A         7009056\n#&gt; 10: IT1883A         7009056\n#&gt; 11: IT2304A         7009056\n#&gt; 12: IT1143A         7009064\n#&gt; 13: IT2286A         7009064\n#&gt; 14: IT2323A         7010006\n#&gt; 15: IT1549A         7010009\n#&gt; 16: IT2302A         7010015\n#&gt; 17: IT0852A         7010025\n#&gt; 18: IT0854A         7010025\n#&gt; 19: IT0858A         7010025\n#&gt; 20: IT1698A         7010025\n#&gt; 21: IT1884A         7010025\n#&gt; 22: IT2298A         7010032\n#&gt; 23: IT2039A         7010046\n#&gt; 24: IT1456A         7011015\n#&gt; 25: IT1457A         7011015\n#&gt; 26: IT1536A         7011015\n#&gt; 27: IT1544A         7011015\n#&gt; 28: IT1886A         7011015\n#&gt; 29: IT1661A         7011026\n#&gt; 30: IT2229A         7011027\n#&gt;       eu_id municipality_id\n\n# conta il numero di stazioni liguri\nstazioni[regione == \"Liguria\", length(station_eu_code)]\n#&gt; [1] 30\nstazioni[regione == \"Liguria\", .N] # alternativa più veloce\n#&gt; [1] 30\n\n# salva il risultato in una variabile\nliguria_eu_id &lt;- stazioni[regione == \"Liguria\", station_eu_code]",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "transform.html#modificare-le-colonne",
    "href": "transform.html#modificare-le-colonne",
    "title": "4  Manipolare i dati con data.table",
    "section": "4.5 Modificare le colonne",
    "text": "4.5 Modificare le colonne",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "transform.html#cambiare-forma-ai-dati",
    "href": "transform.html#cambiare-forma-ai-dati",
    "title": "4  Manipolare i dati con data.table",
    "section": "4.6 Cambiare forma ai dati",
    "text": "4.6 Cambiare forma ai dati",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "transform.html#unire-più-fonti-di-dati",
    "href": "transform.html#unire-più-fonti-di-dati",
    "title": "4  Manipolare i dati con data.table",
    "section": "4.7 Unire più fonti di dati",
    "text": "4.7 Unire più fonti di dati",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "transform.html#fare-calcoli-su-gruppi-di-dati",
    "href": "transform.html#fare-calcoli-su-gruppi-di-dati",
    "title": "4  Manipolare i dati con data.table",
    "section": "4.8 Fare calcoli su gruppi di dati",
    "text": "4.8 Fare calcoli su gruppi di dati",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  }
]