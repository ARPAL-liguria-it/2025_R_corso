[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Corso di R: dalle basi alla prima analisi dei dati",
    "section": "",
    "text": "Prefazione\nQuesto documento raccoglie il materiale presentato durante l’omonimo corso tenuto in ARPAL nel 2025.\nIl corso e l’annesso documento nascono dalla volontà degli autori di condividere con i colleghi la potenza e la bellezza di utilizzare un linguaggio di programmazione nell’analisi dei dati.\nIl linguaggio di programmazione scelto è R, in quanto permette sin da subito di eseguire semplici analisi di dati, richiedendo l’apprendimento di una sintassi intuitiva e di alcune funzioni, in gran parte già pronte o disponibili in librerie specializzate. Inoltre, con R è facile creare grafici efficaci e ricchi di contenuto.\nQuesto documento è rilasciato gratuitamente con licenza Creative Commons CC BY-NC-SA 4.0.",
    "crumbs": [
      "Prefazione"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduzione",
    "section": "",
    "text": "1.1 Quanta fatica\nLo scopo del corso è fornire gli strumenti necessari per eseguire semplici analisi dei dati utilizzando il linguaggio R.\nIl corso si conclude con una piccola analisi guidata svolta dai partecipanti e strutturata in un documento a sé stante.\nDurante il proseguo del corso impareremo a:\nL’utilizzo di un linguaggio di programmazione richiede un importante investimento iniziale per apprenderne le basi, le funzioni principali e il loro campo di applicazione. Tuttavia, l’impegno profuso viene ampiamente ripagato dalla possibilità di riutilizzare e adattare il codice, nonché di ripetere le analisi con poco sforzo, rendendo l’intero processo riproducibile e documentabile.\nInoltre, imparare un linguaggio di programmazione apre numerose porte e può semplificare il lavoro quotidiano in molti ambiti. Per esempio, con R è possibile realizzare:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "intro.html#quanta-fatica",
    "href": "intro.html#quanta-fatica",
    "title": "1  Introduzione",
    "section": "",
    "text": "documenti dinamici parametrizzati;\napplicazioni interattive accessibili via browser;\ninterfacce di programmazione (API) per l’esecuzione di funzioni da remoto.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "intro.html#prerequisiti",
    "href": "intro.html#prerequisiti",
    "title": "1  Introduzione",
    "section": "1.2 Prerequisiti",
    "text": "1.2 Prerequisiti\nIl corso è aperto a chiunque abbia una certa dimestichezza con il computer e una conoscenza di base della logica. Il candidato ideale ha già svolto qualche analisi su dati numerici, utilizzando strumenti statistici di base e fogli di calcolo. La conoscenza di un linguaggio di programmazione diverso da R non è necessaria, ma sicuramente rappresenta un vantaggio.\nPer eseguire il codice presentato durante il corso, è necessario installare R, RStudio e i seguenti pacchetti data.table, readxl, ggplot2, glue e gt.\n\n1.2.1 R\nR può essere scaricato dal Comprensive R Archive Network (CRAN), seguendo le istruzioni relative al proprio sistema operativo. Ogni anno viene rilasciata una nuova versione principale, accompagnata da circa tre aggiornamenti minori: se si intende usare R regolarmente, è consigliabile mantenere il software aggiornato.\nR è un software libero, distribuito sotto una combinazione di licenze GNU General Public License v2 e v3 e GNU Lesser General Public License v2.1.\n\n\n1.2.2 RStudio\nRStudio è l’ambiente di sviluppo integrato (IDE) più diffuso per R: permette la gestione completa di un progetto, la connessione a sorgenti dati esterne come database e l’integrazione con sistemi di gestione delle versioni come git. Può essere scaricato dal sito ufficiale di Posit.\nAnche RStudio è un software libero, rilasciato sotto licenza GNU Affero General Public License v3.\n\n\n\n\n\n\n\n\nFigura 1.1: Schermata di RStudio: in alto, da sinistra a destra, si trova il pannello dedicato al codice sorgente, al suo fianco il pannello dedicato agli ambienti e allo storico. In basso, da sinistra a destra, si trova la console e il pannello dedicato agli output.\n\n\n\n\n\nL’uso di RStudio o di un altro IDE non è strettamente necessario per utilizzare R, ma ne semplifica notevolmente l’impiego. Altri IDE comunemente utilizzati con R sono Visual Studio Code, Vim ed Emacs.\n\n\n1.2.3 I pacchetti di R\nLe funzionalità di R possono essere ampliate tramite pacchetti. La lista completa, molto ampia e variegata, è presente sul sito del CRAN. Alcuni di questi pacchetti sono sviluppati da appassionati, altri da statistici e ingegneri del software di fama mondiale. Tutte le funzioni e i dati contenuti in un pacchetto sono documentati, il codice sorgente è completamente consultabile e spesso è possibile collaborare direttamente allo sviluppo su piattaforme come GitHub. Molti pacchetti sono inoltre collegati a libri di testo o articoli scientifici.\nI pacchetti si installano in R con il comando:\n\ninstall.packages(\"pacchetto\")\n\nDurante il corso utilizzeremo alcuni pacchetti molto diffusi:\n\ndata.table: consente di caricare e manipolare efficientemente grandi insiemi di dati, con una sintassi particolare ma intuitiva;\nggplot2: il pacchetto di riferimento per la creazione di grafici;\nreadxl: utile per importare dati da fogli Excel;\nglue: semplifica la concatenazione di stringhe, anche se lo useremo raramente in modo diretto;\ngt: utilizzato per produrre tabelle di alta qualità. Le tabelle che vedrete nel corso saranno realizzate con questo pacchetto, anche se raramente lo useremo direttamente;\nR.utils: lo utilizzeremo solo per importare dati da file gz.\n\nInstalliamo i pacchetti richiesti racchiudendoli all’interno di un vettore con il comando c() e scrivendo il seguente comando all’interno della console di R, dopo il simbolo &gt;:\n\ninstall.packages(c(\"data.table\", \"readxl\", \"ggplot2\", \"glue\", \"gt\", \"R.utils\"))\n\nQuando ne avremo bisogno saremo pronti a caricare e usare tali pacchetti.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "intro.html#per-approfondire",
    "href": "intro.html#per-approfondire",
    "title": "1  Introduzione",
    "section": "1.3 Per approfondire",
    "text": "1.3 Per approfondire\nSe il materiale presentato nel corso non fosse sufficiente o non rispondesse pienamente alle vostre esigenze, in rete è possibile trovare numerosi testi gratuiti di alta qualità. Tra questi si segnalano:\n\nHands-On Rrogramming with R scritto da Garrett Grolemund;\nR for Data Science scritto da Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund;\nAdvanced R scritto da Hadley Wickham.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Le basi",
    "section": "",
    "text": "In questa prima parte inizieremo a prendere dimestichezza con le basi di R:\n\nnel primo capitolo partiremo dall’interazione con la console fino a scrivere ed eseguire il nostro primo script;\nnel secondo capitolo ci concentreremo sull’uso delle diverse tipologie di oggetti di R;\nnel terzo capitolo importeremo dati da file esterni;\nnel quarto capitolo inizieremo a fare i primi esperimenti di trasformazione dei dati con la libreria data.table.",
    "crumbs": [
      "Le basi"
    ]
  },
  {
    "objectID": "start.html",
    "href": "start.html",
    "title": "2  Il primo assaggio",
    "section": "",
    "text": "2.1 Una bella calcolatrice\nIniziamo a prendere confidenza con la console di R, utilizzandola come una calcolatrice, e scriviamo\n2 + 3\n#&gt; [1] 5\nR, in tutta la sua potenza, dovrebbe produrre\nQuesto significa che il risultato è un vettore composto da un solo elemento, e tale elemento è pari a 5.\nPossiamo anche eseguire calcoli su vettori: definiamo un vettore di 100 elementi che contiene gli interi da 1 a 100, e aggiungiamo 2 a ciascuno di essi.\n1:100 + 2\n#&gt;   [1]   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20\n#&gt;  [19]  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38\n#&gt;  [37]  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56\n#&gt;  [55]  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74\n#&gt;  [73]  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92\n#&gt;  [91]  93  94  95  96  97  98  99 100 101 102\nSe volessimo ripetere il calcolo ma aggiungendo 3 invece di 2, possiamo cliccare sulla console, schiacciare il tasto 🔼 per richiamare l’ultimo comando eseguito, modificare il 2 in 3 e premere Invio. Tuttavia, è preferibile assegnare il vettore contenente i 100 elementi a una variabile che chiameremo\na &lt;- 1:100\na questo punto possiamo fare\na + 3\n#&gt;   [1]   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21\n#&gt;  [19]  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39\n#&gt;  [37]  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57\n#&gt;  [55]  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75\n#&gt;  [73]  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93\n#&gt;  [91]  94  95  96  97  98  99 100 101 102 103\nPossiamo usare la variabile a per altri calcoli. Per esempio, eleviamo al quadrato tutti gli elementi associati alla variabile a:\na^2\n#&gt;   [1]     1     4     9    16    25    36    49    64    81   100   121   144\n#&gt;  [13]   169   196   225   256   289   324   361   400   441   484   529   576\n#&gt;  [25]   625   676   729   784   841   900   961  1024  1089  1156  1225  1296\n#&gt;  [37]  1369  1444  1521  1600  1681  1764  1849  1936  2025  2116  2209  2304\n#&gt;  [49]  2401  2500  2601  2704  2809  2916  3025  3136  3249  3364  3481  3600\n#&gt;  [61]  3721  3844  3969  4096  4225  4356  4489  4624  4761  4900  5041  5184\n#&gt;  [73]  5329  5476  5625  5776  5929  6084  6241  6400  6561  6724  6889  7056\n#&gt;  [85]  7225  7396  7569  7744  7921  8100  8281  8464  8649  8836  9025  9216\n#&gt;  [97]  9409  9604  9801 10000\nIl valore di una variabile può essere sovrascritto con una nuova assegnazione, come nel caso riportato di seguito:\na &lt;- \"Bella zio: sto usando R!\"\nNella creazione di variabili è bene fare caso ad alcune regole:\nDurante il corso utilizzeremo nomi di variabili e funzioni scritti in caratteri minuscoli e senza lettere accentate, utilizzando gli underscore al posto degli spazi (notazione snake_case).",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#una-bella-calcolatrice",
    "href": "start.html#una-bella-calcolatrice",
    "title": "2  Il primo assaggio",
    "section": "",
    "text": "[1] 5\n\n\n\n\n\n\n\n\n\n\n\n\n\nR è case sensitive, quindi f ed F sono due variabili diverse;\nnon sono ammesse variabili che iniziano con numeri (come 1variabile);\nnon sono ammessi caratteri diversi da lettere, numeri e underscore, compresi gli spazi;\nsono ammessi caratteri accentati, ma il loro uso può complicare molto la vita.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#funzioni",
    "href": "start.html#funzioni",
    "title": "2  Il primo assaggio",
    "section": "2.2 Funzioni",
    "text": "2.2 Funzioni\nLe funzioni sono una parte fondamentale di R e consentono di eseguire una serie di operazioni dati degli input, per ottenere nessuno, uno o più output. Si tratta di una definizione generale, perché le funzioni sono elementi estremamente versatili e le incontreremo ovunque. Durante il corso non distingueremo tra funzioni e metodi (dove le prime danno output e le seconde no): per noi, qualunque contenitore di operazioni applicate a un input sarà una funzione.\nR offre già molte funzioni pronte all’uso. Per esempio, possiamo assegnare alcuni numeri a una variabile e calcolarne la somma:\n\nb &lt;- c(2, 3, 5)\nsum(b)\n#&gt; [1] 10\n\nGli input delle funzioni vengono specificati all’interno di parentesi tonde. Alcune funzioni richiedono pochi input, altre che ne richiedono di più. Nella Sezione 2.4 vedremo come acquisire informazioni sull’utilizzo di una funzione.\nOltre alle funzioni predefinite, possiamo scrivere funzioni personalizzate. Scrivere funzioni efficienti, robuste e ben documentate richiede pratica, ma la sintassi di base è:\n\n# la funzione fammi_il_caffe prende come argomenti due stringa di caratteri:\n# la prima definisce il tipo e può essere \"caffè\" o \"orzo\"\n# la seconda definisce la modalità e può essere \"corto\", \"lungo\" o \"macchiato\"\n# l'output è una stringa di testo\nfammi_il_caffe &lt;- function(tipo = \"caffè\",\n                           modo = \"corto\"){\n  # controllo che l'input abbia le caratteristiche desiderate\n  stopifnot(is.character(tipo))\n  stopifnot(is.character(modo))\n  stopifnot(tipo %in% c(\"caffè\", \"orzo\"))\n  stopifnot(modo %in% c(\"corto\", \"lungo\", \"macchiato\"))\n  \n  # determino il prezzo scegliendo un numero casuale tra 1 e 2 con intervallo 0.1\n  prezzo &lt;- sample(seq(from = 1, to = 2, by = 0.1), 1)\n  # formatto il caffé e il prezzo\n  prodotto_txt &lt;- paste(\"Ecco a lei il suo\", tipo, modo, sep = \" \")\n  prezzo_txt &lt;- paste(\"Sono\", prezzo, \"€.\", sep = \" \")\n  \n  # il risultato è l'ultimo comando della funzione\n  paste(prodotto_txt, prezzo_txt, sep = \". \")\n}\n\n# utilizzo della funzione\nfammi_il_caffe()\n#&gt; [1] \"Ecco a lei il suo caffè corto. Sono 1.6 €.\"\nfammi_il_caffe(\"orzo\", \"lungo\")\n#&gt; [1] \"Ecco a lei il suo orzo lungo. Sono 1.4 €.\"\nfammi_il_caffe(\"orzo\", \"corretto\")\n#&gt; Error in fammi_il_caffe(\"orzo\", \"corretto\"): modo %in% c(\"corto\", \"lungo\", \"macchiato\") is not TRUE\n\nGli argomenti (o input) della funzione sono racchiusi tra parentesi tonde, con eventuali valori predefiniti dichiarati dopo l’uguale. Il corpo della funzione è racchiuso tra parentesi graffe e tipicamente contiene:\n\nuna parte di validazione degli argomenti, per assicurarsi che la funzione non venga utilizzata correttamente;\nuna parte in cui vengono eseguiti i calcoli;\nuna parte finale che restituisce il risultato.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#il-primo-script",
    "href": "start.html#il-primo-script",
    "title": "2  Il primo assaggio",
    "section": "2.3 Il primo script",
    "text": "2.3 Il primo script\nNella sezione precedente abbiamo visto codice che si estende su più righe: inserirlo riga per riga nella console può diventare scomodo, e si rischia di dimenticare cosa si è fatto poco prima.\nPer questo motivo, possiamo creare un file.R in cui elencare in ordine i comandi da eseguire. Per farlo, in RStudio basta cliccare sull’icona  in alto a sinistra, selezionare “R Script” e salvare il file. All’interno di questo file possiamo scrivere, ad esempio, le seguenti istruzioni:\n\n# richiamo un dataset di R\niris\n\n# ho visto che il dataset è composto da misurazioni di lunghezze e larghezze di\n# petali e sepali di tre diverse specie di iris. Le specie considerate sono\n# setosa, versicolor e virginica: per ogni specie sono presenti 50 record.\n\n# faccio un grafico tra coppie di variabili\nplot(iris, col = iris$Species)\n\n# noto che le misurazioni relative a una specie sono ben distinte dalle altre due,\n# quest'ultime mostrano un certo grado di sovrapposizione. Vediamo se il calcolo\n# dei quartili eseguita sulle singole variabili per i diversi gruppi mi aiuta a\n# identificare i gruppi che mostrano sovrapposizione parziale nelle misure.\n\n# definisco una funzione per il calcolo dei quartili a partire da generici\n# percentili\nquartili &lt;- function(valori){\n  stopifnot(is.vector(valori))\n  \n  # uso la funzione predefinita quantile\n  quantile(valori, probs = c(0.25, 0.50, 0.75))\n}\n\n# la funzione aggregate divide una serie di dati in gruppi, applica la funzione\n# desiderata a ogni gruppo e poi ricombina i risultati\naggregate(. ~ Species, data = iris, FUN = quartili)\n\n# la specie setosa risulta ben disinguibile dalle specie versicolor e virginica,\n# quest'ultime mostrano dimensioni simili.\n# Le variabili che permettono di distinguere meglio le tre specie sono \n# la lunghezza e la larghezza dei petali.\n\nCon gli script è possibile tenere traccia di quanto è stato fatto, commentando il codice per renderlo maggiormente comprensibile a sé stessi e ai colleghi. D’ora in poi, gli script saranno il nostro principale strumento di lavoro. Nei prossimi capitoli vedremo inoltre come includere gli script in un documento completo, migliorando ulteriormente la riproducibilità di un’analisi.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#sec-help",
    "href": "start.html#sec-help",
    "title": "2  Il primo assaggio",
    "section": "2.4 Chiedere aiuto",
    "text": "2.4 Chiedere aiuto\nQuesta è la sezione più importante dell’intero corso, poiché insegna come muoversi sulle proprie gambe, cadendo senza farsi troppo male e cercando di rialzarsi.\nR offre un ottimo aiuto in linea: ogni pacchetto, dataset e funzione è documentato, contenendo tutte le informazioni necessarie per comprenderne gli ambiti e le modalità di utilizzo. Per accedere a queste informazioni, è sufficiente anteporre un punto interrogativo ? all’elemento del quale si desidera sapere di più:\n\n?sum()\n?iris\n\nSe l’elemento di cui si vuole sapere di più è presente in un pacchetto noto, ma non attualmente caricato, sarà necessario specificare il pacchetto di appartenenza anteponendolo con :::\n\n?ggplot2::geom_point()\n\nSe l’elemento è presente in un pacchetto installato ma non attualmente caricato e non si conosce esattamente a quale pacchetto appartenga, si può effettuare una ricerca tra i pacchetti installati anteponendo due punti interrogativi ?? all’elemento stesso e selezionando la voce di interesse:\n\n??geom_point()\n\nAll’interno della sezione di help si trova una descrizione iniziale dell’elemento e, se si tratta di una funzione, i diversi input richiesti; seguono poi sezioni che spesso spiegato il funzionamento della funziona, per concludere con utili esempi d’uso.\nA volte l’aiuto in linea potrebbe non essere sufficiente; in tal caso si consiglia di rivolgersi a Google o qualche large language model (LLM) come DeepSeek, ChatGPT o Perplexity. Questi strumenti di intelligenza artificiale permettono, a fronte di richieste dettagliate e ben strutturate di farsi scrivere e spiegare interi programmi, anche complessi, richiedendo poche rifiniture manuali.\nIn alternativa o in completamento all’uso di strumenti di intelligenza artificiale, esistono forum dedicati alla programmazione e con una folta comunità di preparatissimi (e spesso burberi) utilizzatori di R. Tra questi StackOverflow risulta particolarmente ricco di spunti e risorse. Per utilizzarlo al meglio:\n\ncercate con cura se la vostra domanda sia già stata posta in passato;\nprendete spunto da domande simili per strutturare con cura la vostra richiesta;\ncreate un esempio minimo riproducibile (reprex).\n\nQuest’ultimo punto ha lo scopo di rendere il vostro codice riproducibile e facilmente leggibile da chi vi dovrà aiutare: inserite nel codice tutte le librerie e variabili utilizzate, e togliete tutto ciò che non è indispensabile per riprodurre il problema su cui state chiedendo aiuto.\n\nEsercizioSoluzione\n\n\n\nDocumentarsi sull’utilizzo della funzione aggregate;\ncalcolare la media di tutte le quattro tipologie di misure delle tre specie nel dataset iris.\n\n\n\n\n?aggregate()    # 1.\naggregate(. ~ Species, data = iris, FUN = mean)    # 2.\n#&gt;      Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n#&gt; 1     setosa        5.006       3.428        1.462       0.246\n#&gt; 2 versicolor        5.936       2.770        4.260       1.326\n#&gt; 3  virginica        6.588       2.974        5.552       2.026",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "3  Oggetti di R",
    "section": "",
    "text": "3.1 Tipologie di elementi\nPrima di vedere le classi di oggetti di R, che possiamo pensare come diverse tipologie di contenitori, è bene dare uno sguardo alle tipologie di elementi che possiamo inserire in questi contenitori.\nQuando saremo in dubbio sulla tipologia di un dato elemento possiamo usare la funzione typeof().",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "objects.html#sec-typeof",
    "href": "objects.html#sec-typeof",
    "title": "3  Oggetti di R",
    "section": "",
    "text": "3.1.1 Numeri\nR gestisce diverse tipologie di numeri, ma utilizzeremo principalmente la tipologia double, abbreviazione di double-precision floating-point format: che definisce come in informatica vengono archiviati e manipolati gli elementi esprimibili con una parte decimale. Ogni misura - ad eccezione dei conteggi puri - ricade in questa tipologia, anche se dovesse avere valore intero (es. 5). L’Utilizzo di elementi di tipo double è semplice:\n\na &lt;- c(2, 2.1, 2.5)\n\nPiù raramente, dovremo definire degli interi, che appartengono alla tipologia integer e si indicano facendo seguire una L maiuscola al numero:\n\nb &lt;- c(1L, 5L)\n\nAltre tipologie di numeri più rare comprendono i tipi complex e raw, rispettivamente per numeri complessi e bytes: non le utilizzeremo.\nAlcune operazioni matematiche possono generare numeri particolari come NaN (not a number), Inf e -Inf. Il primo si ottiene, ad esempio, dividendo zero per zero, mentre gli ultimi dividendo un numero positivo o negativo per zero. Per verificare se un numero è NaN o Inf, si usano rispettivamente le funzioni is.nan() e is.infinite().\n\n\n3.1.2 Testo\nR usa una singola tipologia per le stringhe di testo: indipendentemente dalla loro lunghezza saranno tutte character e si creano racchiudendo il testo tra virgolette (singole o doppie; in questo corso utilizzeremo sempre le doppie virgolette):\n\nc &lt;- \"roba\"\n\nTalvolta, i numeri possono essere erroneamente archiviati come testo. Questo è un risultato indesiderato ma abbastanza frequente quando si importano dati non ben ripulit. Per riconvertirli in numeri, si usa la funzione as.numeric().\n\n\n3.1.3 Logici\nGli elementi logici possono assumere esclusivamente valore TRUE o FALSE. Raramente vengono assegnati direttamente a una variabile, ma compaiono spesso a seguito di un’operazione logica:\n\nd &lt;- 3 &lt; 5\nd\n#&gt; [1] TRUE\ntypeof(d)\n#&gt; [1] \"logical\"\n\ne &lt;- 3 == 3L\n\nInternamente, R li tratta come interi pari a 1 (TRUE) o 0 (FALSE).\n\n\n3.1.4 Elementi mancanti ed elementi nulli\nR identifica gli elementi mancanti con NA (not available). NA rappresenta una tipologia particolare, in quanto diventa di tipo testo, numero o valore logico a seconda del contesto. In genere, le operazioni eseguite su gruppi di elementi in cui uno o più elementi sono NA restituiscono NA. Si può verificare se un elemento è di tipo NA con la funzione is.na().\nTalvolta, R può restituire un elemento di tipo NULL quando si tenta di estrarre un elemento inesistente da un oggetto. Più comunemente, è possibile assegnare il valore NULL a un oggetto per eliminarne il contenuto:\n\nc()\n#&gt; NULL\n\na\n#&gt; [1] 2.0 2.1 2.5\na &lt;- NULL\na\n#&gt; NULL",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "objects.html#sec-classes",
    "href": "objects.html#sec-classes",
    "title": "3  Oggetti di R",
    "section": "3.2 Tipologie di contenitori",
    "text": "3.2 Tipologie di contenitori\n\n3.2.1 Vettori\nUn vettore è un insieme ordinato di valori, tutti appartenenti alla stessa tipologia. Tutte le variabili create nella Sezione 3.1 sono esempi di vettori: anche se alcuni contengono solo numeri, testo o valori logici, essi non contengono mai elementi di tipologie diverse e possiedono una sola dimensione.\nTecnicamente, i vettori non sono catalogati da R all’interno di una classe, tuttavia è comodo vederli come la più semplice delle classi, intendendo con questo termine - per semplicità - una tipologia di contenitore di elementi.\nÈ possibile accedere ai diversi elementi di un vettore utilizzando la notazione: vettore[indici] dove indici è a sua volta un vettore di elementi da includere o escludere. Esempi:\n\nf &lt;- c(\"a\", \"b\", \"c\", NA, \"e\")\nf[1] # seleziona il primo elemento\n#&gt; [1] \"a\"\n\nf[-1] # seleziona tutti gli elementi tranne il primo\n#&gt; [1] \"b\" \"c\" NA  \"e\"\n\nf[2:4] # seleziona gli elementi dal secondo al quarto, estremi compresi\n#&gt; [1] \"b\" \"c\" NA\n\nf[-(2:4)] # seleziona tutti gli elementi tranne quelli dal secondo al quarto\n#&gt; [1] \"a\" \"e\"\n\nf[c(2,4)] # seleziona il secondo e quarto elemento\n#&gt; [1] \"b\" NA\n\nf[-c(2,4)] # seleziona tutti gli elementi tranne il secondo e il quarto\n#&gt; [1] \"a\" \"c\" \"e\"\n\ng &lt;- c(3,5)\nf[g] # seleziona il terzo e quinto elemento\n#&gt; [1] \"c\" \"e\"\n\nf[-g] # seleziona tutti gli elementi tranne il terzo e il quinto\n#&gt; [1] \"a\" \"b\" NA\n\nf[is.na(f)] # seleziona solo gli elementi NA\n#&gt; [1] NA\n\nf[!is.na(f)] # seleziona solo gli elementi non NA\n#&gt; [1] \"a\" \"b\" \"c\" \"e\"\n\nPer verificare se un oggetto è un vettore si può usare la funzione is.vector(), mentre per conoscerne il numero di elementi si usa la funzione length().\nCon i vettori possiamo iniziare a fare qualche calcolo con funzioni quali max(), min(), sum(), mean(), median(), quantile(), which.min() e which.max() e molte altre.\nSpesso è utile generare vettori casuali; a tale scopo, le funzioni forse più usate sono sample() e rnorm(). La prima estrae un numero casuale di elementi da un vettore, la seconda genera valori da una distribuzione normale con parametri noti. Esempio:\n\nsorprendimi &lt;- sample(1:1000, 30, replace = TRUE) # 30 valori indipendenti da 1 a 1000.\nmax(sorprendimi) # trova il valore massimo\n#&gt; [1] 998\nwhich.max(sorprendimi) # trova la posizione del valore massimo\n#&gt; [1] 11\nm &lt;- which.max(sorprendimi)\nsorprendimi[m]\n#&gt; [1] 998\nmax(sorprendimi) == sorprendimi[m] # funziona!\n#&gt; [1] TRUE\n\nrnorm(1000, mean = 10, sd = 3) |&gt; # si usa la pipe per concatenare le funzioni\n  hist()\n\n\n\n\n\n\n\n\nGli elementi di un vettore possono essere associati a un nome tramite l’attributo names():\n\ng\n#&gt; [1] 3 5\nnames(g) &lt;- c(\"tre\", \"cinque\")\ng\n#&gt;    tre cinque \n#&gt;      3      5\nnames(g) &lt;- NULL\ng\n#&gt; [1] 3 5\n\n\n\n3.2.2 Matrici ed array\nLa naturale estensione dei vettori sono le matrici e gli array multidimensionali, creati organizzando i vettori su righe e colonne.\nL’estrazione di elementi da una matrice avviene con la notazione matrice[righe, colonne], come mostrato nell’esempio riportato di seguito:\n\nmatrice &lt;- matrix(1:100, nrow = 20)\nmatrice[5:7, 3:5]\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]   45   65   85\n#&gt; [2,]   46   66   86\n#&gt; [3,]   47   67   87\nmatrice[, 3]\n#&gt;  [1] 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\n\nSi può determinare e modificare la dimensione di una matrice con il comando dim():\n\ndim(matrice)\n#&gt; [1] 20  5\ndim(matrice) &lt;- c(5, 20)\n\nSu vettori e matrici di tipo numerico è possibile eseguire operazioni di algebra lineare, come il prodotto righe per colonne, utilizzando l’operatore %*%, o il calcolo dell’inversa con il comando inv() del pacchetto MASS. Tuttavia, raramente sarà necessario eseguire queste operazioni manualmente, poiché numerosissimi algoritmi sono già implementati in modo molto efficiente in funzioni e pacchetti dedicati.\n\n\n3.2.3 Fattori\nUn fattore è un tipo di dato che può assumere solo valori finiti e noti. Ad esempio, il colore dei capelli dei bambini di una classe è un fattore, così come le tipologie di acque analizzate dal laboratorio (acque di mare, potabili, sotterranee, ecc.). I valori distinti che un fattore può assumere si chiamano livelli.\nGli esempi di fattori visti in precedenza non sono ordinati, ma alcuni possono esserlo, come i giudizi di un esame: insufficiente, sufficiente, buono, distinto, ottimo.\nInternamente, R tratta i fattori come interi a cui associa etichette di testo. Per i fattori ordinati, gli interi seguono l’ordine specificato durante la definizione dei livelli; per i fattori non ordinati, gli interi sono assegnati in ordine alfabetico o di apparizione. Esempio:\n\nterza_c &lt;- c(\"ottimo\", \"ottimo\", \"buono\", \"insufficiente\", \"buono\", \"buono\")\n\n# fattore senza specifica dei livelli\nfactor(terza_c)\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: buono insufficiente ottimo\n\n# fattore con livelli specificato ma non ordinati\nfactor(terza_c,\n       levels = c(\"insufficiente\", \"sufficiente\", \"buono\", \"distinto\", \"ottimo\"))\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: insufficiente sufficiente buono distinto ottimo\n\n# fattore ordinato\nfactor(terza_c,\n       ordered = TRUE,\n       levels = c(\"insufficiente\", \"sufficiente\", \"buono\", \"distinto\", \"ottimo\"))\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: insufficiente &lt; sufficiente &lt; buono &lt; distinto &lt; ottimo\n\n\n\n3.2.4 Liste\nI contenitori visti finora sono ottimi per raggruppare elementi della stessa tipologia. Le liste, invece, permettono di raggruppare elementi di tipi diversi mantenendoli comunque ordinati:\n\nlista &lt;- list(numeri = 1:20,\n              testo = c(\"pippo\", \"ciccio\", \"riccio\"),\n              giudizi = terza_c,\n              matrice = matrice)\nstr(lista)\n#&gt; List of 4\n#&gt;  $ numeri : int [1:20] 1 2 3 4 5 6 7 8 9 10 ...\n#&gt;  $ testo  : chr [1:3] \"pippo\" \"ciccio\" \"riccio\"\n#&gt;  $ giudizi: chr [1:6] \"ottimo\" \"ottimo\" \"buono\" \"insufficiente\" ...\n#&gt;  $ matrice: int [1:5, 1:20] 1 2 3 4 5 6 7 8 9 10 ...\n\nPer accedere alla struttura di una lista si usa il comando str(), utile anche con altri tipi di contenitori.\nI singoli gruppi si estraggono per posizione con la sintassi lista[[gruppo]] o per nome con la sintassi lista$gruppo. All’interno del gruppo posso accedere ai singoli elementi come visto nelle sezioni precedenti:\n\nlista[[2]]\n#&gt; [1] \"pippo\"  \"ciccio\" \"riccio\"\nlista$testo\n#&gt; [1] \"pippo\"  \"ciccio\" \"riccio\"\nlista$testo[2]\n#&gt; [1] \"ciccio\"\nlista[[4]][2,]\n#&gt;  [1]  2  7 12 17 22 27 32 37 42 47 52 57 62 67 72 77 82 87 92 97\nlista[[4]][2,3]\n#&gt; [1] 12\nlista[[3]] &lt;- NULL\n\n\n\n3.2.5 Data frames\nI data.frame sono tabelle di dati che possono contenere colonne di diverse tipologie. Rispetto alle liste, offrono una maggiore facilità di consultazione, ma non permettono di immagazzinare gruppi di diversa lunghezza. Sono la tipologia di dati più frequentemente utilizzata.\nInternamente, R tratta le colonne di un data.frame come gruppi di una lista.\nEsempio con il dataset iris:\n\nstr(iris)\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#&gt;  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#&gt;  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#&gt;  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n#&gt;  $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nCreazione e modifica di un data frame:\n\ndf &lt;- data.frame(lettere = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"),\n                 interi = 1:6,\n                 numeri = rnorm(6))\ndf$numeri\n#&gt; [1] -0.1829260 -1.3792578  1.2506006 -1.8762368 -0.3687876 -2.1292973\ndf$lettere[3]\n#&gt; [1] \"c\"\ndf$lettere[3] &lt;- \"g\"\ndf$sopra3 &lt;- df$interi &gt; 3\ndf$interi &lt;- NULL\n\nI nomi delle colonne si estraggono o modificano con la funzione colnames():\n\ncolnames(df)\n#&gt; [1] \"lettere\" \"numeri\"  \"sopra3\"\ncolnames(df)[3] &lt;- \"random\"\n\nI data.frame possono anche avere nomi per ogni riga, ma è consigliabile evitarlo.\nLa sintassi base di R rende spesso complicato filtrare o eseguire operazioni complesse sui data frame. Per questo motivo sono nati pacchetti dedicati, tra cui:\n\ndplyr permette di manipolare i dati concatenando funzioni con nomi descrittivi come filter(), mutate(), group_by(), ecc.\ndata.table nato per la manipolazione efficiente di grandi quantità di dati, propone una sintassi estesa rispetto a quella base di R: lo vedremo nel prossimo capitolo.\n\n\nEsercizioSoluzione\n\n\nPiero ha effettuato 10 prove indipendenti per la misura della concentrazione di nitrati su un campione di acqua, ottenendo i seguenti risultati: 0.77, 0.69, 0.89, 0.75, 0.93, 0.81, 0.91, 1.06, 0.98 mg/l. Una delle prove non ha dato risultati validi.\n\ncreare uno script contenente commenti esplicativi di ogni passaggio;\ncalcolare media, deviazione standard e intervallo di confidenza (\\(\\alpha\\) = 0.95).\n\nPina ha preparato altre 10 prove indipendenti dello stesso campione di acqua per la misura della concentrazione di nitrati, ottenendo i seguenti risultati: 1.09, 0.89, 0.74, 1.07, 0.68, 0.89, 1.25, 1.10, 0.86, 0.88 mg/l.\n\nampliare lo script sviluppato nell’esercizio precedente;\nunire i risultati ottenuti dai due operatori nello stesso oggetto di R;\ncalcolare gli intervalli di confidenza per ciascun operatore;\nValutare statisticamente la presenza di differenze significative tra i valori ottenuti dai due operatori.\n\nPer praticità, assumiamo che: - i dati seguano una distribuzione normale; - le varianze dei due gruppi siano omogenee.\n\n\n\n# 1\npiero &lt;- c(0.77, 0.69, 0.89, 0.75, 0.93, 0.81, 0.91, 1.06, 0.98, NA)\nmean(piero, na.rm = TRUE)\n#&gt; [1] 0.8655556\nsd(piero, na.rm = TRUE)\n#&gt; [1] 0.119385\nn &lt;- piero[!is.na(piero)] |&gt; length() # immaginate un altro modo\n\nci &lt;- function(data, alfa = 0.975){\n  stopifnot(is.numeric(data))\n  stopifnot(is.numeric(alfa))\n  stopifnot(alfa &gt; 0 &  alfa &lt;= 1)\n  \n  n &lt;- sum(!is.na(data))\n  dof &lt;- n - 1\n  avg &lt;- mean(data, na.rm = TRUE)\n  std_error &lt;- sd(data, na.rm = TRUE) / sqrt(n)\n  t_val &lt;- qt(alfa, dof)\n  \n  avg + c(-1, +1) * t_val * std_error\n}\n\nci(piero)\n#&gt; [1] 0.7737881 0.9573230\n\n# 2\n# In seguito vedremo come questo modo di organizzare i dati non sia ottimale\nrisultati &lt;- data.frame(piero = piero,\n                        pina = c(1.09, 0.89, 0.74, 1.07, 0.68,\n                                 0.89, 1.25, 1.10, 0.86, 0.88))\nlapply(risultati, ci)\n#&gt; $piero\n#&gt; [1] 0.7737881 0.9573230\n#&gt; \n#&gt; $pina\n#&gt; [1] 0.8180479 1.0719521\nt.test(risultati$piero, risultati$pina)\n#&gt; \n#&gt;  Welch Two Sample t-test\n#&gt; \n#&gt; data:  risultati$piero and risultati$pina\n#&gt; t = -1.1548, df = 15.825, p-value = 0.2653\n#&gt; alternative hypothesis: true difference in means is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;  -0.22541955  0.06653066\n#&gt; sample estimates:\n#&gt; mean of x mean of y \n#&gt; 0.8655556 0.9450000",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Oggetti di R</span>"
    ]
  }
]