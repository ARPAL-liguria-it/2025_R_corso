[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Corso di R: dalle basi alla prima analisi dei dati",
    "section": "",
    "text": "Prefazione\nQuesto documento raccoglie il materiale presentato durante l‚Äôomonimo corso tenuto in ARPAL nel 2025.\nIl corso e l‚Äôannesso documento nascono dalla volont√† degli autori di condividere con i colleghi la potenza e la bellezza di utilizzare un linguaggio di programmazione nell‚Äôanalisi dei dati.\nIl linguaggio di programmazione scelto √® R, in quanto permette sin da subito di eseguire semplici analisi di dati, richiedendo l‚Äôapprendimento di una sintassi intuitiva e di alcune funzioni, in gran parte gi√† pronte o disponibili in librerie specializzate. Inoltre, con R √® facile creare grafici efficaci e ricchi di contenuto.\nQuesto documento √® rilasciato gratuitamente con licenza Creative Commons CC BY-NC-SA 4.0.",
    "crumbs": [
      "Prefazione"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1¬† Introduzione",
    "section": "",
    "text": "1.1 Quanta fatica\nLo scopo del corso √® fornire gli strumenti necessari per eseguire semplici analisi dei dati utilizzando il linguaggio R.\nIl corso si conclude con una piccola analisi guidata svolta dai partecipanti e strutturata in un documento a s√© stante.\nDurante il proseguo del corso impareremo a:\nL‚Äôutilizzo di un linguaggio di programmazione richiede un importante investimento iniziale per apprenderne le basi, le funzioni principali e il loro campo di applicazione. Tuttavia, l‚Äôimpegno profuso viene ampiamente ripagato dalla possibilit√† di riutilizzare e adattare il codice, nonch√© di ripetere le analisi con poco sforzo, rendendo l‚Äôintero processo riproducibile e documentabile.\nInoltre, imparare un linguaggio di programmazione apre numerose porte e pu√≤ semplificare il lavoro quotidiano in molti ambiti. Per esempio, con R √® possibile realizzare:",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "intro.html#quanta-fatica",
    "href": "intro.html#quanta-fatica",
    "title": "1¬† Introduzione",
    "section": "",
    "text": "documenti dinamici parametrizzati;\napplicazioni interattive accessibili via browser;\ninterfacce di programmazione (API) per l‚Äôesecuzione di funzioni da remoto.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "intro.html#prerequisiti",
    "href": "intro.html#prerequisiti",
    "title": "1¬† Introduzione",
    "section": "1.2 Prerequisiti",
    "text": "1.2 Prerequisiti\nIl corso √® aperto a chiunque abbia una certa dimestichezza con il computer e una conoscenza di base della logica. Il candidato ideale ha gi√† svolto qualche analisi su dati numerici, utilizzando strumenti statistici di base e fogli di calcolo. La conoscenza di un linguaggio di programmazione diverso da R non √® necessaria, ma sicuramente rappresenta un vantaggio.\nPer eseguire il codice presentato durante il corso, √® necessario installare R, RStudio e i seguenti pacchetti data.table, readxl, ggplot2, glue e gt.\n\n1.2.1 R\nR pu√≤ essere scaricato dal Comprensive R Archive Network (CRAN), seguendo le istruzioni relative al proprio sistema operativo. Ogni anno viene rilasciata una nuova versione principale, accompagnata da circa tre aggiornamenti minori: se si intende usare R regolarmente, √® consigliabile mantenere il software aggiornato.\nR √® un software libero, distribuito sotto una combinazione di licenze GNU General Public License v2 e v3 e GNU Lesser General Public License v2.1.\n\n\n1.2.2 RStudio\nRStudio √® l‚Äôambiente di sviluppo integrato (IDE) pi√π diffuso per R: permette la gestione completa di un progetto, la connessione a sorgenti dati esterne come database e l‚Äôintegrazione con sistemi di gestione delle versioni come git. Pu√≤ essere scaricato dal sito ufficiale di Posit.\nAnche RStudio √® un software libero, rilasciato sotto licenza GNU Affero General Public License v3.\n\n\n\n\n\n\n\n\nFigura¬†1.1: Schermata di RStudio: in alto, da sinistra a destra, si trova il pannello dedicato al codice sorgente, al suo fianco il pannello dedicato agli ambienti e allo storico. In basso, da sinistra a destra, si trova la console e il pannello dedicato agli output.\n\n\n\n\n\nL‚Äôuso di RStudio o di un altro IDE non √® strettamente necessario per utilizzare R, ma ne semplifica notevolmente l‚Äôimpiego. Altri IDE comunemente utilizzati con R sono Visual Studio Code, Vim ed Emacs.\n\n\n1.2.3 I pacchetti di R\nLe funzionalit√† di R possono essere ampliate tramite pacchetti. La lista completa, molto ampia e variegata, √® presente sul sito del CRAN. Alcuni di questi pacchetti sono sviluppati da appassionati, altri da statistici e ingegneri del software di fama mondiale. Tutte le funzioni e i dati contenuti in un pacchetto sono documentati, il codice sorgente √® completamente consultabile e spesso √® possibile collaborare direttamente allo sviluppo su piattaforme come GitHub. Molti pacchetti sono inoltre collegati a libri di testo o articoli scientifici.\nI pacchetti si installano in R con il comando:\n\ninstall.packages(\"pacchetto\")\n\nDurante il corso utilizzeremo alcuni pacchetti molto diffusi:\n\ndata.table: consente di caricare e manipolare efficientemente grandi insiemi di dati, con una sintassi particolare ma intuitiva;\nggplot2: il pacchetto di riferimento per la creazione di grafici;\nreadxl: utile per importare dati da fogli Excel;\nglue: semplifica la concatenazione di stringhe, anche se lo useremo raramente in modo diretto;\ngt: utilizzato per produrre tabelle di alta qualit√†. Le tabelle che vedrete nel corso saranno realizzate con questo pacchetto, anche se raramente lo useremo direttamente;\nR.utils: lo utilizzeremo solo per importare dati da file gz.\n\nInstalliamo i pacchetti richiesti racchiudendoli all‚Äôinterno di un vettore con il comando c() e scrivendo il seguente comando all‚Äôinterno della console di R, dopo il simbolo &gt;:\n\ninstall.packages(c(\"data.table\", \"readxl\", \"ggplot2\", \"glue\", \"gt\", \"R.utils\"))\n\nQuando ne avremo bisogno saremo pronti a caricare e usare tali pacchetti.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "intro.html#per-approfondire",
    "href": "intro.html#per-approfondire",
    "title": "1¬† Introduzione",
    "section": "1.3 Per approfondire",
    "text": "1.3 Per approfondire\nSe il materiale presentato nel corso non fosse sufficiente o non rispondesse pienamente alle vostre esigenze, in rete √® possibile trovare numerosi testi gratuiti di alta qualit√†. Tra questi si segnalano:\n\nHands-On Rrogramming with R scritto da Garrett Grolemund;\nR for Data Science scritto da Hadley Wickham, Mine √áetinkaya-Rundel, and Garrett Grolemund;\nAdvanced R scritto da Hadley Wickham.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Le basi",
    "section": "",
    "text": "In questa prima parte inizieremo a prendere dimestichezza con le basi di R:\n\nnel primo capitolo partiremo dall‚Äôinterazione con la console fino a scrivere ed eseguire il nostro primo script;\nnel secondo capitolo ci concentreremo sull‚Äôuso delle diverse tipologie di oggetti di R;\nnel terzo capitolo importeremo dati da file esterni;\nnel quarto capitolo inizieremo a fare i primi esperimenti di trasformazione dei dati con la libreria data.table.",
    "crumbs": [
      "Le basi"
    ]
  },
  {
    "objectID": "start.html",
    "href": "start.html",
    "title": "2¬† Il primo assaggio",
    "section": "",
    "text": "2.1 Una bella calcolatrice\nIniziamo a prendere confidenza con la console di R, utilizzandola come una calcolatrice, e scriviamo\n2 + 3\n#&gt; [1] 5\nR, in tutta la sua potenza, dovrebbe produrre\nQuesto significa che il risultato √® un vettore composto da un solo elemento, e tale elemento √® pari a 5.\nPossiamo anche eseguire calcoli su vettori: definiamo un vettore di 100 elementi che contiene gli interi da 1 a 100, e aggiungiamo 2 a ciascuno di essi.\n1:100 + 2\n#&gt;   [1]   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20\n#&gt;  [19]  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38\n#&gt;  [37]  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56\n#&gt;  [55]  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74\n#&gt;  [73]  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92\n#&gt;  [91]  93  94  95  96  97  98  99 100 101 102\nSe volessimo ripetere il calcolo ma aggiungendo 3 invece di 2, possiamo cliccare sulla console, schiacciare il tasto üîº per richiamare l‚Äôultimo comando eseguito, modificare il 2 in 3 e premere Invio. Tuttavia, √® preferibile assegnare il vettore contenente i 100 elementi a una variabile che chiameremo\na &lt;- 1:100\na questo punto possiamo fare\na + 3\n#&gt;   [1]   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21\n#&gt;  [19]  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39\n#&gt;  [37]  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57\n#&gt;  [55]  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75\n#&gt;  [73]  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93\n#&gt;  [91]  94  95  96  97  98  99 100 101 102 103\nPossiamo usare la variabile a per altri calcoli. Per esempio, eleviamo al quadrato tutti gli elementi associati alla variabile a:\na^2\n#&gt;   [1]     1     4     9    16    25    36    49    64    81   100   121   144\n#&gt;  [13]   169   196   225   256   289   324   361   400   441   484   529   576\n#&gt;  [25]   625   676   729   784   841   900   961  1024  1089  1156  1225  1296\n#&gt;  [37]  1369  1444  1521  1600  1681  1764  1849  1936  2025  2116  2209  2304\n#&gt;  [49]  2401  2500  2601  2704  2809  2916  3025  3136  3249  3364  3481  3600\n#&gt;  [61]  3721  3844  3969  4096  4225  4356  4489  4624  4761  4900  5041  5184\n#&gt;  [73]  5329  5476  5625  5776  5929  6084  6241  6400  6561  6724  6889  7056\n#&gt;  [85]  7225  7396  7569  7744  7921  8100  8281  8464  8649  8836  9025  9216\n#&gt;  [97]  9409  9604  9801 10000\nIl valore di una variabile pu√≤ essere sovrascritto con una nuova assegnazione, come nel caso riportato di seguito:\na &lt;- \"Bella zio: sto usando R!\"\nNella creazione di variabili √® bene fare caso ad alcune regole:\nDurante il corso utilizzeremo nomi di variabili e funzioni scritti in caratteri minuscoli e senza lettere accentate, utilizzando gli underscore al posto degli spazi (notazione snake_case).",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#una-bella-calcolatrice",
    "href": "start.html#una-bella-calcolatrice",
    "title": "2¬† Il primo assaggio",
    "section": "",
    "text": "[1] 5\n\n\n\n\n\n\n\n\n\n\n\n\n\nR √® case sensitive, quindi f ed F sono due variabili diverse;\nnon sono ammesse variabili che iniziano con numeri (come 1variabile);\nnon sono ammessi caratteri diversi da lettere, numeri e underscore, compresi gli spazi;\nsono ammessi caratteri accentati, ma il loro uso pu√≤ complicare molto la vita.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#funzioni",
    "href": "start.html#funzioni",
    "title": "2¬† Il primo assaggio",
    "section": "2.2 Funzioni",
    "text": "2.2 Funzioni\nLe funzioni sono una parte fondamentale di R e consentono di eseguire una serie di operazioni dati degli input, per ottenere nessuno, uno o pi√π output. Si tratta di una definizione generale, perch√© le funzioni sono elementi estremamente versatili e le incontreremo ovunque. Durante il corso non distingueremo tra funzioni e metodi (dove le prime danno output e le seconde no): per noi, qualunque contenitore di operazioni applicate a un input sar√† una funzione.\nR offre gi√† molte funzioni pronte all‚Äôuso. Per esempio, possiamo assegnare alcuni numeri a una variabile e calcolarne la somma:\n\nb &lt;- c(2, 3, 5)\nsum(b)\n#&gt; [1] 10\n\nGli input delle funzioni vengono specificati all‚Äôinterno di parentesi tonde. Alcune funzioni richiedono pochi input, altre che ne richiedono di pi√π. Nella Sezione 2.4 vedremo come acquisire informazioni sull‚Äôutilizzo di una funzione.\nOltre alle funzioni predefinite, possiamo scrivere funzioni personalizzate. Scrivere funzioni efficienti, robuste e ben documentate richiede pratica, ma la sintassi di base √®:\n\n# la funzione fammi_il_caffe prende come argomenti due stringa di caratteri:\n# la prima definisce il tipo e pu√≤ essere \"caff√®\" o \"orzo\"\n# la seconda definisce la modalit√† e pu√≤ essere \"corto\", \"lungo\" o \"macchiato\"\n# l'output √® una stringa di testo\nfammi_il_caffe &lt;- function(tipo = \"caff√®\",\n                           modo = \"corto\"){\n  # controllo che l'input abbia le caratteristiche desiderate\n  stopifnot(is.character(tipo))\n  stopifnot(is.character(modo))\n  stopifnot(tipo %in% c(\"caff√®\", \"orzo\"))\n  stopifnot(modo %in% c(\"corto\", \"lungo\", \"macchiato\"))\n  \n  # determino il prezzo scegliendo un numero casuale tra 1 e 2 con intervallo 0.1\n  prezzo &lt;- sample(seq(from = 1, to = 2, by = 0.1), 1)\n  # formatto il caff√© e il prezzo\n  prodotto_txt &lt;- paste(\"Ecco a lei il suo\", tipo, modo, sep = \" \")\n  prezzo_txt &lt;- paste(\"Sono\", prezzo, \"‚Ç¨.\", sep = \" \")\n  \n  # il risultato √® l'ultimo comando della funzione\n  paste(prodotto_txt, prezzo_txt, sep = \". \")\n}\n\n# utilizzo della funzione\nfammi_il_caffe()\n#&gt; [1] \"Ecco a lei il suo caff√® corto. Sono 1.6 ‚Ç¨.\"\nfammi_il_caffe(\"orzo\", \"lungo\")\n#&gt; [1] \"Ecco a lei il suo orzo lungo. Sono 1.4 ‚Ç¨.\"\nfammi_il_caffe(\"orzo\", \"corretto\")\n#&gt; Error in fammi_il_caffe(\"orzo\", \"corretto\"): modo %in% c(\"corto\", \"lungo\", \"macchiato\") is not TRUE\n\nGli argomenti (o input) della funzione sono racchiusi tra parentesi tonde, con eventuali valori predefiniti dichiarati dopo l‚Äôuguale. Il corpo della funzione √® racchiuso tra parentesi graffe e tipicamente contiene:\n\nuna parte di validazione degli argomenti, per assicurarsi che la funzione non venga utilizzata correttamente;\nuna parte in cui vengono eseguiti i calcoli;\nuna parte finale che restituisce il risultato.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#il-primo-script",
    "href": "start.html#il-primo-script",
    "title": "2¬† Il primo assaggio",
    "section": "2.3 Il primo script",
    "text": "2.3 Il primo script\nNella sezione precedente abbiamo visto codice che si estende su pi√π righe: inserirlo riga per riga nella console pu√≤ diventare scomodo, e si rischia di dimenticare cosa si √® fatto poco prima.\nPer questo motivo, possiamo creare un file.R in cui elencare in ordine i comandi da eseguire. Per farlo, in RStudio basta cliccare sull‚Äôicona  in alto a sinistra, selezionare ‚ÄúR Script‚Äù e salvare il file. All‚Äôinterno di questo file possiamo scrivere, ad esempio, le seguenti istruzioni:\n\n# richiamo un dataset di R\niris\n\n# ho visto che il dataset √® composto da misurazioni di lunghezze e larghezze di\n# petali e sepali di tre diverse specie di iris. Le specie considerate sono\n# setosa, versicolor e virginica: per ogni specie sono presenti 50 record.\n\n# faccio un grafico tra coppie di variabili\nplot(iris, col = iris$Species)\n\n# noto che le misurazioni relative a una specie sono ben distinte dalle altre due,\n# quest'ultime mostrano un certo grado di sovrapposizione. Vediamo se il calcolo\n# dei quartili eseguita sulle singole variabili per i diversi gruppi mi aiuta a\n# identificare i gruppi che mostrano sovrapposizione parziale nelle misure.\n\n# definisco una funzione per il calcolo dei quartili a partire da generici\n# percentili\nquartili &lt;- function(valori){\n  stopifnot(is.vector(valori))\n  \n  # uso la funzione predefinita quantile\n  quantile(valori, probs = c(0.25, 0.50, 0.75))\n}\n\n# la funzione aggregate divide una serie di dati in gruppi, applica la funzione\n# desiderata a ogni gruppo e poi ricombina i risultati\naggregate(. ~ Species, data = iris, FUN = quartili)\n\n# la specie setosa risulta ben disinguibile dalle specie versicolor e virginica,\n# quest'ultime mostrano dimensioni simili.\n# Le variabili che permettono di distinguere meglio le tre specie sono \n# la lunghezza e la larghezza dei petali.\n\nCon gli script √® possibile tenere traccia di quanto √® stato fatto, commentando il codice per renderlo maggiormente comprensibile a s√© stessi e ai colleghi. D‚Äôora in poi, gli script saranno il nostro principale strumento di lavoro. Nei prossimi capitoli vedremo inoltre come includere gli script in un documento completo, migliorando ulteriormente la riproducibilit√† di un‚Äôanalisi.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#sec-help",
    "href": "start.html#sec-help",
    "title": "2¬† Il primo assaggio",
    "section": "2.4 Chiedere aiuto",
    "text": "2.4 Chiedere aiuto\nQuesta √® la sezione pi√π importante dell‚Äôintero corso, poich√© insegna come muoversi sulle proprie gambe, cadendo senza farsi troppo male e cercando di rialzarsi.\nR offre un ottimo aiuto in linea: ogni pacchetto, dataset e funzione √® documentato, contenendo tutte le informazioni necessarie per comprenderne gli ambiti e le modalit√† di utilizzo. Per accedere a queste informazioni, √® sufficiente anteporre un punto interrogativo ? all‚Äôelemento del quale si desidera sapere di pi√π:\n\n?sum()\n?iris\n\nSe l‚Äôelemento di cui si vuole sapere di pi√π √® presente in un pacchetto noto, ma non attualmente caricato, sar√† necessario specificare il pacchetto di appartenenza anteponendolo con :::\n\n?ggplot2::geom_point()\n\nSe l‚Äôelemento √® presente in un pacchetto installato ma non attualmente caricato e non si conosce esattamente a quale pacchetto appartenga, si pu√≤ effettuare una ricerca tra i pacchetti installati anteponendo due punti interrogativi ?? all‚Äôelemento stesso e selezionando la voce di interesse:\n\n??geom_point()\n\nAll‚Äôinterno della sezione di help si trova una descrizione iniziale dell‚Äôelemento e, se si tratta di una funzione, i diversi input richiesti; seguono poi sezioni che spesso spiegato il funzionamento della funziona, per concludere con utili esempi d‚Äôuso.\nA volte l‚Äôaiuto in linea potrebbe non essere sufficiente; in tal caso si consiglia di rivolgersi a Google o qualche large language model (LLM) come DeepSeek, ChatGPT o Perplexity. Questi strumenti di intelligenza artificiale permettono, a fronte di richieste dettagliate e ben strutturate di farsi scrivere e spiegare interi programmi, anche complessi, richiedendo poche rifiniture manuali.\nIn alternativa o in completamento all‚Äôuso di strumenti di intelligenza artificiale, esistono forum dedicati alla programmazione e con una folta comunit√† di preparatissimi (e spesso burberi) utilizzatori di R. Tra questi StackOverflow risulta particolarmente ricco di spunti e risorse. Per utilizzarlo al meglio:\n\ncercate con cura se la vostra domanda sia gi√† stata posta in passato;\nprendete spunto da domande simili per strutturare con cura la vostra richiesta;\ncreate un esempio minimo riproducibile (reprex).\n\nQuest‚Äôultimo punto ha lo scopo di rendere il vostro codice riproducibile e facilmente leggibile da chi vi dovr√† aiutare: inserite nel codice tutte le librerie e variabili utilizzate, e togliete tutto ci√≤ che non √® indispensabile per riprodurre il problema su cui state chiedendo aiuto.\n\nEsercizioSoluzione\n\n\n\nDocumentarsi sull‚Äôutilizzo della funzione aggregate;\ncalcolare la media di tutte le quattro tipologie di misure delle tre specie nel dataset iris.\n\n\n\n\n?aggregate()    # 1.\naggregate(. ~ Species, data = iris, FUN = mean)    # 2.\n#&gt;      Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n#&gt; 1     setosa        5.006       3.428        1.462       0.246\n#&gt; 2 versicolor        5.936       2.770        4.260       1.326\n#&gt; 3  virginica        6.588       2.974        5.552       2.026",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "3¬† Oggetti di R",
    "section": "",
    "text": "3.1 Tipologie di elementi\nPrima di vedere le classi di oggetti di R, che possiamo pensare come diverse tipologie di contenitori, √® bene dare uno sguardo alle tipologie di elementi che possiamo inserire in questi contenitori.\nQuando saremo in dubbio sulla tipologia di un dato elemento possiamo usare la funzione typeof().",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "objects.html#sec-typeof",
    "href": "objects.html#sec-typeof",
    "title": "3¬† Oggetti di R",
    "section": "",
    "text": "3.1.1 Numeri\nR gestisce diverse tipologie di numeri, ma utilizzeremo principalmente la tipologia double, abbreviazione di double-precision floating-point format: che definisce come in informatica vengono archiviati e manipolati gli elementi esprimibili con una parte decimale. Ogni misura - ad eccezione dei conteggi puri - ricade in questa tipologia, anche se dovesse avere valore intero (es. 5). L‚ÄôUtilizzo di elementi di tipo double √® semplice:\n\na &lt;- c(2, 2.1, 2.5)\n\nPi√π raramente, dovremo definire degli interi, che appartengono alla tipologia integer e si indicano facendo seguire una L maiuscola al numero:\n\nb &lt;- c(1L, 5L)\n\nAltre tipologie di numeri pi√π rare comprendono i tipi complex e raw, rispettivamente per numeri complessi e bytes: non le utilizzeremo.\nAlcune operazioni matematiche possono generare numeri particolari come NaN (not a number), Inf e -Inf. Il primo si ottiene, ad esempio, dividendo zero per zero, mentre gli ultimi dividendo un numero positivo o negativo per zero. Per verificare se un numero √® NaN o Inf, si usano rispettivamente le funzioni is.nan() e is.infinite().\n\n\n3.1.2 Testo\nR usa una singola tipologia per le stringhe di testo: indipendentemente dalla loro lunghezza saranno tutte character e si creano racchiudendo il testo tra virgolette (singole o doppie; in questo corso utilizzeremo sempre le doppie virgolette):\n\nc &lt;- \"roba\"\n\nTalvolta, i numeri possono essere erroneamente archiviati come testo. Questo √® un risultato indesiderato ma abbastanza frequente quando si importano dati non ben ripulit. Per riconvertirli in numeri, si usa la funzione as.numeric().\n\n\n3.1.3 Logici\nGli elementi logici possono assumere esclusivamente valore TRUE o FALSE. Raramente vengono assegnati direttamente a una variabile, ma compaiono spesso a seguito di un‚Äôoperazione logica:\n\nd &lt;- 3 &lt; 5\nd\n#&gt; [1] TRUE\ntypeof(d)\n#&gt; [1] \"logical\"\n\ne &lt;- 3 == 3L\n\nInternamente, R li tratta come interi pari a 1 (TRUE) o 0 (FALSE).\n\n\n3.1.4 Elementi mancanti ed elementi nulli\nR identifica gli elementi mancanti con NA (not available). NA rappresenta una tipologia particolare, in quanto diventa di tipo testo, numero o valore logico a seconda del contesto. In genere, le operazioni eseguite su gruppi di elementi in cui uno o pi√π elementi sono NA restituiscono NA. Si pu√≤ verificare se un elemento √® di tipo NA con la funzione is.na().\nTalvolta, R pu√≤ restituire un elemento di tipo NULL quando si tenta di estrarre un elemento inesistente da un oggetto. Pi√π comunemente, √® possibile assegnare il valore NULL a un oggetto per eliminarne il contenuto:\n\nc()\n#&gt; NULL\n\na\n#&gt; [1] 2.0 2.1 2.5\na &lt;- NULL\na\n#&gt; NULL",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "objects.html#sec-classes",
    "href": "objects.html#sec-classes",
    "title": "3¬† Oggetti di R",
    "section": "3.2 Tipologie di contenitori",
    "text": "3.2 Tipologie di contenitori\n\n3.2.1 Vettori\nUn vettore √® un insieme ordinato di valori, tutti appartenenti alla stessa tipologia. Tutte le variabili create nella Sezione 3.1 sono esempi di vettori: anche se alcuni contengono solo numeri, testo o valori logici, essi non contengono mai elementi di tipologie diverse e possiedono una sola dimensione.\nTecnicamente, i vettori non sono catalogati da R all‚Äôinterno di una classe, tuttavia √® comodo vederli come la pi√π semplice delle classi, intendendo con questo termine - per semplicit√† - una tipologia di contenitore di elementi.\n√à possibile accedere ai diversi elementi di un vettore utilizzando la notazione: vettore[indici] dove indici √® a sua volta un vettore di elementi da includere o escludere. Esempi:\n\nf &lt;- c(\"a\", \"b\", \"c\", NA, \"e\")\nf[1] # seleziona il primo elemento\n#&gt; [1] \"a\"\n\nf[-1] # seleziona tutti gli elementi tranne il primo\n#&gt; [1] \"b\" \"c\" NA  \"e\"\n\nf[2:4] # seleziona gli elementi dal secondo al quarto, estremi compresi\n#&gt; [1] \"b\" \"c\" NA\n\nf[-(2:4)] # seleziona tutti gli elementi tranne quelli dal secondo al quarto\n#&gt; [1] \"a\" \"e\"\n\nf[c(2,4)] # seleziona il secondo e quarto elemento\n#&gt; [1] \"b\" NA\n\nf[-c(2,4)] # seleziona tutti gli elementi tranne il secondo e il quarto\n#&gt; [1] \"a\" \"c\" \"e\"\n\ng &lt;- c(3,5)\nf[g] # seleziona il terzo e quinto elemento\n#&gt; [1] \"c\" \"e\"\n\nf[-g] # seleziona tutti gli elementi tranne il terzo e il quinto\n#&gt; [1] \"a\" \"b\" NA\n\nf[is.na(f)] # seleziona solo gli elementi NA\n#&gt; [1] NA\n\nf[!is.na(f)] # seleziona solo gli elementi non NA\n#&gt; [1] \"a\" \"b\" \"c\" \"e\"\n\nPer verificare se un oggetto √® un vettore si pu√≤ usare la funzione is.vector(), mentre per conoscerne il numero di elementi si usa la funzione length().\nCon i vettori possiamo iniziare a fare qualche calcolo con funzioni quali max(), min(), sum(), mean(), median(), quantile(), which.min() e which.max() e molte altre.\nSpesso √® utile generare vettori casuali; a tale scopo, le funzioni forse pi√π usate sono sample() e rnorm(). La prima estrae un numero casuale di elementi da un vettore, la seconda genera valori da una distribuzione normale con parametri noti. Esempio:\n\nsorprendimi &lt;- sample(1:1000, 30, replace = TRUE) # 30 valori indipendenti da 1 a 1000.\nmax(sorprendimi) # trova il valore massimo\n#&gt; [1] 998\nwhich.max(sorprendimi) # trova la posizione del valore massimo\n#&gt; [1] 11\nm &lt;- which.max(sorprendimi)\nsorprendimi[m]\n#&gt; [1] 998\nmax(sorprendimi) == sorprendimi[m] # funziona!\n#&gt; [1] TRUE\n\nrnorm(1000, mean = 10, sd = 3) |&gt; # si usa la pipe per concatenare le funzioni\n  hist()\n\n\n\n\n\n\n\n\nGli elementi di un vettore possono essere associati a un nome tramite l‚Äôattributo names():\n\ng\n#&gt; [1] 3 5\nnames(g) &lt;- c(\"tre\", \"cinque\")\ng\n#&gt;    tre cinque \n#&gt;      3      5\nnames(g) &lt;- NULL\ng\n#&gt; [1] 3 5\n\n\n\n3.2.2 Matrici ed array\nLa naturale estensione dei vettori sono le matrici e gli array multidimensionali, creati organizzando i vettori su righe e colonne.\nL‚Äôestrazione di elementi da una matrice avviene con la notazione matrice[righe, colonne], come mostrato nell‚Äôesempio riportato di seguito:\n\nmatrice &lt;- matrix(1:100, nrow = 20)\nmatrice[5:7, 3:5]\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]   45   65   85\n#&gt; [2,]   46   66   86\n#&gt; [3,]   47   67   87\nmatrice[, 3]\n#&gt;  [1] 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\n\nSi pu√≤ determinare e modificare la dimensione di una matrice con il comando dim():\n\ndim(matrice)\n#&gt; [1] 20  5\ndim(matrice) &lt;- c(5, 20)\n\nSu vettori e matrici di tipo numerico √® possibile eseguire operazioni di algebra lineare, come il prodotto righe per colonne, utilizzando l‚Äôoperatore %*%, o il calcolo dell‚Äôinversa con il comando inv() del pacchetto MASS. Tuttavia, raramente sar√† necessario eseguire queste operazioni manualmente, poich√© numerosissimi algoritmi sono gi√† implementati in modo molto efficiente in funzioni e pacchetti dedicati.\n\n\n3.2.3 Fattori\nUn fattore √® un tipo di dato che pu√≤ assumere solo valori finiti e noti. Ad esempio, il colore dei capelli dei bambini di una classe √® un fattore, cos√¨ come le tipologie di acque analizzate dal laboratorio (acque di mare, potabili, sotterranee, ecc.). I valori distinti che un fattore pu√≤ assumere si chiamano livelli.\nGli esempi di fattori visti in precedenza non sono ordinati, ma alcuni possono esserlo, come i giudizi di un esame: insufficiente, sufficiente, buono, distinto, ottimo.\nInternamente, R tratta i fattori come interi a cui associa etichette di testo. Per i fattori ordinati, gli interi seguono l‚Äôordine specificato durante la definizione dei livelli; per i fattori non ordinati, gli interi sono assegnati in ordine alfabetico o di apparizione. Esempio:\n\nterza_c &lt;- c(\"ottimo\", \"ottimo\", \"buono\", \"insufficiente\", \"buono\", \"buono\")\n\n# fattore senza specifica dei livelli\nfactor(terza_c)\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: buono insufficiente ottimo\n\n# fattore con livelli specificato ma non ordinati\nfactor(terza_c,\n       levels = c(\"insufficiente\", \"sufficiente\", \"buono\", \"distinto\", \"ottimo\"))\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: insufficiente sufficiente buono distinto ottimo\n\n# fattore ordinato\nfactor(terza_c,\n       ordered = TRUE,\n       levels = c(\"insufficiente\", \"sufficiente\", \"buono\", \"distinto\", \"ottimo\"))\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: insufficiente &lt; sufficiente &lt; buono &lt; distinto &lt; ottimo\n\n\n\n3.2.4 Liste\nI contenitori visti finora sono ottimi per raggruppare elementi della stessa tipologia. Le liste, invece, permettono di raggruppare elementi di tipi diversi mantenendoli comunque ordinati:\n\nlista &lt;- list(numeri = 1:20,\n              testo = c(\"pippo\", \"ciccio\", \"riccio\"),\n              giudizi = terza_c,\n              matrice = matrice)\nstr(lista)\n#&gt; List of 4\n#&gt;  $ numeri : int [1:20] 1 2 3 4 5 6 7 8 9 10 ...\n#&gt;  $ testo  : chr [1:3] \"pippo\" \"ciccio\" \"riccio\"\n#&gt;  $ giudizi: chr [1:6] \"ottimo\" \"ottimo\" \"buono\" \"insufficiente\" ...\n#&gt;  $ matrice: int [1:5, 1:20] 1 2 3 4 5 6 7 8 9 10 ...\n\nPer accedere alla struttura di una lista si usa il comando str(), utile anche con altri tipi di contenitori.\nI singoli gruppi si estraggono per posizione con la sintassi lista[[gruppo]] o per nome con la sintassi lista$gruppo. All‚Äôinterno del gruppo posso accedere ai singoli elementi come visto nelle sezioni precedenti:\n\nlista[[2]]\n#&gt; [1] \"pippo\"  \"ciccio\" \"riccio\"\nlista$testo\n#&gt; [1] \"pippo\"  \"ciccio\" \"riccio\"\nlista$testo[2]\n#&gt; [1] \"ciccio\"\nlista[[4]][2,]\n#&gt;  [1]  2  7 12 17 22 27 32 37 42 47 52 57 62 67 72 77 82 87 92 97\nlista[[4]][2,3]\n#&gt; [1] 12\nlista[[3]] &lt;- NULL\n\n\n\n3.2.5 Data frames\nI data.frame sono tabelle di dati che possono contenere colonne di diverse tipologie. Rispetto alle liste, offrono una maggiore facilit√† di consultazione, ma non permettono di immagazzinare gruppi di diversa lunghezza. Sono la tipologia di dati pi√π frequentemente utilizzata.\nInternamente, R tratta le colonne di un data.frame come gruppi di una lista.\nEsempio con il dataset iris:\n\nstr(iris)\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#&gt;  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#&gt;  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#&gt;  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n#&gt;  $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nCreazione e modifica di un data frame:\n\ndf &lt;- data.frame(lettere = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"),\n                 interi = 1:6,\n                 numeri = rnorm(6))\ndf$numeri\n#&gt; [1] -0.1829260 -1.3792578  1.2506006 -1.8762368 -0.3687876 -2.1292973\ndf$lettere[3]\n#&gt; [1] \"c\"\ndf$lettere[3] &lt;- \"g\"\ndf$sopra3 &lt;- df$interi &gt; 3\ndf$interi &lt;- NULL\n\nI nomi delle colonne si estraggono o modificano con la funzione colnames():\n\ncolnames(df)\n#&gt; [1] \"lettere\" \"numeri\"  \"sopra3\"\ncolnames(df)[3] &lt;- \"random\"\n\nI data.frame possono anche avere nomi per ogni riga, ma √® consigliabile evitarlo.\nLa sintassi base di R rende spesso complicato filtrare o eseguire operazioni complesse sui data frame. Per questo motivo sono nati pacchetti dedicati, tra cui:\n\ndplyr permette di manipolare i dati concatenando funzioni con nomi descrittivi come filter(), mutate(), group_by(), ecc.\ndata.table nato per la manipolazione efficiente di grandi quantit√† di dati, propone una sintassi estesa rispetto a quella base di R: lo vedremo nel prossimo capitolo.\n\n\nEsercizioSoluzione\n\n\nPiero ha effettuato 10 prove indipendenti per la misura della concentrazione di nitrati su un campione di acqua, ottenendo i seguenti risultati: 0.77, 0.69, 0.89, 0.75, 0.93, 0.81, 0.91, 1.06, 0.98 mg/l. Una delle prove non ha dato risultati validi.\n\ncreare uno script contenente commenti esplicativi di ogni passaggio;\ncalcolare media, deviazione standard e intervallo di confidenza (\\(\\alpha\\) = 0.95).\n\nPina ha preparato altre 10 prove indipendenti dello stesso campione di acqua per la misura della concentrazione di nitrati, ottenendo i seguenti risultati: 1.09, 0.89, 0.74, 1.07, 0.68, 0.89, 1.25, 1.10, 0.86, 0.88 mg/l.\n\nampliare lo script sviluppato nell‚Äôesercizio precedente;\nunire i risultati ottenuti dai due operatori nello stesso oggetto di R;\ncalcolare gli intervalli di confidenza per ciascun operatore;\nValutare statisticamente la presenza di differenze significative tra i valori ottenuti dai due operatori.\n\nPer praticit√†, assumiamo che: - i dati seguano una distribuzione normale; - le varianze dei due gruppi siano omogenee.\n\n\n\n# 1\npiero &lt;- c(0.77, 0.69, 0.89, 0.75, 0.93, 0.81, 0.91, 1.06, 0.98, NA)\nmean(piero, na.rm = TRUE)\n#&gt; [1] 0.8655556\nsd(piero, na.rm = TRUE)\n#&gt; [1] 0.119385\nn &lt;- piero[!is.na(piero)] |&gt; length() # immaginate un altro modo\n\nci &lt;- function(data, alfa = 0.975){\n  stopifnot(is.numeric(data))\n  stopifnot(is.numeric(alfa))\n  stopifnot(alfa &gt; 0 &  alfa &lt;= 1)\n  \n  n &lt;- sum(!is.na(data))\n  dof &lt;- n - 1\n  avg &lt;- mean(data, na.rm = TRUE)\n  std_error &lt;- sd(data, na.rm = TRUE) / sqrt(n)\n  t_val &lt;- qt(alfa, dof)\n  \n  avg + c(-1, +1) * t_val * std_error\n}\n\nci(piero)\n#&gt; [1] 0.7737881 0.9573230\n\n# 2\n# In seguito vedremo come questo modo di organizzare i dati non sia ottimale\nrisultati &lt;- data.frame(piero = piero,\n                        pina = c(1.09, 0.89, 0.74, 1.07, 0.68,\n                                 0.89, 1.25, 1.10, 0.86, 0.88))\nlapply(risultati, ci)\n#&gt; $piero\n#&gt; [1] 0.7737881 0.9573230\n#&gt; \n#&gt; $pina\n#&gt; [1] 0.8180479 1.0719521\nt.test(risultati$piero, risultati$pina)\n#&gt; \n#&gt;  Welch Two Sample t-test\n#&gt; \n#&gt; data:  risultati$piero and risultati$pina\n#&gt; t = -1.1548, df = 15.825, p-value = 0.2653\n#&gt; alternative hypothesis: true difference in means is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;  -0.22541955  0.06653066\n#&gt; sample estimates:\n#&gt; mean of x mean of y \n#&gt; 0.8655556 0.9450000",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Oggetti di R</span>"
    ]
  }
]