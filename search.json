[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R in ARPAL: dalle basi alla prima analisi dei dati",
    "section": "",
    "text": "Prefazione\nQuesto documento raccoglie il materiale presentato durante l’omonimo corso tenuto in ARPAL nel 2025.\nIl corso e il relativo materiale sono stati creati per aiutare i colleghi a scoprire la potenza e la flessibilità di un linguaggio di programmazione dedicato allianalisi dei dati: R.\nR è una scelta ideale perché permette di iniziare subito a eseguire analisi semplici, grazie a una sintassi intuitiva e a numerose funzioni già pronte, disponibili in librerie specializzate. Inoltre, con R è possibile creare grafici chiari e di grande impatto, anche senza esperienza pregressa.\nIl corso è stato pensato per chi ha poca o nessuna esperienza con software di analisi dati e durante le 20 ore di formazione, si affrontano con gradualità tutti i passaggi fondamentali per portare a termine un’analisi: dalla manipolazione dei dati alla creazione di report riproducibili.\nQuesto documento è rilasciato gratuitamente con licenza Creative Commons CC BY-NC-SA 4.0.\n\n\n\n\n\n\nAttenzione\n\n\n\nQuesta è una bozza in fase di stesura: il materiale non è ancora stato sottoposto a revisione.",
    "crumbs": [
      "Prefazione"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduzione",
    "section": "",
    "text": "1.1 Quanta fatica\nLo scopo del corso è fornire gli strumenti necessari per eseguire semplici analisi dei dati utilizzando il linguaggio R.\nIl materiale è organizzato in tre parti, ciascuna dedicata a un aspetto fondamentale del lavoro con R.\nLe basi, introduce i concetti essenziali per iniziare a programmare in R: dall’uso della console e delle variabili, alla comprensione dei principali tipi di dati e oggetti. Qui si gettano le fondamenta indispensabili per affrontare le fasi successive.\nLavorare con i dati, si concentra sulle tecniche per manipolare, trasformare e unire dataset, utilizzando strumenti efficienti come il pacchetto data.table e funzioni per il reshaping e le join. Queste competenze sono cruciali per preparare i dati all’analisi.\nVisualizzazione e reportistica, guida alla creazione di grafici professionali con ggplot2 e all’uso di Quarto per produrre report dinamici e personalizzati, migliorando la comunicazione e la condivisione dei risultati.\nAl termine del corso, è proposto lo sviluppo di un documento completo e autonomo, in cui si possano applicare i concetti e le tecniche apprese, creando un prodotto utile nel proprio contesto lavorativo.\nL’utilizzo di un linguaggio di programmazione richiede un importante investimento iniziale per apprenderne le basi, le funzioni principali e il loro campo di applicazione. Tuttavia, l’impegno profuso viene ampiamente ripagato dalla possibilità di riutilizzare e adattare il codice, nonché di ripetere le analisi con poco sforzo, rendendo l’intero processo riproducibile e documentabile.\nInoltre, imparare un linguaggio di programmazione apre numerose porte e può semplificare il lavoro quotidiano in molti ambiti. Per esempio, con R è possibile realizzare:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "intro.html#quanta-fatica",
    "href": "intro.html#quanta-fatica",
    "title": "1  Introduzione",
    "section": "",
    "text": "documenti dinamici parametrizzati;\napplicazioni interattive accessibili via browser;\ninterfacce di programmazione (API) per l’esecuzione di funzioni da remoto.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "intro.html#prerequisiti",
    "href": "intro.html#prerequisiti",
    "title": "1  Introduzione",
    "section": "1.2 Prerequisiti",
    "text": "1.2 Prerequisiti\nIl corso è aperto a chiunque abbia una certa dimestichezza con il computer e una conoscenza di base della logica. Il candidato ideale ha già svolto qualche analisi su dati numerici, utilizzando strumenti statistici di base e fogli di calcolo. La conoscenza di un linguaggio di programmazione diverso da R non è necessaria, ma sicuramente rappresenta un vantaggio.\nPer eseguire il codice presentato durante il corso, è necessario installare R, RStudio e i seguenti pacchetti data.table, readxl, ggplot2, gt e quarto.\n\n1.2.1 R\nR può essere scaricato dal Comprensive R Archive Network (CRAN), seguendo le istruzioni relative al proprio sistema operativo. Ogni anno viene rilasciata una nuova versione principale, accompagnata da circa tre aggiornamenti minori: se si intende usare R regolarmente, è consigliabile mantenere il software aggiornato.\nR è un software libero, distribuito sotto una combinazione di licenze GNU General Public License v2 e v3 e GNU Lesser General Public License v2.1.\n\n\n1.2.2 RStudio\nRStudio è l’ambiente di sviluppo integrato (IDE) più diffuso per R: permette la gestione completa di un progetto, la connessione a sorgenti dati esterne come database e l’integrazione con sistemi di gestione delle versioni come git. Può essere scaricato dal sito ufficiale di Posit.\nAnche RStudio è un software libero, rilasciato sotto licenza GNU Affero General Public License v3.\n\n\n\n\n\n\n\n\nFigura 1.1: Schermata di RStudio: in alto, da sinistra a destra, si trova il pannello dedicato al codice sorgente, al suo fianco il pannello dedicato agli ambienti e allo storico. In basso, da sinistra a destra, si trova la console e il pannello dedicato agli output.\n\n\n\n\n\nL’uso di RStudio o di un altro IDE non è strettamente necessario per utilizzare R, ma ne semplifica notevolmente l’impiego. Altri IDE comunemente utilizzati con R sono Visual Studio Code, Vim ed Emacs.\n\n\n1.2.3 I progetti di RStudio\nPer mantenere in ordine e facilmente accessibili i diversi file collegati a una medesima analisi è possibile creare un progetto di RStudio. Durante il corso si lavorerà all’interno di un progetto dedicato: per crearlo è necessario cliccare sull’icona  di RStudio, in alto a destra. Selezionando prima “New Project…” e poi “New directory” è richiesto dove salvare il progetto e con quale nome.\nAll’interno della cartella dedicata al progetto si crea la cartella data, salvando al suo interno un dataset in formato xlsx e uno in formato csv compresso: saranno utili nel Capitolo 5.\n\n\n1.2.4 I pacchetti di R\nLe funzionalità di R possono essere ampliate tramite pacchetti. La lista completa, molto ampia e variegata, è presente sul sito del CRAN. Alcuni di questi pacchetti sono sviluppati da appassionati, altri da statistici e ingegneri del software di fama mondiale. Tutte le funzioni e i dati contenuti in un pacchetto sono documentati, il codice sorgente è completamente consultabile e spesso è possibile collaborare direttamente allo sviluppo su piattaforme come GitHub. Molti pacchetti sono inoltre collegati a libri di testo o articoli scientifici.\nI pacchetti si installano in R con il comando:\n\ninstall.packages(\"pacchetto\")\n\nDurante il corso saranno utilizzati alcuni pacchetti molto diffusi:\n\ndata.table: consente di caricare e manipolare efficientemente grandi insiemi di dati, con una sintassi particolare ma intuitiva;\nggplot2: il pacchetto di riferimento per la creazione di grafici;\nreadxl: utile per importare dati da fogli Excel;\ngt: utilizzato per produrre tabelle di alta qualità. Le tabelle che vedrete nel corso saranno realizzate con questo pacchetto, anche se raramente sarà usato direttamente;\nquarto: sarà necessaria la funzione quarto_render() per produrre report in serie;\nR.utils: è utile solo per importare dati da file gz.\n\nI pacchetti richiesti si installano racchiudendoli all’interno di un vettore con il comando c() e scrivendo il seguente comando all’interno della console di R, dopo il simbolo &gt;:\n\ninstall.packages(c(\"data.table\", \"readxl\", \"ggplot2\", \"gt\", \"R.utils\", \"quarto\"))\n\nUna volta installati, si procederà direttamente a caricare e usare tali pacchetti solo laddove necessario.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "intro.html#per-approfondire",
    "href": "intro.html#per-approfondire",
    "title": "1  Introduzione",
    "section": "1.3 Per approfondire",
    "text": "1.3 Per approfondire\nSe il materiale presentato nel corso non fosse sufficiente o non rispondesse pienamente alle esigenze del lettore, in rete è possibile trovare numerosi testi gratuiti di alta qualità. Tra questi si segnalano:\n\nHands-On Programming with R scritto da Garrett Grolemund;\nR for Data Science scritto da Hadley Wickham, Mine Çetinkaya-Rundel, and Garrett Grolemund;\nAdvanced R scritto da Hadley Wickham.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduzione</span>"
    ]
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Le basi",
    "section": "",
    "text": "Questa parte introduce i concetti fondamentali per iniziare a lavorare con R in modo efficace e autonomo. Nei due capitoli che seguono, si parte dalle prime semplici operazioni nella console per familiarizzare con l’ambiente di lavoro e la sintassi di R, fino a comprendere la natura degli oggetti e dei dati.\nQuesta parte è suddivisa in tre capitoli così organizzati:\n\nnel capitolo 2 si inizia a usare la console di R, per poi organizzare il codice in script e apprendere come consultare l’aiuto in linea;\nnel capitolo 3 si elencano i tipi di dati fondamentali in R e le principali classi di oggetti;\nnel capitolo 4 si esaminano alcuni costrutti elementari per iniziare a programmare con R.\n\nQuesti argomenti costituiscono le fondamenta indispensabili per affrontare con sicurezza le analisi e le manipolazioni di dati più complesse che saranno presentate nei capitoli successivi.",
    "crumbs": [
      "Le basi"
    ]
  },
  {
    "objectID": "start.html",
    "href": "start.html",
    "title": "2  Il primo assaggio",
    "section": "",
    "text": "2.1 Una bella calcolatrice\nIn questo capitolo si inizia a usare R per eseguire semplici calcoli e operazioni su dati, creare e gestire variabili, utilizzare funzioni predefinite e scrivere funzioni personalizzate. Si comincia a organizzare il codice in script e a consultare la documentazione e l’aiuto in linea per lavorare in autonomia.\nPer iniziare a prendere confidenza con la console di R, è possibile usarla come una calcolatrice, scrivendo\n2 + 3\nR, in tutta la sua potenza, dovrebbe produrre\nQuesto significa che il risultato è un vettore composto da un solo elemento, e tale elemento è pari a 5.\nÈ possibile anche eseguire calcoli su vettori: si definisce un vettore di 100 elementi che contiene gli interi da 1 a 100, aggiungendo 2 a ciascuno di essi.\n1:100 + 2\n#&gt;   [1]   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20\n#&gt;  [19]  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38\n#&gt;  [37]  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56\n#&gt;  [55]  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74\n#&gt;  [73]  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92\n#&gt;  [91]  93  94  95  96  97  98  99 100 101 102\nDa questo esempio in poi, è adottata la convenzione secondo cui le righe scritte in colore grigio chiaro e precedute da #&gt; riportano l’output della console.\nSe si volesse ripetere il calcolo precedente aggiungendo 3 invece di 2, ci si può posizionare sulla console, premere il tasto freccia su (🔼) della tastiera per richiamare l’ultimo comando, modificarlo e premere Invio. Tuttavia, è più comodo assegnare il vettore dei numeri da 1 a 100 a una variabile, ad esempio\na &lt;- 1:100\na questo punto, si scrive semplicemente:\na + 3\n#&gt;   [1]   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21\n#&gt;  [19]  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39\n#&gt;  [37]  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57\n#&gt;  [55]  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75\n#&gt;  [73]  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90  91  92  93\n#&gt;  [91]  94  95  96  97  98  99 100 101 102 103\nLa variabile a è riutilizzabile per altri calcoli. Per esempio, per elevare al quadrato tutti i suoi elementi:\na^2\n#&gt;   [1]     1     4     9    16    25    36    49    64    81   100   121   144\n#&gt;  [13]   169   196   225   256   289   324   361   400   441   484   529   576\n#&gt;  [25]   625   676   729   784   841   900   961  1024  1089  1156  1225  1296\n#&gt;  [37]  1369  1444  1521  1600  1681  1764  1849  1936  2025  2116  2209  2304\n#&gt;  [49]  2401  2500  2601  2704  2809  2916  3025  3136  3249  3364  3481  3600\n#&gt;  [61]  3721  3844  3969  4096  4225  4356  4489  4624  4761  4900  5041  5184\n#&gt;  [73]  5329  5476  5625  5776  5929  6084  6241  6400  6561  6724  6889  7056\n#&gt;  [85]  7225  7396  7569  7744  7921  8100  8281  8464  8649  8836  9025  9216\n#&gt;  [97]  9409  9604  9801 10000\nIl valore di una variabile può essere sovrascritto con una nuova assegnazione, come nel caso riportato di seguito:\na &lt;- \"Bella zio: sto usando R!\"\nNella creazione di variabili è bene fare caso ad alcune regole:\nDurante il corso i nomi di variabili e funzioni sono scritti in caratteri minuscoli e senza lettere accentate, utilizzando gli underscore al posto degli spazi (notazione snake_case).",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#una-bella-calcolatrice",
    "href": "start.html#una-bella-calcolatrice",
    "title": "2  Il primo assaggio",
    "section": "",
    "text": "[1] 5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR è case sensitive, quindi f ed F sono due variabili diverse;\nnon sono ammesse variabili che iniziano con numeri (come 1variabile);\nnon sono ammessi caratteri diversi da lettere, numeri e underscore, compresi gli spazi;\nsono ammessi caratteri accentati, ma il loro uso può complicare molto la vita.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#sec-functions",
    "href": "start.html#sec-functions",
    "title": "2  Il primo assaggio",
    "section": "2.2 Funzioni",
    "text": "2.2 Funzioni\nLe funzioni sono una parte fondamentale di R e consentono di eseguire una serie di operazioni dati degli input, per ottenere nessuno, uno o più output. Si tratta di una definizione generale, perché le funzioni sono elementi estremamente versatili che si incontreranno ovunque. Durante il corso non si distingue tra funzioni e metodi (dove le prime danno output e le seconde no): qualunque contenitore di operazioni applicate a un input è una funzione.\nR offre già molte funzioni pronte all’uso. Per esempio, è possibile assegnare alcuni numeri a una variabile e calcolarne la somma:\n\nb &lt;- c(2, 3, 5)\nsum(b)\n#&gt; [1] 10\n\nGli input delle funzioni vengono specificati all’interno di parentesi tonde. Alcune funzioni richiedono pochi input, altre che ne richiedono di più. Nella Sezione 2.4 è spiegato come reperire informazioni sull’utilizzo di una qualunque funzione.\nOltre alle funzioni predefinite, è possibile scrivere funzioni personalizzate. Scrivere funzioni efficienti, robuste e ben documentate richiede pratica, ma la sintassi di base è:\n\n# la funzione fammi_il_caffe prende come argomenti due stringa di caratteri:\n# la prima definisce il tipo e può essere \"caffè\" o \"orzo\"\n# la seconda definisce la modalità e può essere \"corto\", \"lungo\" o \"macchiato\"\n# l'output è una stringa di testo\nfammi_il_caffe &lt;- function(tipo = \"caffè\",\n                           modo = \"corto\"){\n  # controlla che l'input abbia le caratteristiche desiderate\n  stopifnot(is.character(tipo))\n  stopifnot(is.character(modo))\n  stopifnot(tipo %in% c(\"caffè\", \"orzo\"))\n  stopifnot(modo %in% c(\"corto\", \"lungo\", \"macchiato\"))\n  \n  # determina il prezzo scegliendo un numero casuale tra 1 e 2 con intervallo 0.1\n  prezzo &lt;- sample(seq(from = 1, to = 2, by = 0.1), 1)\n  # formatta il caffé e il prezzo\n  prodotto_txt &lt;- paste(\"Ecco a lei il suo\", tipo, modo, sep = \" \")\n  prezzo_txt &lt;- paste(\"Sono\", prezzo, \"€.\", sep = \" \")\n  \n  # il risultato è l'ultimo comando della funzione\n  paste(prodotto_txt, prezzo_txt, sep = \". \")\n}\n\n# utilizzo della funzione\nfammi_il_caffe()\n#&gt; [1] \"Ecco a lei il suo caffè corto. Sono 1.6 €.\"\nfammi_il_caffe(\"orzo\", \"lungo\")\n#&gt; [1] \"Ecco a lei il suo orzo lungo. Sono 1.4 €.\"\nfammi_il_caffe(\"orzo\", \"corretto\")\n#&gt; Error in fammi_il_caffe(\"orzo\", \"corretto\"): modo %in% c(\"corto\", \"lungo\", \"macchiato\") is not TRUE\n\nGli argomenti (o input) della funzione sono racchiusi tra parentesi tonde, con eventuali valori predefiniti dichiarati dopo l’uguale. Il corpo della funzione è racchiuso tra parentesi graffe e tipicamente contiene:\n\nuna parte di validazione degli argomenti, per assicurarsi che la funzione venga utilizzata correttamente;\nuna parte in cui vengono eseguiti i calcoli;\nuna parte finale che restituisce il risultato.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#il-primo-script",
    "href": "start.html#il-primo-script",
    "title": "2  Il primo assaggio",
    "section": "2.3 Il primo script",
    "text": "2.3 Il primo script\nNella Sezione 2.2 è stato presentato del codice che si estende su più righe: inserirlo riga per riga nella console può diventare scomodo, e si rischia di dimenticare cosa si è fatto poco prima.\nPer questo motivo, è meglio creare un file.R in cui elencare in ordine i comandi da eseguire. Per farlo, in RStudio basta cliccare sull’icona  in alto a sinistra, selezionare “R Script” e salvare il file. All’interno di questo file si scriveranno, ad esempio, le seguenti istruzioni:\n\n# richiamo un dataset di R\niris\n\n# ho visto che il dataset è composto da misurazioni di lunghezze e larghezze di\n# petali e sepali di tre diverse specie di iris. Le specie considerate sono\n# setosa, versicolor e virginica: per ogni specie sono presenti 50 record.\n\n# faccio un grafico tra coppie di variabili\nplot(iris, col = iris$Species)\n\n# noto che le misurazioni relative a una specie sono ben distinte dalle altre due,\n# queste ultime mostrano un certo grado di sovrapposizione. Vediamo se il calcolo\n# dei quartili eseguita sulle singole variabili per i diversi gruppi mi aiuta a\n# identificare i gruppi che mostrano sovrapposizione parziale nelle misure.\n\n# definisco una funzione per il calcolo dei quartili a partire da generici\n# percentili\nquartili &lt;- function(valori){\n  stopifnot(is.vector(valori))\n  \n  # uso la funzione predefinita quantile\n  quantile(valori, probs = c(0.25, 0.50, 0.75))\n}\n\n# la funzione aggregate divide una serie di dati in gruppi, applica la funzione\n# desiderata a ogni gruppo e poi ricombina i risultati\naggregate(. ~ Species, data = iris, FUN = quartili)\n\n# la specie setosa risulta ben disinguibile dalle specie versicolor e virginica,\n# queste ultime mostrano dimensioni simili.\n# Le variabili che permettono di distinguere meglio le tre specie sono \n# la lunghezza e la larghezza dei petali.\n\nCon gli script è possibile tenere traccia di quanto è stato fatto, commentando il codice per renderlo maggiormente comprensibile a sé stessi e ai colleghi. D’ora in poi, gli script saranno lo strumento di lavoro principale per prendere appunti e tenere traccia di quanto fatto durante il proseguo del corso. Nel Capitolo 9 gli script saranno inclusi in un documento completo, migliorando ulteriormente la riproducibilità delle analisi.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "start.html#sec-help",
    "href": "start.html#sec-help",
    "title": "2  Il primo assaggio",
    "section": "2.4 Chiedere aiuto",
    "text": "2.4 Chiedere aiuto\nQuesta è la sezione più importante dell’intero corso, poiché insegna come muoversi sulle proprie gambe, cadendo senza farsi troppo male e cercando di rialzarsi.\nR offre un ottimo aiuto in linea: ogni pacchetto, dataset e funzione è documentato, contenendo tutte le informazioni necessarie per comprenderne gli ambiti e le modalità di utilizzo. Per accedere a queste informazioni, è sufficiente anteporre un punto interrogativo ? all’elemento del quale si desidera sapere di più:\n\n?sum()\n?iris\n\nSe l’elemento di cui si vuole sapere di più è presente in un pacchetto noto, ma non attualmente caricato, sarà necessario specificare il pacchetto di appartenenza anteponendolo con :::\n\n?ggplot2::geom_point()\n\nSe l’elemento è presente in un pacchetto installato ma non attualmente caricato e non si conosce esattamente a quale pacchetto appartenga, si può effettuare una ricerca tra i pacchetti installati anteponendo due punti interrogativi ?? all’elemento stesso e selezionando la voce di interesse:\n\n??geom_point()\n\nAll’interno della sezione di help si trova una descrizione iniziale dell’elemento e, se si tratta di una funzione, i diversi input richiesti; seguono poi sezioni che spesso spiegano il funzionamento della funzione, per concludere con utili esempi d’uso.\nA volte l’aiuto in linea potrebbe non essere sufficiente; in tal caso si consiglia di rivolgersi a Google o qualche large language model (LLM) come DeepSeek, ChatGPT o Perplexity. Questi strumenti di intelligenza artificiale permettono, a fronte di richieste dettagliate e ben strutturate di farsi scrivere e spiegare interi programmi, anche complessi, richiedendo poche rifiniture manuali.\nIn alternativa o in completamento all’uso di strumenti di intelligenza artificiale, esistono forum dedicati alla programmazione e con una folta comunità di preparatissimi (e spesso burberi) utilizzatori di R. Tra questi StackOverflow risulta particolarmente ricco di spunti e risorse. Per utilizzarlo al meglio:\n\ncercate con cura se la vostra domanda sia già stata posta in passato;\nprendete spunto da domande simili per strutturare con cura la vostra richiesta;\ncreate un esempio minimo riproducibile (reprex).\n\nQuest’ultimo punto ha lo scopo di rendere il vostro codice riproducibile e facilmente leggibile da chi vi dovrà aiutare: inserite nel codice tutte le librerie e variabili utilizzate, e togliete tutto ciò che non è indispensabile per riprodurre il problema su cui state chiedendo aiuto.\n\nEsercizioSoluzione\n\n\n\nDocumentarsi sull’utilizzo della funzione aggregate;\ncalcolare la media di tutte le quattro tipologie di misure delle tre specie nel dataset iris.\n\n\n\n\n?aggregate()                                      # 1.\n\n\naggregate(. ~ Species, data = iris, FUN = mean)   # 2.\n#&gt;      Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n#&gt; 1     setosa        5.006       3.428        1.462       0.246\n#&gt; 2 versicolor        5.936       2.770        4.260       1.326\n#&gt; 3  virginica        6.588       2.974        5.552       2.026",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Il primo assaggio</span>"
    ]
  },
  {
    "objectID": "objects.html",
    "href": "objects.html",
    "title": "3  Oggetti di R",
    "section": "",
    "text": "3.1 Tipologie di elementi\nIn questo capitolo si affrontano le principali tipologie di elementi e contenitori in R. Si analizzerà il modo in cui R gestisce numeri, testo, valori logici, elementi mancanti e nulli. Saranno presentati i contenitori fondamentali per organizzare i dati: vettori, matrici, fattori, liste e data frame. Si comincerà a creare, manipolare e accedere a questi oggetti fondamentali, oltre a utilizzare funzioni base per esplorarne la struttura e il contenuto.\nPrima di vedere le classi di oggetti di R, che possono essere immaginate come diverse tipologie di contenitori, è bene dare uno sguardo alle tipologie di elementi che è possibile inserire in questi contenitori.\nQuando si avrà un dubbio sulla tipologia di un dato elemento è bene usare la funzione typeof().",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "objects.html#sec-typeof",
    "href": "objects.html#sec-typeof",
    "title": "3  Oggetti di R",
    "section": "",
    "text": "3.1.1 Numeri\nR gestisce diversi tipi di numeri, ma nella maggior parte dei casi si usa il tipo double. Questo significa che i numeri con la virgola (decimali) sono memorizzati con precisione elevata, permettendo di rappresentare valori molto precisi. Anche i numeri interi (come 5) sono memorizzati come double, a meno che non sia assegnato esplicitamente il tipo integer, aggiungendo una L (es. 5L). Ogni misura - ad eccezione dei conteggi puri - ricade nella tipologia double, anche se dovesse avere valore intero (es. 5). L’Utilizzo di elementi di tipo double è semplice:\n\na &lt;- c(2, 2.1, 2.5) # double\nb &lt;- c(1L, 5L)      # integer\n\nAltre tipologie di numeri più rare comprendono i tipi complex e raw, rispettivamente per numeri complessi e bytes: non sono trattate nel corso.\nAlcune operazioni matematiche possono generare numeri particolari come NaN (not a number), Inf e -Inf. Il primo si ottiene, ad esempio, dividendo zero per zero, mentre gli ultimi dividendo un numero positivo o negativo per zero. Per verificare se un numero è NaN o Inf, si usano rispettivamente le funzioni is.nan() e is.infinite().\n\n\n3.1.2 Testo\nR usa una singola tipologia per le stringhe di testo: indipendentemente dalla loro lunghezza sono tutte character e si creano racchiudendo il testo tra virgolette (singole o doppie; in questo corso saranno sempre utilizzate le doppie virgolette):\n\nc &lt;- \"roba\"\n\nTalvolta, i numeri possono essere erroneamente archiviati come testo. Questo è un risultato indesiderato ma abbastanza frequente quando si importano dati non ben ripuliti. Per riconvertirli in numeri, si usa la funzione as.numeric().\n\n\n3.1.3 Logici\nGli elementi logici possono assumere esclusivamente valore TRUE o FALSE. Raramente vengono assegnati direttamente a una variabile, ma compaiono spesso a seguito di un’operazione logica:\n\nd &lt;- 3 &lt; 5\nd\n#&gt; [1] TRUE\ntypeof(d)\n#&gt; [1] \"logical\"\n\ne &lt;- 3 == 3L\n\nInternamente, R li tratta come interi pari a 1 (TRUE) o 0 (FALSE).\n\n\n3.1.4 Elementi mancanti ed elementi nulli\nR identifica gli elementi mancanti con NA (not available). NA rappresenta una tipologia particolare, in quanto diventa di tipo testo, numero o valore logico a seconda del contesto. In genere, le operazioni eseguite su gruppi di elementi in cui uno o più elementi sono NA restituiscono NA. Si può verificare se un elemento è di tipo NA con la funzione is.na().\nTalvolta, R può restituire un elemento di tipo NULL quando si tenta di estrarre un elemento inesistente da un oggetto. Più comunemente, è possibile assegnare il valore NULL a un oggetto per eliminarne il contenuto:\n\nc()\n#&gt; NULL\na\n#&gt; [1] 2.0 2.1 2.5\na &lt;- NULL\na\n#&gt; NULL",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "objects.html#sec-classes",
    "href": "objects.html#sec-classes",
    "title": "3  Oggetti di R",
    "section": "3.2 Tipologie di contenitori",
    "text": "3.2 Tipologie di contenitori\n\n3.2.1 Vettori\nUn vettore è un insieme ordinato di valori, tutti appartenenti alla stessa tipologia. Tutte le variabili create nella Sezione 3.1 sono esempi di vettori: anche se alcuni contengono solo numeri, testo o valori logici, essi non contengono mai elementi di tipologie diverse e possiedono una sola dimensione.\nTecnicamente, i vettori non sono catalogati da R all’interno di una classe, tuttavia è comodo vederli come la più semplice delle classi, intendendo con questo termine - per semplicità - una tipologia di contenitore di elementi.\nÈ possibile accedere ai diversi elementi di un vettore utilizzando la notazione: vettore[indici] dove indici è a sua volta un vettore di elementi da includere o escludere. Esempi:\n\nf &lt;- c(\"a\", \"b\", \"c\", NA, \"e\")\nf[1]          # seleziona il primo elemento\n#&gt; [1] \"a\"\nf[-1]         # seleziona tutti gli elementi tranne il primo\n#&gt; [1] \"b\" \"c\" NA  \"e\"\nf[2:4]        # seleziona gli elementi dal secondo al quarto, estremi compresi\n#&gt; [1] \"b\" \"c\" NA\nf[-(2:4)]     # seleziona tutti gli elementi tranne quelli dal secondo al quarto\n#&gt; [1] \"a\" \"e\"\nf[c(2,4)]     # seleziona il secondo e quarto elemento\n#&gt; [1] \"b\" NA\nf[-c(2,4)]    # seleziona tutti gli elementi tranne il secondo e il quarto\n#&gt; [1] \"a\" \"c\" \"e\"\n\ng &lt;- c(3,5)\nf[g]          # seleziona il terzo e quinto elemento\n#&gt; [1] \"c\" \"e\"\nf[-g]         # seleziona tutti gli elementi tranne il terzo e il quinto\n#&gt; [1] \"a\" \"b\" NA\nf[is.na(f)]   # seleziona solo gli elementi NA\n#&gt; [1] NA\nf[!is.na(f)]  # seleziona solo gli elementi non NA\n#&gt; [1] \"a\" \"b\" \"c\" \"e\"\n\nPer verificare se un oggetto è un vettore si può usare la funzione is.vector(), mentre per conoscerne il numero di elementi si usa la funzione length().\nCon i vettori è possibile iniziare a fare qualche calcolo con funzioni quali max(), min(), sum(), mean(), median(), quantile(), which.min() e which.max() e molte altre.\nSpesso è utile generare vettori casuali; a tale scopo, le funzioni forse più usate sono sample() e rnorm(). La prima estrae un numero casuale di elementi da un vettore, la seconda genera valori da una distribuzione normale con parametri noti. Esempio:\n\nsorprendimi &lt;- sample(1:1000, 30, replace = TRUE) # 30 valori indipendenti da 1 a 1000.\nmax(sorprendimi)                                  # trova il valore massimo\n#&gt; [1] 998\nwhich.max(sorprendimi)                            # trova la posizione del valore massimo\n#&gt; [1] 11\nm &lt;- which.max(sorprendimi)\nsorprendimi[m]\n#&gt; [1] 998\nmax(sorprendimi) == sorprendimi[m]                # funziona!\n#&gt; [1] TRUE\n\nrnorm(1000, mean = 10, sd = 3) |&gt;                 # la pipe per concatenare le funzioni\n  hist()\n\n\n\n\n\n\n\n\nGli elementi di un vettore possono essere associati a un nome tramite l’attributo names():\n\ng\n#&gt; [1] 3 5\nnames(g) &lt;- c(\"tre\", \"cinque\")\ng\n#&gt;    tre cinque \n#&gt;      3      5\nnames(g) &lt;- NULL\ng\n#&gt; [1] 3 5\n\n\n\n3.2.2 Matrici ed array\nLa naturale estensione dei vettori sono le matrici e gli array multidimensionali, creati organizzando i vettori su righe e colonne.\nL’estrazione di elementi da una matrice avviene con la notazione matrice[righe, colonne], come mostrato nell’esempio riportato di seguito:\n\nmatrice &lt;- matrix(1:100, nrow = 20)\nmatrice[5:7, 3:5]\n#&gt;      [,1] [,2] [,3]\n#&gt; [1,]   45   65   85\n#&gt; [2,]   46   66   86\n#&gt; [3,]   47   67   87\nmatrice[, 3]\n#&gt;  [1] 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60\n\nSi può determinare e modificare la dimensione di una matrice con il comando dim():\n\ndim(matrice)\n#&gt; [1] 20  5\ndim(matrice) &lt;- c(5, 20)\n\nSu vettori e matrici di tipo numerico è possibile eseguire operazioni di algebra lineare, come il prodotto righe per colonne, utilizzando l’operatore %*%, o il calcolo dell’inversa con il comando inv() del pacchetto MASS. Tuttavia, raramente sarà necessario eseguire queste operazioni manualmente, poiché numerosissimi algoritmi sono già implementati in modo molto efficiente in funzioni e pacchetti dedicati.\n\n\n3.2.3 Fattori\nUn fattore è un tipo di dato che può assumere solo valori finiti e noti. Ad esempio, il colore dei capelli dei bambini di una classe è un fattore, così come le tipologie di acque analizzate dal laboratorio (acque di mare, potabili, sotterranee, ecc.). I valori distinti che un fattore può assumere si chiamano livelli.\nGli esempi di fattori visti in precedenza non sono ordinati, ma alcuni possono esserlo, come i giudizi di un esame: insufficiente, sufficiente, buono, distinto, ottimo.\nInternamente, R tratta i fattori come interi a cui associa etichette di testo. Per i fattori ordinati, gli interi seguono l’ordine specificato durante la definizione dei livelli; per i fattori non ordinati, gli interi sono assegnati in ordine alfabetico o di apparizione. Esempio:\n\nterza_c &lt;- c(\"ottimo\", \"ottimo\", \"buono\", \"insufficiente\", \"buono\", \"buono\")\n\n# fattore senza specifica dei livelli\nfactor(terza_c)\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: buono insufficiente ottimo\n\n# fattore con livelli specificato ma non ordinati\nfactor(terza_c,\n       levels = c(\"insufficiente\", \"sufficiente\", \"buono\", \"distinto\", \"ottimo\"))\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: insufficiente sufficiente buono distinto ottimo\n\n# fattore ordinato\nfactor(terza_c,\n       ordered = TRUE,\n       levels = c(\"insufficiente\", \"sufficiente\", \"buono\", \"distinto\", \"ottimo\"))\n#&gt; [1] ottimo        ottimo        buono         insufficiente buono        \n#&gt; [6] buono        \n#&gt; Levels: insufficiente &lt; sufficiente &lt; buono &lt; distinto &lt; ottimo\n\n\n\n3.2.4 Liste\nI contenitori visti finora sono ottimi per raggruppare elementi della stessa tipologia. Le liste, invece, permettono di raggruppare elementi di tipi diversi mantenendoli comunque ordinati:\n\nlista &lt;- list(numeri = 1:20,\n              testo = c(\"pippo\", \"ciccio\", \"riccio\"),\n              giudizi = terza_c,\n              matrice = matrice)\nstr(lista)\n#&gt; List of 4\n#&gt;  $ numeri : int [1:20] 1 2 3 4 5 6 7 8 9 10 ...\n#&gt;  $ testo  : chr [1:3] \"pippo\" \"ciccio\" \"riccio\"\n#&gt;  $ giudizi: chr [1:6] \"ottimo\" \"ottimo\" \"buono\" \"insufficiente\" ...\n#&gt;  $ matrice: int [1:5, 1:20] 1 2 3 4 5 6 7 8 9 10 ...\n\nPer accedere alla struttura di una lista si usa il comando str(), utile anche con altri tipi di contenitori.\nI singoli gruppi si estraggono per posizione con la sintassi lista[[gruppo]] o per nome con la sintassi lista$gruppo. All’interno del gruppo è possibile accedere ai singoli elementi come visto nelle sezioni precedenti:\n\nlista[[2]]\n#&gt; [1] \"pippo\"  \"ciccio\" \"riccio\"\nlista$testo\n#&gt; [1] \"pippo\"  \"ciccio\" \"riccio\"\nlista$testo[2]\n#&gt; [1] \"ciccio\"\nlista[[4]][2,]\n#&gt;  [1]  2  7 12 17 22 27 32 37 42 47 52 57 62 67 72 77 82 87 92 97\nlista[[4]][2,3]\n#&gt; [1] 12\nlista[[3]] &lt;- NULL\n\n\n\n3.2.5 Data frames\nI data.frame sono tabelle di dati che possono contenere colonne di diverse tipologie. Rispetto alle liste, offrono una maggiore facilità di consultazione, ma non permettono di immagazzinare gruppi di diversa lunghezza. Sono la tipologia di dati più frequentemente utilizzata.\nInternamente, R tratta le colonne di un data.frame come gruppi di una lista.\nEsempio con il dataset iris:\n\nstr(iris)\n#&gt; 'data.frame':    150 obs. of  5 variables:\n#&gt;  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#&gt;  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#&gt;  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#&gt;  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n#&gt;  $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\n\nCreazione e modifica di un data frame:\n\ndf &lt;- data.frame(lettere = c(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"),\n                 interi = 1:6,\n                 numeri = rnorm(6))\ndf$numeri\n#&gt; [1] -0.1829260 -1.3792578  1.2506006 -1.8762368 -0.3687876 -2.1292973\ndf$lettere[3]\n#&gt; [1] \"c\"\ndf$lettere[3] &lt;- \"g\"\ndf$sopra3 &lt;- df$interi &gt; 3\ndf$interi &lt;- NULL\n\nI nomi delle colonne si estraggono o modificano con la funzione colnames():\n\ncolnames(df)\n#&gt; [1] \"lettere\" \"numeri\"  \"sopra3\"\ncolnames(df)[3] &lt;- \"random\"\n\nI data.frame possono anche avere nomi per ogni riga, ma è consigliabile evitarlo.\nLa sintassi base di R rende spesso complicato filtrare o eseguire operazioni complesse sui data frame. Per questo motivo sono nati pacchetti dedicati, tra cui:\n\ndplyr permette di manipolare i dati concatenando funzioni con nomi descrittivi come filter(), mutate(), group_by(), ecc.\ndata.table nato per la manipolazione efficiente di grandi quantità di dati, propone una sintassi estesa rispetto a quella base di R: come spiegato nel Capitolo 5.\n\n\nEsercizioSoluzione\n\n\nPiero ha effettuato 10 prove indipendenti per la misura della concentrazione di nitrati su un campione di acqua, ottenendo i seguenti risultati: 0.77, 0.69, 0.89, 0.75, 0.93, 0.81, 0.91, 1.06, 0.98 mg/l. Una delle prove non ha dato risultati validi.\n\nCreare uno script contenente commenti esplicativi di ogni passaggio;\ncalcolare media, deviazione standard e intervallo di confidenza (\\(\\alpha\\) = 0.95).\n\nPina ha preparato altre 10 prove indipendenti dello stesso campione di acqua per la misura della concentrazione di nitrati, ottenendo i seguenti risultati: 1.09, 0.89, 0.74, 1.07, 0.68, 0.89, 1.25, 1.10, 0.86, 0.88 mg/l.\n\nAmpliare lo script sviluppato nell’esercizio precedente;\nunire i risultati ottenuti dai due operatori nello stesso oggetto di R;\ncalcolare gli intervalli di confidenza per ciascun operatore;\nValutare statisticamente la presenza di differenze significative tra i valori ottenuti dai due operatori.\n\nPer praticità, si assuma che:\n\ni dati seguano una distribuzione normale;\nle varianze dei due gruppi siano omogenee.\n\n\n\n\n# 1\npiero &lt;- c(0.77, 0.69, 0.89, 0.75, 0.93, 0.81, 0.91, 1.06, 0.98, NA)\nmean(piero, na.rm = TRUE)\n#&gt; [1] 0.8655556\nsd(piero, na.rm = TRUE)\n#&gt; [1] 0.119385\nn &lt;- piero[!is.na(piero)] |&gt; length() # immaginate un altro modo\n\nci &lt;- function(data, alfa = 0.975){\n  stopifnot(is.numeric(data))\n  stopifnot(is.numeric(alfa))\n  stopifnot(alfa &gt; 0 &  alfa &lt;= 1)\n  \n  n &lt;- sum(!is.na(data))\n  dof &lt;- n - 1\n  avg &lt;- mean(data, na.rm = TRUE)\n  std_error &lt;- sd(data, na.rm = TRUE) / sqrt(n)\n  t_val &lt;- qt(alfa, dof)\n  \n  avg + c(-1, +1) * t_val * std_error\n}\n\nci(piero)\n#&gt; [1] 0.7737881 0.9573230\n\n# 2\n# In seguito si vedrà come questo modo di organizzare i dati non sia ottimale\nrisultati &lt;- data.frame(piero = piero,\n                        pina = c(1.09, 0.89, 0.74, 1.07, 0.68,\n                                 0.89, 1.25, 1.10, 0.86, 0.88))\nlapply(risultati, ci)\n#&gt; $piero\n#&gt; [1] 0.7737881 0.9573230\n#&gt; \n#&gt; $pina\n#&gt; [1] 0.8180479 1.0719521\nt.test(risultati$piero, risultati$pina)\n#&gt; \n#&gt;  Welch Two Sample t-test\n#&gt; \n#&gt; data:  risultati$piero and risultati$pina\n#&gt; t = -1.1548, df = 15.825, p-value = 0.2653\n#&gt; alternative hypothesis: true difference in means is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;  -0.22541955  0.06653066\n#&gt; sample estimates:\n#&gt; mean of x mean of y \n#&gt; 0.8655556 0.9450000",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Oggetti di R</span>"
    ]
  },
  {
    "objectID": "coding.html",
    "href": "coding.html",
    "title": "4  Elementi di programmazione",
    "section": "",
    "text": "4.1 Introduzione ai Cicli (Loops)\nIn questo capitolo sono discussi alcuni elementi fondamentali di programmazione in R, focalizzandosi su come ripetere istruzioni con i cicli (for e while), applicando funzioni in modo efficiente (lapply()), e facendo seguire al codice percorsi differenziati con i flussi condizionali (if, else e ifelse()).\nIn programmazione, i cicli servono a ripetere una serie di istruzioni più volte, evitando di scrivere codice ripetuto manualmente. In R, i cicli più comuni sono:\nEcco un esempio:\n# ciclo for\nfor(i in 1:5) {\n  print(i)\n}\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\n\n# ciclo while\ni &lt;- 1\nwhile(i &lt;= 5) {\n  print(i)\n  i &lt;- i + 1\n}\n#&gt; [1] 1\n#&gt; [1] 2\n#&gt; [1] 3\n#&gt; [1] 4\n#&gt; [1] 5\nQuesto genere di cicli sono comuni a ogni tipologia di linguaggio di programmazione, tuttavia in R spesso è più efficiente e leggibile evitare i cicli espliciti e utilizzare al loro posto funzioni che applicano altre funzioni a ogni elemento di un oggetto (lista, vettore, dataframe).",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Elementi di programmazione</span>"
    ]
  },
  {
    "objectID": "coding.html#introduzione-ai-cicli-loops",
    "href": "coding.html#introduzione-ai-cicli-loops",
    "title": "4  Elementi di programmazione",
    "section": "",
    "text": "for: per eseguire un blocco di codice per ogni elemento di una sequenza;\nwhile: per eseguire un blocco di codice finché una condizione è vera.\n\n\n\n\n\n4.1.1 La funzione lapply()\nlapply() è la più generale e più usata di queste funzioni speciali e permette di applicare una funzione a ogni elemento di una lista o di un vettore, restituendo una lista.\nLa sintassi è lapply(X, FUN, ...) dove X è l’oggetto e FUN la funzione da applicare.\nEcco un esempio:\n\n# una lista di tre vettori numerici\nmy_list &lt;- list(\n  a = 1:5,\n  b = 6:10,\n  c = 11:15\n)\n\n# calcola la media di ogni vettore\nmedie &lt;- lapply(my_list, mean)\nprint(medie)\n#&gt; $a\n#&gt; [1] 3\n#&gt; \n#&gt; $b\n#&gt; [1] 8\n#&gt; \n#&gt; $c\n#&gt; [1] 13\n\nlapply() si presta anche ad applicare una funzione personalizzata senza doverla definire prima. In questi casi, si usa una funzione anonima come argomento FUN.\nEcco come calcolare la media della somma dei quadrati della lista di vettori, definita nell’esempio precedente:\n\nresult &lt;- lapply(my_list, function(x) sum(x^2))\nprint(result)\n#&gt; $a\n#&gt; [1] 55\n#&gt; \n#&gt; $b\n#&gt; [1] 330\n#&gt; \n#&gt; $c\n#&gt; [1] 855\n\n\nfunction(x) sum(x^2) è una funzione anonima che prende un vettore x, eleva al quadrato ogni elemento (x^2), e ne calcola la somma (sum()).\nlapply() applica questa funzione a ogni elemento della lista my_list.\nIl risultato è una lista con la somma dei quadrati per ciascun vettore.",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Elementi di programmazione</span>"
    ]
  },
  {
    "objectID": "coding.html#flussi-condizionali",
    "href": "coding.html#flussi-condizionali",
    "title": "4  Elementi di programmazione",
    "section": "4.2 Flussi condizionali",
    "text": "4.2 Flussi condizionali\nI flussi condizionali permettono di eseguire del codice solo se una certa condizione è vera.\n\nif valuta una condizione e, se vera, esegue un blocco di codice.\nelse definisce cosa fare se la condizione è falsa.\nifelse() è una funzione vettoriale che valuta una condizione su ogni elemento di un vettore e restituisce un valore se la condizione è vera, un altro se falsa.\n\nDue esempi base:\n\n# if ed else\nx &lt;- 10\nif (x &gt; 5) {\n  print(\"grande\")\n} else {\n  print(\"piccolo\")\n}\n#&gt; [1] \"grande\"\n\n# ifelse()\nv &lt;- c(3, 7, 2, 9)\nrisultato &lt;- ifelse(v &gt; 5, \"grande\", \"piccolo\")\nprint(risultato)\n#&gt; [1] \"piccolo\" \"grande\"  \"piccolo\" \"grande\"\n\nifelse() è preferibile nei casi in cui si lavori con vettori o colonne di dati e si voglia applicare una condizione a ogni elemento. Inoltre permette di utilizzare codice più compatto e veloce rispetto a un ciclo for con if ed else. Nel caso di condizioni multiple è possibile utilizzare più ifelse() annidati ma è bene prestare sempre attenzione alla leggibilità del codice.\n\nEsercizioSoluzione\n\n\nFranco ha misurato le concentrazioni di cianuro in diversi campioni d’acqua prelevati da varie stazioni di monitoraggio e le ha organizzate in una lista.\n\nconcentrazioni &lt;- list(\n  stazione1 = c(10, 12, 60, 30),\n  stazione2 = c(11, 95, 85, 42),\n  stazione3 = c(10, 10, 14, 18)\n)\n\nOra non sa come fare per:\n\ncalcolare la media delle concentrazioni per ogni stazione;\nclassificare ogni concentrazione come “Sicura” se è inferiore o uguale a 15 µg/l, “Attenzione” se è tra 15 e 50 µg/l, e “Pericolosa” se superiore a 50 µg/l.\n\n\n\n\n# 1.\nlapply(concentrazioni, mean)\n#&gt; $stazione1\n#&gt; [1] 28\n#&gt; \n#&gt; $stazione2\n#&gt; [1] 58.25\n#&gt; \n#&gt; $stazione3\n#&gt; [1] 13\n# 2.\nclassifica &lt;- lapply(concentrazioni, function(x) {\n  ifelse(x &lt;= 15, \"Sicura\",\n         ifelse(x &lt;= 50, \"Attenzione\", \"Pericolosa\"))\n  })\n\nprint(classifica)\n#&gt; $stazione1\n#&gt; [1] \"Sicura\"     \"Sicura\"     \"Pericolosa\" \"Attenzione\"\n#&gt; \n#&gt; $stazione2\n#&gt; [1] \"Sicura\"     \"Pericolosa\" \"Pericolosa\" \"Attenzione\"\n#&gt; \n#&gt; $stazione3\n#&gt; [1] \"Sicura\"     \"Sicura\"     \"Sicura\"     \"Attenzione\"",
    "crumbs": [
      "Le basi",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Elementi di programmazione</span>"
    ]
  },
  {
    "objectID": "transform.html",
    "href": "transform.html",
    "title": "Lavorare con i dati",
    "section": "",
    "text": "Questa parte del corso è dedicata a tecniche per la manipolazione e l’integrazione dei dati con R, fondamentali per lavorare con dataset di qualunque tipo: dai più semplici ai più complessi e di grandi dimensioni.\nIl materiale è suddiviso in tre capitoli, così organizzati:\n\nnel capitolo 5 si utilizza il pacchetto data.table per gestire e manipolare dati in modo efficiente e importare dati da file esterni;\nnel capitolo 6 si modifica la struttura dei dataset passando da formato wide a long e viceversa;\nnel capitolo 7 si integrano le informazioni contenute in diverse tabelle in relazione tra loro usando le operazioni di join.\n\nQuesti argomenti permettono di preparare, combinare e riorganizzare i dati in modo flessibile e performante, creando basi solide per analisi statistiche e visualizzazioni più complesse.",
    "crumbs": [
      "Lavorare con i dati"
    ]
  },
  {
    "objectID": "datatable.html",
    "href": "datatable.html",
    "title": "5  Manipolare i dati con data.table",
    "section": "",
    "text": "5.1 Il pacchetto data.table\nIn questo capitolo si utilizzerà il pacchetto data.table per gestire e manipolare dati in modo efficiente, anche su dataset di grandi dimensioni. Una volta entranti in contatto con la sintassi di base per filtrare, selezionare e raggruppare dati, si vedrà come importare dati da file esterni, pulirli e prepararli per l’analisi.\nRispetto ai tradizionali data.frame trattati nella Sezione 3.2.5, il pacchetto data.table offre uno strumento più potente, efficiente e flessibile per gestire e manipolare i dati. data.table è stato creato per lavorare in modo efficiente con dataset di grandi dimensioni, tuttavia la sua sintassi lo rende pratico e agevole da usare anche per dataset di piccole o medie dimensioni.\nCreare una data.table è semplice e molto simile a creare un data.frame. Ecco un esempio:\nlibrary(data.table) # carico il pacchetto\n\ndt &lt;- data.table(\n  id = rep(c(\"a\", \"b\", \"c\", \"d\", \"e\"), each = 10),\n  a = sample(letters, 50, replace = TRUE),\n  b = rnorm(50)\n)\nSe si ha già un data.frame, è possibile convertirlo in una data.table usando la funzione setDT().\nLa sintassi di base del pacchetto data.table si ispira, con buona dose di creatività, al linguaggio SQL, integrandolo con il sistema di indicizzazione di base di R per selezionare e modificare i dati:\ndt[i, j, by]\nTutti e tre gli argomenti sono opzionali: se omessi, vengono restituiti tutti i dati.\nIn altre parole, l’istruzione data si legge così:\nEcco subito un esempio pratico:\n# prendi dt, ordina per id in ordine decrescente e calcola la media di b per ogni id\ndt[order(-id), .(avg = mean(b)), by = id]\n#&gt;        id         avg\n#&gt;    &lt;char&gt;       &lt;num&gt;\n#&gt; 1:      e  0.62033804\n#&gt; 2:      d -0.34352763\n#&gt; 3:      c  0.14841647\n#&gt; 4:      b  0.19524443\n#&gt; 5:      a  0.06563361\nPer sfruttare appieno le potenzialità di data.table, il passo successivo sarà imparare a importare dati da file esterni.",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "datatable.html#sec-load",
    "href": "datatable.html#sec-load",
    "title": "5  Manipolare i dati con data.table",
    "section": "",
    "text": "i serve per filtrare o ordinare le righe (simile a WHERE e ORDER BY in SQL);\nj permette di selezionare o modificare colonne (come SELECT e UPDATE in SQL);\nby consente di ripetere le operazioni per ogni gruppo di dati (equivalente a GROUP BY in SQL).\n\n\n\n\nprendi la data.table dt, filtra o ordina le righe con i, seleziona o calcola j e ripeti l’operazione per ogni gruppo definito da by.",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "datatable.html#importare-i-dati",
    "href": "datatable.html#importare-i-dati",
    "title": "5  Manipolare i dati con data.table",
    "section": "5.2 Importare i dati",
    "text": "5.2 Importare i dati\n\n5.2.1 File .csv, .tsv e .gz\nLa funzione fread() del pacchetto data.table consente di importare facilmente dati in formato .csv, .tsv. Inoltre, supporta anche l’importazione di file compressi, come quelli con estensione .gz, grazie al supporto del pacchetto R.utils.\nfread() cerca di riconoscere automaticamente il tipo di dati nelle varie colonne (numeri, date, testi), ma è sempre buona pratica verificare il risultato dell’importazione.\nEcco un esempio:\n\npm_genova &lt;- fread(\"data/2025-04-24_pm1025_ambiente_liguria.csv.gz\",\n                   skip = \"Codice europeo\", # salta fino alla riga contenente \"Codice europeo\"\n                   encoding = \"Latin-1\")    # gestisce accenti e caratteri speciali\n# Il dataset proviene da Ambiente in Liguria ed è stato modificato a scopo di didattico\n\nstr(pm_genova)\n#&gt; Classes 'data.table' and 'data.frame':   122376 obs. of  10 variables:\n#&gt;  $ Codice europeo : chr  \"IT2302A\" \"IT2302A\" \"IT1698A\" \"IT1698A\" ...\n#&gt;  $ Inquinante     : chr  \"PM10\" \"PM2,5\" \"PM10\" \"PM2,5\" ...\n#&gt;  $ Metodo         : chr  \"CAMP. CONTINUO, RAGGI BETA\" \"CAMP. CONTINUO, RAGGI BETA\" \"CAMP. CONTINUO, RAGGI BETA\" \"CAMP. CONTINUO, RAGGI BETA\" ...\n#&gt;  $ Unità di misura: chr  \"microg/m3\" \"microg/m3\" \"microg/m3\" \"microg/m3\" ...\n#&gt;  $ Data inizio    : chr  \"31/12/2024 23:00\" \"31/12/2024 23:00\" \"31/12/2024 23:00\" \"31/12/2024 23:00\" ...\n#&gt;  $ Data fine      : chr  \"01/01/2025 00:00\" \"01/01/2025 00:00\" \"01/01/2025 00:00\" \"01/01/2025 00:00\" ...\n#&gt;  $ Valore         : num  17.5 13.9 50.7 31.1 12.8 12.4 48.5 37.7 66.5 60.3 ...\n#&gt;  $ Valido         : chr  \"SI\" \"SI\" \"SI\" \"SI\" ...\n#&gt;  $ Validato COR   : chr  \"SI\" \"SI\" \"SI\" \"SI\" ...\n#&gt;  $ Certificato    : chr  \"ancora da esaminare\" \"ancora da esaminare\" \"ancora da esaminare\" \"ancora da esaminare\" ...\n#&gt;  - attr(*, \".internal.selfref\")=&lt;externalptr&gt;\n\nNel dataset importato è possibile notare che sono state distinte le colonne numeriche da quelle testuali, ma ci sono ancora aspetti da migliorare:\n\ni nomi delle colonne contengono spazi e lettere maiuscole;\nl’unità di misura è riportata come \\(microg/m3\\) e non come \\(\\mu g/m^3\\);\nle colonne Data inizio e Data fine sono riconosciute come testo anziché come date e ore;\nle colonne Valido, Validato COR e Certificato andrebbero codificare come valori logici;\nl’unica informazione sul punto di prelievo è fornita dal codice europeo.\n\nÈ possibile sistemare i nomi delle colonne così:\n\ncolnames(pm_genova) &lt;- colnames(pm_genova) |&gt; \n  tolower() |&gt;                  # trasforma in minuscolo\n  gsub(\" \", \"_\", x = _) |&gt;      # sostituisce gli spazi con uderscore\n  iconv(to = \"ASCII//TRANSLIT\") # rimuove accenti e caratteri speciali  \n\n\n\n\n\n\n\nPipe e segnalibri\n\n\n\nUsando la pipe |&gt; l’output della funzione precedente è passato come primo argomento della funzione successiva. È possibile specificare in quale argomento posizionare l’output ricorrendo al segnalibro _.\n\n\nNella Sezione 5.5 verranno affrontati e risolti gli altri problemi del dataset.\n\n\n5.2.2 File xlsx\nPer importare file Excel è necessario utilizzare il pacchetto readxl, come mostrato nell’esempio:\n\nlibrary(readxl)\n\nstazioni &lt;- read_excel(\"data/2025-04-24_anagrafica_stazioni.xlsx\",\n                       sheet = \"Tabella 1\") |&gt; \n  setDT() # converte il dataset in data.table\n# Il dataset proviene dalla sezione Dati e indicatori - Aria del sito di ISPRA\n# ed è stato modificato a scopo didattico\n\nstr(stazioni)\n#&gt; Classes 'data.table' and 'data.frame':   596 obs. of  11 variables:\n#&gt;  $ id_regione     : num  1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  $ id_provincia   : num  1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  $ id_comune      : num  1e+06 1e+06 1e+06 1e+06 1e+06 ...\n#&gt;  $ station_eu_code: chr  \"IT1128A\" \"IT1963A\" \"IT2101A\" \"IT1121A\" ...\n#&gt;  $ station_code   : num  1e+05 1e+05 1e+05 1e+05 1e+05 ...\n#&gt;  $ regione        : chr  \"Piemonte\" \"Piemonte\" \"Piemonte\" \"Piemonte\" ...\n#&gt;  $ provincia      : chr  \"Torino\" \"Torino\" \"Torino\" \"Torino\" ...\n#&gt;  $ comune         : chr  \"Borgaro Torinese\" \"Ceresole Reale\" \"Chieri\" \"Druento\" ...\n#&gt;  $ nome_stazione  : chr  \"Borgaro T. - Caduti\" \"Ceresole Reale - Diga\" \"Chieri - Bersezio\" \"Druento - La Mandria\" ...\n#&gt;  $ tipo_zona      : chr  \"S\" \"R\" \"S\" \"R\" ...\n#&gt;  $ tipo_stazione  : chr  \"F\" \"F\" \"F\" \"F\" ...\n#&gt;  - attr(*, \".internal.selfref\")=&lt;externalptr&gt;\n\nAnche in questo caso, read_excel() cerca di identificare automaticamente i tipi di dati nelle diverse colonne: distingue senza problemi tra numeri e caratteri, ma non riconosce tipo_zona come fattore. A differenza di fread(), read_excel() non restituisce direttamente una data.table.",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "datatable.html#sec-filter",
    "href": "datatable.html#sec-filter",
    "title": "5  Manipolare i dati con data.table",
    "section": "5.3 Filtrare i dati",
    "text": "5.3 Filtrare i dati\nApplicare un filtro ai dati è uno dei modi più semplici per concentrarsi sulle informazioni di interesse. Con data.table, i filtri si applicano sempre sull’elemento i della sintassi dt[i, j, by].\nIn generale, un filtro può essere scritto come\ndt[elemento %operatore% valore, ]\ndove:\n\ndt è la data.table da filtrare;\nvariabile è tipicamente il nome di una colonna di dt;\n%operatore% indica il tipo di confronto o filtro da applicare;\nvalore è il valore con cui confrontare le variabile.\n\nLa condizione variabile %operatore% valore definisce quali righe saranno selezionate.\nAd esempio, per filtrare le stazioni della Liguria nella data.table stazioni, si scrive:\n\nstazioni[regione == \"Liguria\", ]\n#&gt;     id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;          &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;  &lt;char&gt;\n#&gt;  1:          7            8   7008055         IT1882A       700806 Liguria\n#&gt;  2:          7            9   7009002         IT2038A       700972 Liguria\n#&gt;  3:          7            9   7009010         IT2303A       700979 Liguria\n#&gt;  4:          7            9   7009015         IT2107A       700973 Liguria\n#&gt;  5:          7            9   7009015         IT2108A       700974 Liguria\n#&gt;  6:          7            9   7009015         IT2299A       700978 Liguria\n#&gt;  7:          7            9   7009023         IT2155A       700975 Liguria\n#&gt;  8:          7            9   7009052         IT1144A       700909 Liguria\n#&gt;  9:          7            9   7009056         IT1145A       700903 Liguria\n#&gt; 10:          7            9   7009056         IT1883A       700971 Liguria\n#&gt; 11:          7            9   7009056         IT2304A       700980 Liguria\n#&gt; 12:          7            9   7009064         IT1143A       700910 Liguria\n#&gt; 13:          7            9   7009064         IT2286A       700977 Liguria\n#&gt; 14:          7           10   7010006         IT2323A       701082 Liguria\n#&gt; 15:          7           10   7010009         IT1549A       701028 Liguria\n#&gt; 16:          7           10   7010015         IT2302A       701081 Liguria\n#&gt; 17:          7           10   7010025         IT0852A       701014 Liguria\n#&gt; 18:          7           10   7010025         IT0854A       701009 Liguria\n#&gt; 19:          7           10   7010025         IT0858A       701016 Liguria\n#&gt; 20:          7           10   7010025         IT1698A       701068 Liguria\n#&gt; 21:          7           10   7010025         IT1884A       701073 Liguria\n#&gt; 22:          7           10   7010032         IT2298A       701080 Liguria\n#&gt; 23:          7           10   7010046         IT2039A       701078 Liguria\n#&gt; 24:          7           11   7011015         IT1456A       701105 Liguria\n#&gt; 25:          7           11   7011015         IT1457A       701106 Liguria\n#&gt; 26:          7           11   7011015         IT1536A       701113 Liguria\n#&gt; 27:          7           11   7011015         IT1544A       701112 Liguria\n#&gt; 28:          7           11   7011015         IT1886A       701175 Liguria\n#&gt; 29:          7           11   7011026         IT1661A       701173 Liguria\n#&gt; 30:          7           11   7011027         IT2229A       701176 Liguria\n#&gt;     id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;     provincia                 comune                          nome_stazione\n#&gt;        &lt;char&gt;                 &lt;char&gt;                                 &lt;char&gt;\n#&gt;  1:   Imperia                Sanremo              PIAZZA BATTISTI - SANREMO\n#&gt;  2:    Savona                Albenga              REGIONE CAVALLO - ALBENGA\n#&gt;  3:    Savona               Bergeggi                BERGEGGI SV - CAPO VADO\n#&gt;  4:    Savona       Cairo Montenotte  LOCALITA' MAZZUCCA - CAIRO MONTENOTTE\n#&gt;  5:    Savona       Cairo Montenotte    LOCALITA' BRAGNO - CAIRO MONTENOTTE\n#&gt;  6:    Savona       Cairo Montenotte        CAIRO M. SV - VILLA SANGUINETTI\n#&gt;  7:    Savona                 Cengio                 CENGIO - RIO PARASACCO\n#&gt;  8:    Savona               Quiliano            MERCATO GENERALE - QUILIANO\n#&gt;  9:    Savona                 Savona                   CORSO RICCI - SAVONA\n#&gt; 10:    Savona                 Savona                       VARALDO - SAVONA\n#&gt; 11:    Savona                 Savona             SAVONA - MONTE SAN GIORGIO\n#&gt; 12:    Savona            Vado Ligure   VIA AURELIA - VIA FERRARIS - VADO L.\n#&gt; 13:    Savona            Vado Ligure             VIA DE LITTA - VADO LIGURE\n#&gt; 14:    Genova                Busalla                    BUSALLA GE - SUARDI\n#&gt; 15:    Genova            Campomorone                  CAMPORA - CAMPOMORONE\n#&gt; 16:    Genova               Chiavari                   CHIAVARI GE - DEVOTO\n#&gt; 17:    Genova                 Genova               MULTEDO - PEGLI - GENOVA\n#&gt; 18:    Genova                 Genova                 CORSO FIRENZE - GENOVA\n#&gt; 19:    Genova                 Genova                        QUARTO - GENOVA\n#&gt; 20:    Genova                 Genova CORSO EUROPA - VIA S. MARTINO - GENOVA\n#&gt; 21:    Genova                 Genova            CORSO BUENOS AIRES - GENOVA\n#&gt; 22:    Genova                 Masone                              MASONE GE\n#&gt; 23:    Genova                Rapallo        CAMPO SPORTIVO MACERA - RAPALLO\n#&gt; 24: La Spezia              La Spezia     SAN CIPRIANO - LIBERTA - LA SPEZIA\n#&gt; 25: La Spezia              La Spezia                   AMENDOLA - LA SPEZIA\n#&gt; 26: La Spezia              La Spezia                 MAGGIOLINA - LA SPEZIA\n#&gt; 27: La Spezia              La Spezia                FOSSAMASTRA - LA SPEZIA\n#&gt; 28: La Spezia              La Spezia           PIAZZA SAINT BON - LA SPEZIA\n#&gt; 29: La Spezia Santo Stefano di Magra                    SANTO STEFANO MAGRA\n#&gt; 30: La Spezia                Sarzana                LARGO PERTINI - SARZANA\n#&gt;     provincia                 comune                          nome_stazione\n#&gt;           tipo_zona tipo_stazione\n#&gt;              &lt;char&gt;        &lt;char&gt;\n#&gt;  1:               U             T\n#&gt;  2:               U             T\n#&gt;  3:               S             I\n#&gt;  4:               S             I\n#&gt;  5:               S             I\n#&gt;  6:               U             F\n#&gt;  7: RURALE-NEARCITY             F\n#&gt;  8:               S             I\n#&gt;  9:               U             T\n#&gt; 10:               U             F\n#&gt; 11:               R             I\n#&gt; 12:               U             T\n#&gt; 13:               S             I\n#&gt; 14:               U             T\n#&gt; 15:               S             F\n#&gt; 16:               U             F\n#&gt; 17:               U             T\n#&gt; 18:               U             F\n#&gt; 19:               U             F\n#&gt; 20:               U             T\n#&gt; 21:               U             T\n#&gt; 22:               S             F\n#&gt; 23:               U             T\n#&gt; 24:               U             T\n#&gt; 25:               U             T\n#&gt; 26:               U             F\n#&gt; 27:               U             I\n#&gt; 28:               U             T\n#&gt; 29:               S             T\n#&gt; 30:               U             T\n#&gt;           tipo_zona tipo_stazione\n\nGli operatori più comuni sono:\n\n==, &lt;, &lt;=, &gt;, &gt;=, !=: confrontano la variabile con il valore e selezionano rispettivamente righe con valori uguali, minori, minori o uguali, maggiori, maggiori o uguali, o diversi dal valore. Questi operatori funzionano sia con valori numerici sia con stringhe di testo.\nAttenzione: usare &lt; o &gt; con testo permette di filtrare per ordine alfabetico, ma questo uso non è consigliato.\n%like%: permette di cercare corrispondenze parziali all’interno di stringhe.\nPer esempio, nella colonna nome_stazione della data.table stazioni, si vogliono estrarre le informazioni relative alle stazioni identificate come LOCALITA’ MAZZUCCA - CAIRO MONTENOTTE, LOCALITA’ BRAGNO - CAIRO MONTENOTTE, CAIRO M. SV - VILLA SANGUINETTI. Non è possibile usare == CAIRO, perché il valore CAIRO può comparire in posizioni diverse o in forma abbreviata nel nome. Si può risolvere così:\n\nstazioni[nome_stazione %like% \"CAIR\",]\n#&gt;    id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;         &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;  &lt;char&gt;\n#&gt; 1:          7            9   7009015         IT2107A       700973 Liguria\n#&gt; 2:          7            9   7009015         IT2108A       700974 Liguria\n#&gt; 3:          7            9   7009015         IT2299A       700978 Liguria\n#&gt;    provincia           comune                         nome_stazione tipo_zona\n#&gt;       &lt;char&gt;           &lt;char&gt;                                &lt;char&gt;    &lt;char&gt;\n#&gt; 1:    Savona Cairo Montenotte LOCALITA' MAZZUCCA - CAIRO MONTENOTTE         S\n#&gt; 2:    Savona Cairo Montenotte   LOCALITA' BRAGNO - CAIRO MONTENOTTE         S\n#&gt; 3:    Savona Cairo Montenotte       CAIRO M. SV - VILLA SANGUINETTI         U\n#&gt;    tipo_stazione\n#&gt;           &lt;char&gt;\n#&gt; 1:             I\n#&gt; 2:             I\n#&gt; 3:             F\n\nPer selezionare invece tutte le righe che non contengono “CAIR”, si usa:\n\nstazioni[!(nome_stazione %like% \"CAIR\"),]\n#&gt;      id_regione id_provincia id_comune station_eu_code station_code  regione\n#&gt;           &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;   &lt;char&gt;\n#&gt;   1:          1            1   1001028         IT1128A       100114 Piemonte\n#&gt;   2:          1            1   1001073         IT1963A       100168 Piemonte\n#&gt;   3:          1            1   1001078         IT2101A       100171 Piemonte\n#&gt;   4:          1            1   1001099         IT1121A       100122 Piemonte\n#&gt;   5:          1            1   1001125         IT1788A       100165 Piemonte\n#&gt;  ---                                                                        \n#&gt; 589:         20          111  20111057         IT1273A      2009207 Sardegna\n#&gt; 590:         20          111  20111057         IT1575A      2009221 Sardegna\n#&gt; 591:         20          111  20111057         IT1576A      2009222 Sardegna\n#&gt; 592:         20          111  20111062         IT1994A      2010601 Sardegna\n#&gt; 593:         20          111  20111082         IT2011A      2009239 Sardegna\n#&gt;         provincia              comune         nome_stazione     tipo_zona\n#&gt;            &lt;char&gt;              &lt;char&gt;                &lt;char&gt;        &lt;char&gt;\n#&gt;   1:       Torino    Borgaro Torinese   Borgaro T. - Caduti             S\n#&gt;   2:       Torino      Ceresole Reale Ceresole Reale - Diga             R\n#&gt;   3:       Torino              Chieri     Chieri - Bersezio             S\n#&gt;   4:       Torino             Druento  Druento - La Mandria             R\n#&gt;   5:       Torino               Ivrea   Ivrea - Liberazione             S\n#&gt;  ---                                                                     \n#&gt; 589: Sud Sardegna          Portoscuso                CENPS4             S\n#&gt; 590: Sud Sardegna          Portoscuso                CENPS6             S\n#&gt; 591: Sud Sardegna          Portoscuso                CENPS7             S\n#&gt; 592: Sud Sardegna San Gavino Monreale                CENSG3             U\n#&gt; 593: Sud Sardegna               Seulo                CENSE0 RURALE-REMOTA\n#&gt;      tipo_stazione\n#&gt;             &lt;char&gt;\n#&gt;   1:             F\n#&gt;   2:             F\n#&gt;   3:             F\n#&gt;   4:             F\n#&gt;   5:             F\n#&gt;  ---              \n#&gt; 589:             F\n#&gt; 590:             I\n#&gt; 591:             F\n#&gt; 592:             F\n#&gt; 593:             F\n\n%in% e %notin%: selezionano righe in cui il valore della variabile è rispettivamente presente o assente in un vettore di valori.\nPer esempio, per filtrare le stazioni dei comuni di Vado Ligure e Quiliano:\n\nstazioni[comune %in% c(\"Vado Ligure\", \"Quiliano\"),]\n#&gt;    id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;         &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;  &lt;char&gt;\n#&gt; 1:          7            9   7009052         IT1144A       700909 Liguria\n#&gt; 2:          7            9   7009064         IT1143A       700910 Liguria\n#&gt; 3:          7            9   7009064         IT2286A       700977 Liguria\n#&gt;    provincia      comune                        nome_stazione tipo_zona\n#&gt;       &lt;char&gt;      &lt;char&gt;                               &lt;char&gt;    &lt;char&gt;\n#&gt; 1:    Savona    Quiliano          MERCATO GENERALE - QUILIANO         S\n#&gt; 2:    Savona Vado Ligure VIA AURELIA - VIA FERRARIS - VADO L.         U\n#&gt; 3:    Savona Vado Ligure           VIA DE LITTA - VADO LIGURE         S\n#&gt;    tipo_stazione\n#&gt;           &lt;char&gt;\n#&gt; 1:             I\n#&gt; 2:             T\n#&gt; 3:             I\n\n\nÈ possibile combinare più condizioni usando gli operatori logici & (e) e | (o):\n\n& seleziona righe che soddisfano tutte le condizioni;\n| seleziona righe che soddisfano almeno una.\n\nAd esempio, per filtrare le stazioni nella provincia di Savona o nel comune di Sanremo:\n\nstazioni[provincia == \"Savona\" | comune == \"Sanremo\",]\n#&gt;     id_regione id_provincia id_comune station_eu_code station_code regione\n#&gt;          &lt;num&gt;        &lt;num&gt;     &lt;num&gt;          &lt;char&gt;        &lt;num&gt;  &lt;char&gt;\n#&gt;  1:          7            8   7008055         IT1882A       700806 Liguria\n#&gt;  2:          7            9   7009002         IT2038A       700972 Liguria\n#&gt;  3:          7            9   7009010         IT2303A       700979 Liguria\n#&gt;  4:          7            9   7009015         IT2107A       700973 Liguria\n#&gt;  5:          7            9   7009015         IT2108A       700974 Liguria\n#&gt;  6:          7            9   7009015         IT2299A       700978 Liguria\n#&gt;  7:          7            9   7009023         IT2155A       700975 Liguria\n#&gt;  8:          7            9   7009052         IT1144A       700909 Liguria\n#&gt;  9:          7            9   7009056         IT1145A       700903 Liguria\n#&gt; 10:          7            9   7009056         IT1883A       700971 Liguria\n#&gt; 11:          7            9   7009056         IT2304A       700980 Liguria\n#&gt; 12:          7            9   7009064         IT1143A       700910 Liguria\n#&gt; 13:          7            9   7009064         IT2286A       700977 Liguria\n#&gt;     provincia           comune                         nome_stazione\n#&gt;        &lt;char&gt;           &lt;char&gt;                                &lt;char&gt;\n#&gt;  1:   Imperia          Sanremo             PIAZZA BATTISTI - SANREMO\n#&gt;  2:    Savona          Albenga             REGIONE CAVALLO - ALBENGA\n#&gt;  3:    Savona         Bergeggi               BERGEGGI SV - CAPO VADO\n#&gt;  4:    Savona Cairo Montenotte LOCALITA' MAZZUCCA - CAIRO MONTENOTTE\n#&gt;  5:    Savona Cairo Montenotte   LOCALITA' BRAGNO - CAIRO MONTENOTTE\n#&gt;  6:    Savona Cairo Montenotte       CAIRO M. SV - VILLA SANGUINETTI\n#&gt;  7:    Savona           Cengio                CENGIO - RIO PARASACCO\n#&gt;  8:    Savona         Quiliano           MERCATO GENERALE - QUILIANO\n#&gt;  9:    Savona           Savona                  CORSO RICCI - SAVONA\n#&gt; 10:    Savona           Savona                      VARALDO - SAVONA\n#&gt; 11:    Savona           Savona            SAVONA - MONTE SAN GIORGIO\n#&gt; 12:    Savona      Vado Ligure  VIA AURELIA - VIA FERRARIS - VADO L.\n#&gt; 13:    Savona      Vado Ligure            VIA DE LITTA - VADO LIGURE\n#&gt;           tipo_zona tipo_stazione\n#&gt;              &lt;char&gt;        &lt;char&gt;\n#&gt;  1:               U             T\n#&gt;  2:               U             T\n#&gt;  3:               S             I\n#&gt;  4:               S             I\n#&gt;  5:               S             I\n#&gt;  6:               U             F\n#&gt;  7: RURALE-NEARCITY             F\n#&gt;  8:               S             I\n#&gt;  9:               U             T\n#&gt; 10:               U             F\n#&gt; 11:               R             I\n#&gt; 12:               U             T\n#&gt; 13:               S             I",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "datatable.html#sec-select",
    "href": "datatable.html#sec-select",
    "title": "5  Manipolare i dati con data.table",
    "section": "5.4 Selezionare le colonne",
    "text": "5.4 Selezionare le colonne\nI filtri visti nella Sezione 5.3 agiscono sulle righe del dataset, ma non permettono di di selezionare direttamente le colonne di interesse. Per fare questo, si utilizza l’elemento j della sintassi dt[i, j, by].\nAd esempio, per estrarre i codici europei delle stazioni liguri:\n\nstazioni[regione == \"Liguria\", station_eu_code]\n#&gt;  [1] \"IT1882A\" \"IT2038A\" \"IT2303A\" \"IT2107A\" \"IT2108A\" \"IT2299A\" \"IT2155A\"\n#&gt;  [8] \"IT1144A\" \"IT1145A\" \"IT1883A\" \"IT2304A\" \"IT1143A\" \"IT2286A\" \"IT2323A\"\n#&gt; [15] \"IT1549A\" \"IT2302A\" \"IT0852A\" \"IT0854A\" \"IT0858A\" \"IT1698A\" \"IT1884A\"\n#&gt; [22] \"IT2298A\" \"IT2039A\" \"IT1456A\" \"IT1457A\" \"IT1536A\" \"IT1544A\" \"IT1886A\"\n#&gt; [29] \"IT1661A\" \"IT2229A\"\n\nQuesto restituisce un vettore. Se invece si vuole mantenere la struttura di una data.table (utile per ulteriori elaborazioni), è necessario racchiudere la colonna in .():\n\nstazioni[regione == \"Liguria\", .(station_eu_code)]\n#&gt;     station_eu_code\n#&gt;              &lt;char&gt;\n#&gt;  1:         IT1882A\n#&gt;  2:         IT2038A\n#&gt;  3:         IT2303A\n#&gt;  4:         IT2107A\n#&gt;  5:         IT2108A\n#&gt;  6:         IT2299A\n#&gt;  7:         IT2155A\n#&gt;  8:         IT1144A\n#&gt;  9:         IT1145A\n#&gt; 10:         IT1883A\n#&gt; 11:         IT2304A\n#&gt; 12:         IT1143A\n#&gt; 13:         IT2286A\n#&gt; 14:         IT2323A\n#&gt; 15:         IT1549A\n#&gt; 16:         IT2302A\n#&gt; 17:         IT0852A\n#&gt; 18:         IT0854A\n#&gt; 19:         IT0858A\n#&gt; 20:         IT1698A\n#&gt; 21:         IT1884A\n#&gt; 22:         IT2298A\n#&gt; 23:         IT2039A\n#&gt; 24:         IT1456A\n#&gt; 25:         IT1457A\n#&gt; 26:         IT1536A\n#&gt; 27:         IT1544A\n#&gt; 28:         IT1886A\n#&gt; 29:         IT1661A\n#&gt; 30:         IT2229A\n#&gt;     station_eu_code\n\nAll’interno di .() è possibile elencare più colonne, rinominarle o applicare operazioni. Il risultato verrà mostrato a video, ma non salvato a meno che non venga assegnato a una variabile.\nEcco alcuni esempi:\n\n# seleziona due colonne\nstazioni[regione == \"Liguria\", .(station_eu_code, id_comune)]\n#&gt;     station_eu_code id_comune\n#&gt;              &lt;char&gt;     &lt;num&gt;\n#&gt;  1:         IT1882A   7008055\n#&gt;  2:         IT2038A   7009002\n#&gt;  3:         IT2303A   7009010\n#&gt;  4:         IT2107A   7009015\n#&gt;  5:         IT2108A   7009015\n#&gt;  6:         IT2299A   7009015\n#&gt;  7:         IT2155A   7009023\n#&gt;  8:         IT1144A   7009052\n#&gt;  9:         IT1145A   7009056\n#&gt; 10:         IT1883A   7009056\n#&gt; 11:         IT2304A   7009056\n#&gt; 12:         IT1143A   7009064\n#&gt; 13:         IT2286A   7009064\n#&gt; 14:         IT2323A   7010006\n#&gt; 15:         IT1549A   7010009\n#&gt; 16:         IT2302A   7010015\n#&gt; 17:         IT0852A   7010025\n#&gt; 18:         IT0854A   7010025\n#&gt; 19:         IT0858A   7010025\n#&gt; 20:         IT1698A   7010025\n#&gt; 21:         IT1884A   7010025\n#&gt; 22:         IT2298A   7010032\n#&gt; 23:         IT2039A   7010046\n#&gt; 24:         IT1456A   7011015\n#&gt; 25:         IT1457A   7011015\n#&gt; 26:         IT1536A   7011015\n#&gt; 27:         IT1544A   7011015\n#&gt; 28:         IT1886A   7011015\n#&gt; 29:         IT1661A   7011026\n#&gt; 30:         IT2229A   7011027\n#&gt;     station_eu_code id_comune\n\n# rinomina le colonne\nstazioni[regione == \"Liguria\", .(eu_id = station_eu_code, \n                                 municipality_id = id_comune)]\n#&gt;       eu_id municipality_id\n#&gt;      &lt;char&gt;           &lt;num&gt;\n#&gt;  1: IT1882A         7008055\n#&gt;  2: IT2038A         7009002\n#&gt;  3: IT2303A         7009010\n#&gt;  4: IT2107A         7009015\n#&gt;  5: IT2108A         7009015\n#&gt;  6: IT2299A         7009015\n#&gt;  7: IT2155A         7009023\n#&gt;  8: IT1144A         7009052\n#&gt;  9: IT1145A         7009056\n#&gt; 10: IT1883A         7009056\n#&gt; 11: IT2304A         7009056\n#&gt; 12: IT1143A         7009064\n#&gt; 13: IT2286A         7009064\n#&gt; 14: IT2323A         7010006\n#&gt; 15: IT1549A         7010009\n#&gt; 16: IT2302A         7010015\n#&gt; 17: IT0852A         7010025\n#&gt; 18: IT0854A         7010025\n#&gt; 19: IT0858A         7010025\n#&gt; 20: IT1698A         7010025\n#&gt; 21: IT1884A         7010025\n#&gt; 22: IT2298A         7010032\n#&gt; 23: IT2039A         7010046\n#&gt; 24: IT1456A         7011015\n#&gt; 25: IT1457A         7011015\n#&gt; 26: IT1536A         7011015\n#&gt; 27: IT1544A         7011015\n#&gt; 28: IT1886A         7011015\n#&gt; 29: IT1661A         7011026\n#&gt; 30: IT2229A         7011027\n#&gt;       eu_id municipality_id\n\n# conta il numero di stazioni liguri\nstazioni[regione == \"Liguria\", length(station_eu_code)]\n#&gt; [1] 30\nstazioni[regione == \"Liguria\", .N]        # alternativa più veloce\n#&gt; [1] 30\nstazioni[regione == \"Liguria\", .(n = .N)] # data.table con intestazione\n#&gt;        n\n#&gt;    &lt;int&gt;\n#&gt; 1:    30\n\n# conta il numero di stazioni liguri e il numero dei comuni monitorati\nstazioni[regione == \"Liguria\", .(n_stazioni = .N,\n                                 n_comuni = unique(id_comune) |&gt; \n                                   length())]\n#&gt;    n_stazioni n_comuni\n#&gt;         &lt;int&gt;    &lt;int&gt;\n#&gt; 1:         30       17\n\n# salva il risultato in una variabile\nliguria_eu_id &lt;- stazioni[regione == \"Liguria\", station_eu_code]",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "datatable.html#sec-update",
    "href": "datatable.html#sec-update",
    "title": "5  Manipolare i dati con data.table",
    "section": "5.5 Modificare le colonne",
    "text": "5.5 Modificare le colonne\nL’importazione dei dati descritta nella Sezione 5.2.1 ha prodotto una data.table in cui alcune colonne non sono identificate con la giusta tipologia di dati. Si risolverà il problema in questa sezione, imparando a modificare le colonne sfruttando l’elemento j della sintassi dt[i, j, by], ma utilizzando l’operatore := al posto di =, come nell’esempio:\n\n# converte i valori di `valido` da testo a valori logici\npm_genova[, valido := fcase(valido == \"SI\", TRUE,\n                            valido == \"NO\", FALSE,\n                            default = NA)]\n\nPer modifiche multiple su più colonne, è possibile usare una sintassi più compatta:\n\n# l'operatore := è spostato fuori dalla parentesi nell'elemento j\n# mentre all'interno della parentesi si usa il segno =\npm_genova[, `:=` (\n  # standardizza le unità\n  udm = gsub(\"microg/m3\", \"µg/m³\", unita_di_misura),\n  # converte validato cor e certificato in valori logici\n  validato_cor = fcase(validato_cor == \"SI\", TRUE,\n                       validato_cor == \"NO\", FALSE,\n                       default = NA),\n  certificato = fcase(certificato == \"SI\", TRUE,\n                      certificato == \"NO\", FALSE,\n                      default = NA),\n  # converte le date specificando il formato di input\n  inizio = as.POSIXct(data_inizio, format = \"%d/%m/%Y %H:%M\", tz = \"GMT\"),\n  fine = as.POSIXct(data_fine, format = \"%d/%m/%Y %H:%M\", tz = \"GMT\"),\n  # elimina le vecchie colonne non più utili\n  unita_di_misura = NULL,\n  data_inizio = NULL,\n  data_fine = NULL\n)]\n\n\n\n\n\n\n\nBuone maniere\n\n\n\nLa ripetizione di spezzoni di codice, come nel caso di fcase() non è considerata una buona prassi: sarebbe stato meglio scrivere una funzione!",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "datatable.html#sec-by",
    "href": "datatable.html#sec-by",
    "title": "5  Manipolare i dati con data.table",
    "section": "5.6 Fare calcoli su gruppi di dati",
    "text": "5.6 Fare calcoli su gruppi di dati\nL’elemento by della sintassi dt[i, j, by] permette di ripetere un’operazione su diversi gruppi. Ad esempio, nel caso in cui si voglia calcolare il numero di giorni sottoposti a campionamento, il numero di valori misurati e il numero di valori mancanti per ogni stazione e inquinante, è possibile usare la seguente istruzione:\n\npm_genova[ , .(\n  giorni_campionati = difftime(fine, inizio, units = \"days\") |&gt; sum(na.rm = TRUE),\n  n_tot = .N,\n  n_na = is.na(valore) |&gt; sum()\n  ),\n  by = .(codice_europeo, inquinante)]\n#&gt;     codice_europeo inquinante giorni_campionati n_tot  n_na\n#&gt;             &lt;char&gt;     &lt;char&gt;        &lt;difftime&gt; &lt;int&gt; &lt;int&gt;\n#&gt;  1:        IT2302A       PM10     357.2917 days  7172     0\n#&gt;  2:        IT2302A      PM2,5     360.2500 days  7243     0\n#&gt;  3:        IT1698A       PM10     349.2500 days  8382     0\n#&gt;  4:        IT1698A      PM2,5     333.7917 days  8011     0\n#&gt;  5:        IT0854A       PM10     339.3750 days  8145     0\n#&gt;  6:        IT0854A      PM2,5     339.3333 days  8144     0\n#&gt;  7:        IT2339A       PM10     347.2500 days  8334     0\n#&gt;  8:        IT2339A      PM2,5     344.8333 days  8276     0\n#&gt;  9:        IT2327A       PM10     360.1667 days  8644     0\n#&gt; 10:        IT2327A      PM2,5     360.1667 days  8644     0\n#&gt; 11:        IT0852A       PM10     356.8750 days  8565     0\n#&gt; 12:        IT0858A       PM10     350.5417 days  8413     0\n#&gt; 13:        IT0858A      PM2,5     350.5417 days  8413     0\n#&gt; 14:        IT2323A       PM10     361.0000 days   361     0\n#&gt; 15:        IT2323A      PM2,5     361.0000 days   361     0\n#&gt; 16:        IT2039A       PM10     357.0000 days   357     0\n#&gt; 17:        IT2039A      PM2,5     356.0000 days   356     0\n#&gt; 18:        IT1549A       PM10     360.0000 days   360     0\n#&gt; 19:        IT1549A      PM2,5     360.0000 days   360     0\n#&gt; 20:        IT1884A       PM10     351.0000 days   351     0\n#&gt; 21:        IT2298A       PM10     342.0000 days   342     0\n#&gt; 22:        IT2298A      PM2,5     342.0000 days   342     0\n#&gt; 23:                      PM10     266.6667 days  6400     0\n#&gt; 24:                     PM2,5     266.6667 days  6400     0\n#&gt;     codice_europeo inquinante giorni_campionati n_tot  n_na\n\nRisulta evidente come, a fronte di un tempo di campionamento totale circa uguale, alcune stazioni abbiano fatto molte più misure: sono quelle dotate di un sistema di misura in continuo (contatore ottico o a raggi \\(\\beta\\)).\nAll’interno dell’espressione by è possibile inserire anche espressioni, come nel caso seguente per il calcolo della concentrazione media giornaliera:\n\npm_genova[, .(media_giornaliera = mean(valore, na.rm = TRUE)), \n          by = .(codice_europeo, inquinante, data = as.IDate(inizio))]\n#&gt;       codice_europeo inquinante       data media_giornaliera\n#&gt;               &lt;char&gt;     &lt;char&gt;     &lt;IDat&gt;             &lt;num&gt;\n#&gt;    1:        IT2302A       PM10 2024-12-31          14.51667\n#&gt;    2:        IT2302A      PM2,5 2024-12-31          10.26250\n#&gt;    3:        IT1698A       PM10 2024-12-31          24.27083\n#&gt;    4:        IT1698A      PM2,5 2024-12-31          18.05652\n#&gt;    5:        IT0854A       PM10 2024-12-31          11.61667\n#&gt;   ---                                                       \n#&gt; 8416:        IT2302A       PM10 2024-01-01          16.50000\n#&gt; 8417:        IT2302A      PM2,5 2024-01-01           9.40000\n#&gt; 8418:        IT1884A       PM10 2024-01-01          20.70000\n#&gt; 8419:        IT2298A       PM10 2024-01-01          14.00000\n#&gt; 8420:        IT2298A      PM2,5 2024-01-01           9.50000",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "datatable.html#concatenare-operazioni",
    "href": "datatable.html#concatenare-operazioni",
    "title": "5  Manipolare i dati con data.table",
    "section": "5.7 Concatenare operazioni",
    "text": "5.7 Concatenare operazioni\nNel caso di operazioni complesse, composte di più passaggi, normalmente si usa la pipe (|&gt;) o si salva ogni risultato intermedio in una variabile. Il pacchetto data.table offre una possibilità in più.\nRiprendendo l’esempio della Sezione 5.6 e volendo calcolare per ogni stazione il numero di giornate il cui la concentrazione media giornaliera di PM10 è superiore del limite di \\(50\\, \\mu g/m^3\\), è possibile usare l’espressione:\n\n# prima espressione\npm_genova[, .(media_giornaliera = mean(valore, na.rm = TRUE)), \n          by = .(codice_europeo, inquinante, data = as.IDate(inizio))][\n# seconda espressione\n            inquinante == \"PM10\", \n            .(sopra50 = (media_giornaliera &gt; 50) |&gt; sum()),\n          by = .(codice_europeo, anno = year(data))]\n#&gt;     codice_europeo  anno sopra50\n#&gt;             &lt;char&gt; &lt;int&gt;   &lt;int&gt;\n#&gt;  1:        IT2302A  2024       3\n#&gt;  2:        IT1698A  2024       3\n#&gt;  3:        IT0854A  2024       3\n#&gt;  4:        IT2339A  2024       3\n#&gt;  5:        IT2327A  2024       4\n#&gt;  6:        IT0852A  2024       4\n#&gt;  7:        IT0858A  2024       0\n#&gt;  8:        IT2323A  2024       8\n#&gt;  9:        IT2039A  2024       5\n#&gt; 10:        IT1549A  2024       1\n#&gt; 11:        IT1884A  2024       3\n#&gt; 12:        IT2298A  2024       4\n#&gt; 13:                 2024       3\n\n\n\n\n\n\n\nPer i più golosi\n\n\n\nCon il comando vignette(\"datatable-intro\") è possible avere informazioni aggiuntive sull’utilizzo di base del pacchetto data.table.\n\n\n\nEsercizioSoluzione\n\n\nUtilizzando il dataset pm_genova importato e modificato nelle sezioni precedenti, calcolare il minimo, la mediana, la media e il massimo delle concentrazioni giornaliere di PM10 e PM2,5 misurate nel 2024 per ogni stazione.\nIdentificare le stazioni con valori medi annuali di PM2,5 superiori a \\(10\\, \\mu g/m^3\\).\n\n\n\n# 1\npm_genova[, .(\n  minimo = min(valore, na.rm = TRUE),\n  mediana = median(valore, na.rm = TRUE),\n  media = mean(valore, na.rm = TRUE),\n  max = max(valore, na.rm = TRUE)\n  ),\n  by = .(codice_europeo, inquinante, data = as.IDate(inizio))]\n#&gt;       codice_europeo inquinante       data minimo mediana    media   max\n#&gt;               &lt;char&gt;     &lt;char&gt;     &lt;IDat&gt;  &lt;num&gt;   &lt;num&gt;    &lt;num&gt; &lt;num&gt;\n#&gt;    1:        IT2302A       PM10 2024-12-31    0.9   13.85 14.51667  28.9\n#&gt;    2:        IT2302A      PM2,5 2024-12-31   -6.1   11.15 10.26250  26.7\n#&gt;    3:        IT1698A       PM10 2024-12-31    6.1   22.30 24.27083  50.7\n#&gt;    4:        IT1698A      PM2,5 2024-12-31   -6.3   17.30 18.05652  39.4\n#&gt;    5:        IT0854A       PM10 2024-12-31    0.2   11.15 11.61667  27.3\n#&gt;   ---                                                                   \n#&gt; 8416:        IT2302A       PM10 2024-01-01   16.5   16.50 16.50000  16.5\n#&gt; 8417:        IT2302A      PM2,5 2024-01-01    9.4    9.40  9.40000   9.4\n#&gt; 8418:        IT1884A       PM10 2024-01-01   20.7   20.70 20.70000  20.7\n#&gt; 8419:        IT2298A       PM10 2024-01-01   14.0   14.00 14.00000  14.0\n#&gt; 8420:        IT2298A      PM2,5 2024-01-01    9.5    9.50  9.50000   9.5\n\n# 2\npm_genova[inquinante == \"PM2,5\",\n          .(media_annuale = mean(valore, na.rm = TRUE)), \n          by = .(codice_europeo)][\n            media_annuale &gt; 10]\n#&gt;    codice_europeo media_annuale\n#&gt;            &lt;char&gt;         &lt;num&gt;\n#&gt; 1:        IT1698A      13.41177\n#&gt; 2:        IT2339A      10.81406\n#&gt; 3:        IT2327A      11.33169\n#&gt; 4:        IT2323A      14.19280\n#&gt; 5:        IT2039A      11.18157\n#&gt; 6:        IT2298A      10.50409",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Manipolare i dati con `data.table`</span>"
    ]
  },
  {
    "objectID": "reshape.html",
    "href": "reshape.html",
    "title": "6  Cambiare la forma dei dati",
    "section": "",
    "text": "6.1 La forma dei dati\nIn questo capitolo sono gestiti i dati nei loro due formati principali: wide (una entità osservata per riga, variabili in colonne) e long (una misura per riga, con tipo e valore separati). Si passerà da un formato all’altro con i comandi melt() e dcast(), imparando a gestire casi con misure multiple o mancanti, e a utilizzando opzioni di aggregazione per risolvere duplicati. Queste tecniche sono fondamentali per preparare i dati all’analisi e alla visualizzazione.\nI dati con cui si lavora abitualmente sono composti da entità osservate (o osservabili) e misure (o variabili) ad essi associate. Ad esempio, volendo prendere in considerazione i dati prodotti da un laboratorio, le entità osservate saranno i singoli campioni, mentre le misure saranno i valori risultanti dalle diverse metodiche a cui tali campioni sono sottoposti.\nQuesta tipologia di dati possono essere organizzati in due differenti formati:\nLa scelta tra i due formati dipende dal tipo di operazione che si vuole eseguire sui dati ed è frequente dover passare da un formato all’altro.",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cambiare la forma dei dati</span>"
    ]
  },
  {
    "objectID": "reshape.html#sec-shapes",
    "href": "reshape.html#sec-shapes",
    "title": "6  Cambiare la forma dei dati",
    "section": "",
    "text": "wide: i dati sono organizzati con un’entità osservata per riga e una misura per colonna. Ecco un esempio:\n\nlibrary(data.table)\n\ncampioni_wide &lt;- data.table(\ncodice_campione = c(\"22201/24\", \"22248/24\", \"22311/24\"),\ndata_campionamento = as.IDate(c(\"2024-01-15\", \"2024-02-20\", \"2024-03-10\")),\ncadmio = c(0.05, 0.06, 0.04),\npiombo = c(0.1, 0.15, 0.12)\n)\n\n\n\n\n\n\n\n\n\ncodice_campione\ndata_campionamento\ncadmio\npiombo\n\n\n\n\n22201/24\n2024-01-15\n0.05\n0.10\n\n\n22248/24\n2024-02-20\n0.06\n0.15\n\n\n22311/24\n2024-03-10\n0.04\n0.12\n\n\n\n\n\n\n\nQuesto formato risulta comodo per la visualizzazione dei dati e il confronto diretto tra le diverse variabili.\nlong: i dati sono organizzati con una misura per riga. La tipologia della misura è archiviata all’interno di un’apposita variabile, come mostrato nell’esempio:\n\ncampioni_long &lt;- data.table(\n  codice_campione = c(\"22201/24\", \"22248/24\", \"22311/24\") |&gt; \n    rep(each = 2),\n  data_campionamento = c(\"2024-01-15\", \"2024-02-20\", \"2024-03-10\") |&gt; \n    rep(each = 2) |&gt; \n    as.IDate(),\n  tipo_misura = c(\"cadmio\", \"piombo\") |&gt; \n    rep(times = 3),\n  valore_misura = c(0.05, 0.10, 0.06, 0.15, 0.04, 0.12)\n)\n\n\n\n\n\n\n\n\n\ncodice_campione\ndata_campionamento\ntipo_misura\nvalore_misura\n\n\n\n\n22201/24\n2024-01-15\ncadmio\n0.05\n\n\n22201/24\n2024-01-15\npiombo\n0.10\n\n\n22248/24\n2024-02-20\ncadmio\n0.06\n\n\n22248/24\n2024-02-20\npiombo\n0.15\n\n\n22311/24\n2024-03-10\ncadmio\n0.04\n\n\n22311/24\n2024-03-10\npiombo\n0.12\n\n\n\n\n\n\n\nÈ un formato indispensabile per la gestione dei dati con molte variabili o per la produzione di grafici e l’esecuzione di molte analisi statistiche.",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cambiare la forma dei dati</span>"
    ]
  },
  {
    "objectID": "reshape.html#la-funzione-melt-da-wide-a-long",
    "href": "reshape.html#la-funzione-melt-da-wide-a-long",
    "title": "6  Cambiare la forma dei dati",
    "section": "6.2 La funzione melt(): da wide a long",
    "text": "6.2 La funzione melt(): da wide a long\nLa funzione melt() scioglie i dati in formato wide portandoli in formato long e utilizza la seguente sintassi:\n\nmelt(data, id.vars, measure.vars, variable.name = \"variable\", value.name = \"value\")\n\n\ndata: una data.table;\nid.vars: le colonne da mantenere fisse e che svolgono il ruolo di identificatori dell’entità osservata;\nmeasure.vars: le colonne da “sciogliere” e che contengono le misure;\nvariable.name: il nome della colonna che conterrà le variabili “sciolte” e quindi la tipologia di misura. Il valore di default è variable;\nvalue.name: il nome della colonna che conterrà i valori della misura. Il valore di default è value.\n\nTutti gli argomenti sono opzionali, tuttavia è sempre buona norma specificare id.vars e measure.vars. In caso contrario la funzione melt() imposterà tutte le colonne non numeriche o di tipo logico come id.vars e le restanti colonne come measure.vars.\nEcco come trasformare campioni_wide in formato long:\n\ncampioni_wide |&gt; \n  melt(id.vars = c(\"codice_campione\", \"data_campionamento\"),\n       measure.vars = c(\"cadmio\", \"piombo\"),\n       variable.name = \"tipo_misura\",\n       value.name = \"valore_misura\") |&gt; \n  _[order(codice_campione)] # ordina per codice campione\n#&gt;    codice_campione data_campionamento tipo_misura valore_misura\n#&gt;             &lt;char&gt;             &lt;IDat&gt;      &lt;fctr&gt;         &lt;num&gt;\n#&gt; 1:        22201/24         2024-01-15      cadmio          0.05\n#&gt; 2:        22201/24         2024-01-15      piombo          0.10\n#&gt; 3:        22248/24         2024-02-20      cadmio          0.06\n#&gt; 4:        22248/24         2024-02-20      piombo          0.15\n#&gt; 5:        22311/24         2024-03-10      cadmio          0.04\n#&gt; 6:        22311/24         2024-03-10      piombo          0.12\n\nLa funzione “scioglie” le colonne specificate in measure.vars in due colonne: la prima relativa alla tipologia di misura, identificata con il nome specificato in variable.name e una seconda relativa al valore della misura, identificata con il nome specificato in value.name. Le informazioni contenute in id.vars sono ripetute per il numero totale di misure effettuate per ogni entità osservata.",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cambiare la forma dei dati</span>"
    ]
  },
  {
    "objectID": "reshape.html#la-funzione-dcast-da-long-a-wide",
    "href": "reshape.html#la-funzione-dcast-da-long-a-wide",
    "title": "6  Cambiare la forma dei dati",
    "section": "6.3 La funzione dcast(): da long a wide",
    "text": "6.3 La funzione dcast(): da long a wide\n\n6.3.1 Significato e sintassi di base\nLa funzione dcast() proietta i dati in formato long distribuendone il contenuto su un più colonne, per ottenere un formato wide. Si tratta di un’operazione analoga a quella fornita dalle tabelle pivot dei sistemi basati su fogli di calcolo e, nettamente più delicata rispetto a quella eseguita dalla funzione melt().\nLa complessità e potenza dell’operazione di proiezione è testimoniata dalla sintassi della funzione dcast():\n\ndcast(data, formula, fun.aggregate = NULL, value.var = NULL, fill = NULL)\n\n\ndata: una data.table;\nformula: la formula che indica come distribuire le righe e colonne, es. id ~ variable significa che la colonna id identificherà le righe, e quindi le entità osservate, mentre i valori univoci di variable diventeranno altrettante colonne;\nfun.aggregate: definisce come aggregare i valori nel caso di più misure effettuate per la stessa tipologia di misura e sulla medesima entità osservata;\nvalue.var: il nome della colonna con i valori da distribuire;\nfill: il valore da mettere in caso di combinazioni mancanti (es. NA o 0).\n\nEcco come trasformare campioni_long in formato wide:\n\ncampioni_long |&gt; \n  dcast(codice_campione + data_campionamento ~ tipo_misura,\n        value.var = \"valore_misura\") |&gt;\n  _[order(codice_campione)] # ordina per codice campione\n#&gt; Key: &lt;codice_campione, data_campionamento&gt;\n#&gt;    codice_campione data_campionamento cadmio piombo\n#&gt;             &lt;char&gt;             &lt;IDat&gt;  &lt;num&gt;  &lt;num&gt;\n#&gt; 1:        22201/24         2024-01-15   0.05   0.10\n#&gt; 2:        22248/24         2024-02-20   0.06   0.15\n#&gt; 3:        22311/24         2024-03-10   0.04   0.12\n\n\n\n6.3.2 Misure multiple e misure mancanti\nSi devono aggiungere a campioni_long i valori misurati per un quarto campione per cui la concentrazione di cadmio è stata misurata una volta, mentre sono state effettuate tre determinazioni indipendenti della concentrazione di zinco.\n\nnuovi_dati &lt;- data.table(\n  codice_campione = rep(\"22345/24\", 4),\n  data_campionamento = rep(\"2024-04-01\", 4) |&gt; as.IDate(),\n  tipo_misura = c(\"cadmio\", rep(\"zinco\", 3)),\n  valore_misura = c(0.07, 0.28, 0.32, 0.30)\n  )\ncampioni_long &lt;- rbind(campioni_long,\n                       nuovi_dati)\n\nSe si proiettassero i dati come fatto nella Sezione 6.3.1, si otterrebbe:\n\n#&gt; Warning in dcast.data.table(campioni_long, codice_campione + data_campionamento\n#&gt; ~ : 'fun.aggregate' is NULL, but found duplicate row/column combinations, so\n#&gt; defaulting to length(). That is, the variables [codice_campione,\n#&gt; data_campionamento, tipo_misura] used in 'formula' do not uniquely identify\n#&gt; rows in the input 'data'. In such cases, 'fun.aggregate' is used to derive a\n#&gt; single representative value for each combination in the output data.table, for\n#&gt; example by summing or averaging (fun.aggregate=sum or fun.aggregate=mean,\n#&gt; respectively). Check the resulting table for values larger than 1 to see which\n#&gt; combinations were not unique. See ?dcast.data.table for more details.\n#&gt; Key: &lt;codice_campione, data_campionamento&gt;\n#&gt;    codice_campione data_campionamento cadmio piombo zinco\n#&gt;             &lt;char&gt;             &lt;IDat&gt;  &lt;int&gt;  &lt;int&gt; &lt;int&gt;\n#&gt; 1:        22201/24         2024-01-15      1      1     0\n#&gt; 2:        22248/24         2024-02-20      1      1     0\n#&gt; 3:        22311/24         2024-03-10      1      1     0\n#&gt; 4:        22345/24         2024-04-01      1      0     3\n\nla funzione, si è accorta che compaiono misure ripetute e, non sapendo cosa farci, avvisa e si limita a contare il numero di misure per ogni entità e ogni tipologia di misura.\nNel caso si voglia ottenere la media delle misure ripetute, usando NA per le misure mancanti, si può scrivere:\n\ncampioni_long |&gt; \n  dcast(codice_campione + data_campionamento ~ tipo_misura,\n        value.var = \"valore_misura\",\n        fun.aggregate = mean,\n        fill = \"NA\") |&gt;\n  _[order(codice_campione)] # ordina per codice campione\n#&gt; Warning in dcast.data.table(campioni_long, codice_campione + data_campionamento\n#&gt; ~ : Coercing 'character' RHS to 'double' to match the type of target vector.\n#&gt; Warning in dcast.data.table(campioni_long, codice_campione + data_campionamento\n#&gt; ~ : NAs introduced by coercion\n#&gt; Key: &lt;codice_campione, data_campionamento&gt;\n#&gt;    codice_campione data_campionamento cadmio piombo zinco\n#&gt;             &lt;char&gt;             &lt;IDat&gt;  &lt;num&gt;  &lt;num&gt; &lt;num&gt;\n#&gt; 1:        22201/24         2024-01-15   0.05   0.10    NA\n#&gt; 2:        22248/24         2024-02-20   0.06   0.15    NA\n#&gt; 3:        22311/24         2024-03-10   0.04   0.12    NA\n#&gt; 4:        22345/24         2024-04-01   0.07     NA   0.3\n\n\n\n\n\n\n\nPer i più golosi\n\n\n\nCon il comando vignette(\"datatable-reshape\") è possible avere informazioni aggiuntive sulla modifica della forma dei dati con il pacchetto data.table.\n\n\n\nEsercizioSoluzione\n\n\nUtilizzando il dataset pm_genova:\n\nidentificare se il dataset è in formato wide o long;\nidentificare l’entità osservata;\nidentificare la o le colonne con la tipologia di misura e il relativo valore;\nconvertire il dataset in formato wide o long a seconda di come è stato fornito;\nvalutare la presenza di valori duplicati ed eventualmente fornire il risultato medio;\nconvertire il dataset in formato wide o long, a seconda di come è stato fornito, evitando operazioni di aggregazione sui valori.\n\n\n\n\nOgni riga del dataset si riferisce a una misura, quindi è in formato long;\nl’entità osservata sono i campioni misurati con frequenza oraria o giornaliera nelle diverse stazioni;\nla tipologia di misura è identificata dalla colonna inquinante e i relativi valori sono salvati nelle colonna valore, valido, validato_cor e certificato;\nla presenza di valori duplicati è attestata dall’utilizzo della funzione dcast() senza specificare l’argomento di fun.aggregate nel codice riportato nel punto successivo;\nla conversione in formato wide, mediando i risultati delle misure ripetute, può essere ottenuta con:\n\ndcast(\n  pm_genova,\n  codice_europeo + inizio + fine + metodo + udm ~ \n  inquinante,\n  fun.aggregate = mean,\n  value.var = c(\"valore\", \"valido\", \"validato_cor\", \"certificato\")\n  )\n#&gt; Key: &lt;codice_europeo, inizio, fine, metodo, udm&gt;\n#&gt;        codice_europeo              inizio                fine\n#&gt;                &lt;char&gt;              &lt;POSc&gt;              &lt;POSc&gt;\n#&gt;     1:                2024-01-01 00:00:00 2024-01-01 01:00:00\n#&gt;     2:                2024-01-01 01:00:00 2024-01-01 02:00:00\n#&gt;     3:                2024-01-01 02:00:00 2024-01-01 03:00:00\n#&gt;     4:                2024-01-01 03:00:00 2024-01-01 04:00:00\n#&gt;     5:                2024-01-01 04:00:00 2024-01-01 05:00:00\n#&gt;    ---                                                       \n#&gt; 66338:        IT2339A 2024-12-31 19:00:00 2024-12-31 20:00:00\n#&gt; 66339:        IT2339A 2024-12-31 20:00:00 2024-12-31 21:00:00\n#&gt; 66340:        IT2339A 2024-12-31 21:00:00 2024-12-31 22:00:00\n#&gt; 66341:        IT2339A 2024-12-31 22:00:00 2024-12-31 23:00:00\n#&gt; 66342:        IT2339A 2024-12-31 23:00:00 2025-01-01 00:00:00\n#&gt;                                                             metodo    udm\n#&gt;                                                             &lt;char&gt; &lt;char&gt;\n#&gt;     1: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     2: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     3: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     4: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     5: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;    ---                                                                   \n#&gt; 66338:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt; 66339:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt; 66340:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt; 66341:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt; 66342:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt;        valore_PM10 valore_PM2,5 valido_PM10 valido_PM2,5 validato_cor_PM10\n#&gt;              &lt;num&gt;        &lt;num&gt;       &lt;num&gt;        &lt;num&gt;             &lt;num&gt;\n#&gt;     1:       32.70        27.25           1            1                 1\n#&gt;     2:       15.85        14.60           1            1                 1\n#&gt;     3:       15.75        14.25           1            1                 1\n#&gt;     4:       14.10        11.35           1            1                 1\n#&gt;     5:       16.00        11.35           1            1                 1\n#&gt;    ---                                                                    \n#&gt; 66338:       31.60        15.70           1            1                 1\n#&gt; 66339:       43.50        24.80           1            1                 1\n#&gt; 66340:       47.20        33.00           1            1                 1\n#&gt; 66341:       32.90        27.00           1            1                 1\n#&gt; 66342:       48.50        37.70           1            1                 1\n#&gt;        validato_cor_PM2,5 certificato_PM10 certificato_PM2,5\n#&gt;                     &lt;num&gt;            &lt;num&gt;             &lt;num&gt;\n#&gt;     1:                  1               NA                NA\n#&gt;     2:                  1               NA                NA\n#&gt;     3:                  1               NA                NA\n#&gt;     4:                  1               NA                NA\n#&gt;     5:                  1               NA                NA\n#&gt;    ---                                                      \n#&gt; 66338:                  1               NA                NA\n#&gt; 66339:                  1               NA                NA\n#&gt; 66340:                  1               NA                NA\n#&gt; 66341:                  1               NA                NA\n#&gt; 66342:                  1               NA                NA\n\nManca la riconversione dei valori nelle colonne valido, validato_cor e certificato in valori logici.\nUn’alternativa più complessa ma maggiormente efficiente è ottenibile definendo prima una funzione che calcolerà il numero di elementi e in caso di mancanza di elementi ripetuti li convertirà in valori logici:\n\ndiventa_logico &lt;- function(x) {\n\n  lunghezza &lt;- length(x)\n  ifelse(lunghezza == 1, x, NA)}\n\nutilizzo la funzione all’interno di una lista di fun.aggregate:\n\ndcast(\n    pm_genova,\n    codice_europeo + inizio + fine + metodo + udm ~ \n        inquinante,\n    fun.aggregate = list(mean, diventa_logico, diventa_logico, diventa_logico),\n    value.var = list(\"valore\", \"valido\", \"validato_cor\", \"certificato\")\n)\n#&gt; Key: &lt;codice_europeo, inizio, fine, metodo, udm&gt;\n#&gt;        codice_europeo              inizio                fine\n#&gt;                &lt;char&gt;              &lt;POSc&gt;              &lt;POSc&gt;\n#&gt;     1:                2024-01-01 00:00:00 2024-01-01 01:00:00\n#&gt;     2:                2024-01-01 01:00:00 2024-01-01 02:00:00\n#&gt;     3:                2024-01-01 02:00:00 2024-01-01 03:00:00\n#&gt;     4:                2024-01-01 03:00:00 2024-01-01 04:00:00\n#&gt;     5:                2024-01-01 04:00:00 2024-01-01 05:00:00\n#&gt;    ---                                                       \n#&gt; 66338:        IT2339A 2024-12-31 19:00:00 2024-12-31 20:00:00\n#&gt; 66339:        IT2339A 2024-12-31 20:00:00 2024-12-31 21:00:00\n#&gt; 66340:        IT2339A 2024-12-31 21:00:00 2024-12-31 22:00:00\n#&gt; 66341:        IT2339A 2024-12-31 22:00:00 2024-12-31 23:00:00\n#&gt; 66342:        IT2339A 2024-12-31 23:00:00 2025-01-01 00:00:00\n#&gt;                                                             metodo    udm\n#&gt;                                                             &lt;char&gt; &lt;char&gt;\n#&gt;     1: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     2: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     3: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     4: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     5: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;    ---                                                                   \n#&gt; 66338:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt; 66339:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt; 66340:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt; 66341:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt; 66342:                                  CAMP. CONTINUO, RAGGI BETA  µg/m³\n#&gt;        valore_mean_PM10 valore_mean_PM2,5 valido_diventa_logico_PM10\n#&gt;                   &lt;num&gt;             &lt;num&gt;                     &lt;lgcl&gt;\n#&gt;     1:            32.70             27.25                         NA\n#&gt;     2:            15.85             14.60                         NA\n#&gt;     3:            15.75             14.25                         NA\n#&gt;     4:            14.10             11.35                         NA\n#&gt;     5:            16.00             11.35                         NA\n#&gt;    ---                                                              \n#&gt; 66338:            31.60             15.70                       TRUE\n#&gt; 66339:            43.50             24.80                       TRUE\n#&gt; 66340:            47.20             33.00                       TRUE\n#&gt; 66341:            32.90             27.00                       TRUE\n#&gt; 66342:            48.50             37.70                       TRUE\n#&gt;        valido_diventa_logico_PM2,5 validato_cor_diventa_logico_PM10\n#&gt;                             &lt;lgcl&gt;                           &lt;lgcl&gt;\n#&gt;     1:                          NA                               NA\n#&gt;     2:                          NA                               NA\n#&gt;     3:                          NA                               NA\n#&gt;     4:                          NA                               NA\n#&gt;     5:                          NA                               NA\n#&gt;    ---                                                             \n#&gt; 66338:                        TRUE                             TRUE\n#&gt; 66339:                        TRUE                             TRUE\n#&gt; 66340:                        TRUE                             TRUE\n#&gt; 66341:                        TRUE                             TRUE\n#&gt; 66342:                        TRUE                             TRUE\n#&gt;        validato_cor_diventa_logico_PM2,5 certificato_diventa_logico_PM10\n#&gt;                                   &lt;lgcl&gt;                          &lt;lgcl&gt;\n#&gt;     1:                                NA                              NA\n#&gt;     2:                                NA                              NA\n#&gt;     3:                                NA                              NA\n#&gt;     4:                                NA                              NA\n#&gt;     5:                                NA                              NA\n#&gt;    ---                                                                  \n#&gt; 66338:                              TRUE                              NA\n#&gt; 66339:                              TRUE                              NA\n#&gt; 66340:                              TRUE                              NA\n#&gt; 66341:                              TRUE                              NA\n#&gt; 66342:                              TRUE                              NA\n#&gt;        certificato_diventa_logico_PM2,5\n#&gt;                                  &lt;lgcl&gt;\n#&gt;     1:                               NA\n#&gt;     2:                               NA\n#&gt;     3:                               NA\n#&gt;     4:                               NA\n#&gt;     5:                               NA\n#&gt;    ---                                 \n#&gt; 66338:                               NA\n#&gt; 66339:                               NA\n#&gt; 66340:                               NA\n#&gt; 66341:                               NA\n#&gt; 66342:                               NA\n\nAnche a value.var viene assegnata una lista, questo permette di associare univocamente i valori e le funzioni da applicare. Per maggiori informazioni, è possibile consultare gli ultimi due esempi riportati in ?dcast.\nper eseguire la conversione in formato wide evitando operazioni di aggregazione, è necessario creare un indice che distingua i valori replicati. I valori replicati hanno insiemi di codice_europeo, inizio, fine e metodo e inquinante uguali.\nSi può fare così:\n\n# l'indice id aumenta da 1 a N,\n# dove N è il numero di righe con codice_europeo, inizio, fine, metodo e\n# inquinante uguali\npm_genova[, id := 1:.N, \n          by = .(codice_europeo, inizio, fine, metodo, inquinante)]\n\ndcast(\n  pm_genova,\n  id + codice_europeo + inizio + fine + metodo + udm ~ \n  inquinante,\n  value.var = c(\"valore\", \"valido\", \"validato_cor\", \"certificato\")\n    )\n#&gt; Key: &lt;id, codice_europeo, inizio, fine, metodo, udm&gt;\n#&gt;           id codice_europeo              inizio                fine\n#&gt;        &lt;int&gt;         &lt;char&gt;              &lt;POSc&gt;              &lt;POSc&gt;\n#&gt;     1:     1                2024-01-01 00:00:00 2024-01-01 01:00:00\n#&gt;     2:     1                2024-01-01 01:00:00 2024-01-01 02:00:00\n#&gt;     3:     1                2024-01-01 02:00:00 2024-01-01 03:00:00\n#&gt;     4:     1                2024-01-01 03:00:00 2024-01-01 04:00:00\n#&gt;     5:     1                2024-01-01 04:00:00 2024-01-01 05:00:00\n#&gt;    ---                                                             \n#&gt; 66543:     2                2024-01-09 08:00:00 2024-01-09 09:00:00\n#&gt; 66544:     2                2024-01-09 09:00:00 2024-01-09 10:00:00\n#&gt; 66545:     2                2024-01-09 10:00:00 2024-01-09 11:00:00\n#&gt; 66546:     2                2024-01-09 11:00:00 2024-01-09 12:00:00\n#&gt; 66547:     2                2024-01-09 12:00:00 2024-01-09 13:00:00\n#&gt;                                                             metodo    udm\n#&gt;                                                             &lt;char&gt; &lt;char&gt;\n#&gt;     1: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     2: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     3: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     4: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;     5: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;    ---                                                                   \n#&gt; 66543: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt; 66544: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt; 66545: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt; 66546: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt; 66547: Contatore ottico particelle + conversione in concentrazione  µg/m³\n#&gt;        valore_PM10 valore_PM2,5 valido_PM10 valido_PM2,5 validato_cor_PM10\n#&gt;              &lt;num&gt;        &lt;num&gt;      &lt;lgcl&gt;       &lt;lgcl&gt;            &lt;lgcl&gt;\n#&gt;     1:        24.9         22.2        TRUE         TRUE              TRUE\n#&gt;     2:        16.0         15.0        TRUE         TRUE              TRUE\n#&gt;     3:        15.2         14.0        TRUE         TRUE              TRUE\n#&gt;     4:        13.4         11.3        TRUE         TRUE              TRUE\n#&gt;     5:        15.1         11.5        TRUE         TRUE              TRUE\n#&gt;    ---                                                                    \n#&gt; 66543:        16.0         13.4        TRUE         TRUE              TRUE\n#&gt; 66544:        13.3         10.8        TRUE         TRUE              TRUE\n#&gt; 66545:        11.6          9.1        TRUE         TRUE              TRUE\n#&gt; 66546:        10.8          8.1        TRUE         TRUE              TRUE\n#&gt; 66547:        10.7          7.8        TRUE         TRUE              TRUE\n#&gt;        validato_cor_PM2,5 certificato_PM10 certificato_PM2,5\n#&gt;                    &lt;lgcl&gt;           &lt;lgcl&gt;            &lt;lgcl&gt;\n#&gt;     1:               TRUE               NA                NA\n#&gt;     2:               TRUE               NA                NA\n#&gt;     3:               TRUE               NA                NA\n#&gt;     4:               TRUE               NA                NA\n#&gt;     5:               TRUE               NA                NA\n#&gt;    ---                                                      \n#&gt; 66543:               TRUE               NA                NA\n#&gt; 66544:               TRUE               NA                NA\n#&gt; 66545:               TRUE               NA                NA\n#&gt; 66546:               TRUE               NA                NA\n#&gt; 66547:               TRUE               NA                NA",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Cambiare la forma dei dati</span>"
    ]
  },
  {
    "objectID": "join.html",
    "href": "join.html",
    "title": "7  Unire diverse fonti di dati",
    "section": "",
    "text": "7.1 Tipologie di unioni\nIn questo capitolo si integreranno informazioni da tabelle diverse combinando due dataset con colonne chiave comuni. Si utilizzeranno alcune tra le diverse tipologie di join del pacchetto data.table, gestendo casi di chiavi mancanti o non corrispondenti.\nQuando si lavora con i dati, capita spesso di dover combinare due insiemi di dati basandosi su una o più colonne chiave comuni. Questo processo si chiama join o merge ed è essenziale per integrare informazioni provenienti da fonti diverse.\nSi prendano come esempio due data.table:\nPer collegare queste due tabelle serve una colonna in comune, che nel nostro caso è il codice del campione:\nlibrary(data.table)\n\nmisure &lt;- data.table(\n  codice = c(\"22201/24\", \"22248/24\", \"22311/24\", \"22312/24\"),\n  data_campionamento = as.IDate(c(\"2024-01-15\", \"2024-02-20\", \"2024-03-10\", \"2024-03-10\")),\n  cadmio = c(0.05, 0.06, 0.04, 0.06),\n  piombo = c(0.1, 0.15, 0.12, 0.11),\n  arsenico = c(0.08, 0.09, 0.05, NA)\n    )\n\nindirizzi &lt;- data.table(\n  codice = c(\"22311/24\", \"22248/24\", \"22412/24\"),\n  comune = c(\"Paperopoli\", \"Topolinia\", \"Topolinia\"),\n  provincia = c(\"SV\", \"IM\", \"IM\"),\n  via = c(\"corso Papero\", \"via de Topis\", \"via Ratti\"),\n  civico = c(\"12\", \"11/10\", \"8R\")\n)\nSi nota che:\nPrima di unire le tabelle, è importante decidere come gestire i dati senza corrispondenza: questa scelta determina il tipo di join da utilizzare.",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Unire diverse fonti di dati</span>"
    ]
  },
  {
    "objectID": "join.html#tipologie-di-unioni",
    "href": "join.html#tipologie-di-unioni",
    "title": "7  Unire diverse fonti di dati",
    "section": "",
    "text": "misure contiene i risultati analitici di una serie di campioni;\nindirizzi: contiene le informazioni relative ai punti di prelievo.\n\n\n\n\n\nnon tutti i codici di misure sono presenti in indirizzi;\nnon tutti i codici di indirizzi compaiono in misure.\n\n\n\n7.1.1 Inner join\nSe si vogliono mantenere solo i campioni per cui sono disponibili sia le misure che l’indirizzo, si usa un inner join. In termini di insiemi, corrisponde alliintersezione \\(A \\cap B\\), come mostrato in Figura 7.1.\n\n\n\n\n\n\nFigura 7.1: Inner join (\\(A \\cap B\\)): vengono restituite solo le righe di A che compaiono anche in B.\n\n\n\nCon data.table la sintassi è:\n\nmisure[indirizzi, # le tabelle\n       on = \"codice\", # la colonna chiave\n       nomatch = NULL] # assegno NULL ai record senza corrispondenza\n#&gt;      codice data_campionamento cadmio piombo arsenico     comune provincia\n#&gt;      &lt;char&gt;             &lt;IDat&gt;  &lt;num&gt;  &lt;num&gt;    &lt;num&gt;     &lt;char&gt;    &lt;char&gt;\n#&gt; 1: 22311/24         2024-03-10   0.04   0.12     0.05 Paperopoli        SV\n#&gt; 2: 22248/24         2024-02-20   0.06   0.15     0.09  Topolinia        IM\n#&gt;             via civico\n#&gt;          &lt;char&gt; &lt;char&gt;\n#&gt; 1: corso Papero     12\n#&gt; 2: via de Topis  11/10\n\nSe le colonne chiave hanno nomi diversi, è possibile specificare on come coppia di nomi, ad esempio on = .(codice_misure = codice_indirizzi). È possibile anche effettuare unioni su più colonne.\n\n\n7.1.2 Right e left join\nVolendo mantenere tutti i campioni con indirizzo, aggiungendo le misure quando disponibili, si usa un right join. In termini insiemistici \\(B\\cup(A\\cap B)\\) dove \\(B\\) sono gli indirizzi e \\(A\\) le misure, come mostrato in Figura 7.2.\n\n\n\n\n\n\nFigura 7.2: Right join (\\(B \\cup (A \\cap B)\\)): vengono restituite tutte le righe di B, completate con le informazioni contenute in A, quando disponibili.\n\n\n\nEcco la sintassi:\n\nmisure[indirizzi, # le tabelle\n       on = \"codice\", # la colonna chiave\n       nomatch = NA] # assegno NA ai record senza corrispondenza\n#&gt;      codice data_campionamento cadmio piombo arsenico     comune provincia\n#&gt;      &lt;char&gt;             &lt;IDat&gt;  &lt;num&gt;  &lt;num&gt;    &lt;num&gt;     &lt;char&gt;    &lt;char&gt;\n#&gt; 1: 22311/24         2024-03-10   0.04   0.12     0.05 Paperopoli        SV\n#&gt; 2: 22248/24         2024-02-20   0.06   0.15     0.09  Topolinia        IM\n#&gt; 3: 22412/24               &lt;NA&gt;     NA     NA       NA  Topolinia        IM\n#&gt;             via civico\n#&gt;          &lt;char&gt; &lt;char&gt;\n#&gt; 1: corso Papero     12\n#&gt; 2: via de Topis  11/10\n#&gt; 3:    via Ratti     8R\n\nÈ bene ricordare che nella sintassi x[i] di data.table:\n\ntutte le righe di i (indirizzi nell’esempio) sono mantenute;\nle colonne di x (misure nell’esempio) sono aggiunte solo se c’è corrispondenza, altrimenti sono NA.\n\nPer un left join (tutte le misure, con indirizzo se disponibile), basta invertire le tabelle:\n\nindirizzi[misure, # le tabelle\n       on = \"codice\", # la colonna chiave\n       nomatch = NA] # assegno NA ai record senza corrispondenza\n#&gt;      codice     comune provincia          via civico data_campionamento cadmio\n#&gt;      &lt;char&gt;     &lt;char&gt;    &lt;char&gt;       &lt;char&gt; &lt;char&gt;             &lt;IDat&gt;  &lt;num&gt;\n#&gt; 1: 22201/24       &lt;NA&gt;      &lt;NA&gt;         &lt;NA&gt;   &lt;NA&gt;         2024-01-15   0.05\n#&gt; 2: 22248/24  Topolinia        IM via de Topis  11/10         2024-02-20   0.06\n#&gt; 3: 22311/24 Paperopoli        SV corso Papero     12         2024-03-10   0.04\n#&gt; 4: 22312/24       &lt;NA&gt;      &lt;NA&gt;         &lt;NA&gt;   &lt;NA&gt;         2024-03-10   0.06\n#&gt;    piombo arsenico\n#&gt;     &lt;num&gt;    &lt;num&gt;\n#&gt; 1:   0.10     0.08\n#&gt; 2:   0.15     0.09\n#&gt; 3:   0.12     0.05\n#&gt; 4:   0.11       NA\n\n\n\n\n\n\n\nPer i più frettolosi\n\n\n\nIl valore predefinito dell’argomento nomatch è NA: è possibile quindi ometterlo per right e left join.\n\n\n\n\n7.1.3 Full join\nSe si vuole mantenere tutti i dati di entrambe le tabelle, mettendoli in relazione quando possibile e inserendo NA in assenza di corrispondenza, si usa un full join. In termini di insiemi, è l’unione \\(A \\cup B\\) , come mostrato in Figura 7.3.\n\n\n\n\n\n\nFigura 7.3: Full join (\\(A \\cup B\\)): vengono restituite tutte le righe di A e B, in caso di mancanza di corrispondenza tra i valori si utilizzano NA.\n\n\n\nLa sintassi prevede la funzione merge():\n\nmerge(misure, indirizzi, by = \"codice\", all = TRUE)\n#&gt; Key: &lt;codice&gt;\n#&gt;      codice data_campionamento cadmio piombo arsenico     comune provincia\n#&gt;      &lt;char&gt;             &lt;IDat&gt;  &lt;num&gt;  &lt;num&gt;    &lt;num&gt;     &lt;char&gt;    &lt;char&gt;\n#&gt; 1: 22201/24         2024-01-15   0.05   0.10     0.08       &lt;NA&gt;      &lt;NA&gt;\n#&gt; 2: 22248/24         2024-02-20   0.06   0.15     0.09  Topolinia        IM\n#&gt; 3: 22311/24         2024-03-10   0.04   0.12     0.05 Paperopoli        SV\n#&gt; 4: 22312/24         2024-03-10   0.06   0.11       NA       &lt;NA&gt;      &lt;NA&gt;\n#&gt; 5: 22412/24               &lt;NA&gt;     NA     NA       NA  Topolinia        IM\n#&gt;             via civico\n#&gt;          &lt;char&gt; &lt;char&gt;\n#&gt; 1:         &lt;NA&gt;   &lt;NA&gt;\n#&gt; 2: via de Topis  11/10\n#&gt; 3: corso Papero     12\n#&gt; 4:         &lt;NA&gt;   &lt;NA&gt;\n#&gt; 5:    via Ratti     8R\n\nSe le colonne chiave hanno nomi diversi, si specificano by.x e by.y. Entrambi possono essere vettori con più di un elemento, per effettuare unioni su più colonne.\n\n\n\n\n\n\nPer i più golosi\n\n\n\nCon il comando vignette(\"datatable-joins\") è possible avere informazioni aggiuntive sull’unione di serie di dati con il pacchetto data.table.\n\n\n\nEsercizioSoluzione\n\n\nUnire i dataset pm_genova e stazioni creati nel Capitolo 5:\n\nqual è la chiave che mette in relazione i due dataset?\nquale tipo di join usare per mantenere solo le misure associate a stazioni e viceversa?\neseguire il join e salvare il risultato in pm_genova_completo;\ncontrollare la tipologia delle colonne di pm_genova_completo e correggerle se necessarie;\nverificare quali stazioni e righe sono state perse passando da pm_genova a pm_genova_completo.\n\n\n\n\nLa chiave è il codice univoco della stazione: codice_europeo in pm_genova e station_eu_code in stazioni;\nserve un inner join (\\(A \\cap B\\));\necco il codice:\n\npm_genova_completo &lt;- pm_genova[stazioni,\n                          # la lista identifica le colonne in relazione\n                          # in data.table .() equivale a list()\n                          on = .(codice_europeo = station_eu_code),\n                          nomatch = NULL]\n\ncon str(pm_genova_completo) si nota che tipo_zona e tipo_stazione sono character invece che factor. Si corregge così:\n\npm_genova_completo[, `:=` (\n  tipo_zona = factor(tipo_zona),\n  tipo_stazione = factor(tipo_stazione)\n)]\n\nper identificare stazioni e righe perse:\n\npm_genova[codice_europeo %notin% pm_genova_completo[, codice_europeo],\n          unique(codice_europeo)]\n#&gt; [1] \"IT2339A\" \"IT2327A\" \"\"\n\npm_genova[codice_europeo %notin% pm_genova_completo[, codice_europeo],\n          .N]\n#&gt; [1] 46698\n\nSi è perso circa il 38% dei dati, probabilmente per codifiche errate o mancanti.",
    "crumbs": [
      "Lavorare con i dati",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Unire diverse fonti di dati</span>"
    ]
  },
  {
    "objectID": "reports.html",
    "href": "reports.html",
    "title": "Visualizzazione e reportistica",
    "section": "",
    "text": "Questa parte del corso è dedicata agli strumenti e alle tecniche per rappresentare i dati in modo chiaro, e per creare report dinamici e personalizzati che facilitano la riproducibilità delle analisi, la comunicazione e la condivisione dei risultati.\nQuesta parte è suddivisa in tre capitoli così organizzati:\n\nnel capitolo 8 si costruiranno grafici personalizzati e informativi con il pacchetto ggplot2;\nnel capitolo 9 si utilizzerà Quarto per creare documenti dinamici che integrano testo, codice e output, generando report riproducibili;\nnel capitolo 10 saranno realizzati report parametrizzati in Quarto, definendo parametri per generare contenuti dinamici e automatizzare la produzione di report multipli.\n\nQuesti argomenti forniranno le competenze per comunicare efficacemente i risultati delle proprie analisi e per automatizzare la creazione di documenti.",
    "crumbs": [
      "Visualizzazione e reportistica"
    ]
  },
  {
    "objectID": "ggplot2.html",
    "href": "ggplot2.html",
    "title": "8  Visualizzare i dati con ggplot2",
    "section": "",
    "text": "8.1 Sintassi di base di ggplot2\nLa visualizzazione dei dati è una fase fondamentale nell’analisi statistica: un grafico chiaro facilita l’interpretazione e la comunicazione dei risultati.\nIn questo capitolo si creeranno grafici professionali e personalizzati con il pacchetto ggplot2, basato sulla grammar of graphics. Combinando e sovrapponendo più livelli grafici sarà possibile arricchire le visualizzazioni, personalizzare assi, colori, legende e temi.\nUn grafico con ggplot2 si costruisce combinando tre elementi principali:\nEcco un esempio per la creazione di un semplice grafico di dispersione a partire da un dataset sintetico:\n# dataset sintetico\nlibrary(data.table)\n\nn &lt;- 50\nvalori &lt;- rnorm(n, mean = 0.100, sd = 0.010)\n\nmisure &lt;- data.table(\n  codice = paste0(sample(1:40000, n), \"/24\"),\n  data_campionamento = sample(seq(as.IDate('2024-01-01'),\n                                  as.IDate('2024-12-31'),\n                                  by = \"day\"), \n                              n, replace = TRUE),\n  matrice = sample(c(\"Acque superficiali\", \"Acque sotterranee\", \"Acque destinate al consumo umano\"),\n                   n, replace = TRUE) |&gt; factor(),\n  piombo = valori,\n  arsenico = valori - rnorm(n, mean = 0.020, sd = 0.003)\n    )\n\n# grafico di dispersione\nlibrary(ggplot2)\n\nmisure |&gt;                           # dataset\n  ggplot(aes(x = piombo,            # piombo sull'asse delle x\n             y = arsenico)) +       # arsenico sull'asse delle y\n  geom_point()                      # grafico di dispersione\n\n\n\n\n\n\n\nFigura 8.1: un semplice grafico di dispersione.",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Visualizzare i dati con `ggplot2`</span>"
    ]
  },
  {
    "objectID": "ggplot2.html#sintassi-di-base-di-ggplot2",
    "href": "ggplot2.html#sintassi-di-base-di-ggplot2",
    "title": "8  Visualizzare i dati con ggplot2",
    "section": "",
    "text": "dataset: il data.frame o la data.table con i dati da visualizzare;\nestetiche (aes): la mappatura delle variabili del dataset alle proprietà visive del grafico (assi, colore, forma, dimensione);\ngeometria (geom_): il tipo di oggetto grafico da disegnare (punti, linee, barre, ecc.).\n\n\n\n\n8.1.1 Aggiungere livelli al grafico\nggplot2 permette di sovrapporre più livelli per arricchire il grafico con elementi aggiuntivi come linee di tendenza, etichette, pannelli, titoli e annotazioni.\nOgni livello si aggiunge con l’operatore +.\n\n# grafico\nmisure |&gt;                           # dataset\n  ggplot(aes(x = piombo,            # piombo sull'asse delle x\n             y = arsenico)) +       # arsenico sull'asse delle y\n  geom_point() +                    # grafico di dispersione\n  geom_smooth(method = \"lm\",        # linea di tendenza con metodo OLS\n              linewidth = 1,\n              col = \"red\") +      \n  facet_wrap(vars(matrice)) +       # pannelli distinti per matrice\n  labs(                             # personalizzazione degli assi\n    title = \"Relazione tra piombo e arsenico nei campioni di acqua del 2024\",\n    x = \"Piombo (µg/l)\",\n    y = \"Arsenico (µg/l)\"\n  ) +\n  theme_bw()                        # scelgo lo stile\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\nFigura 8.2: un grafico di dispersione suddiviso su più panelli e con una retta di regressione basata sul metodo OLS.\n\n\n\n\n\nI livelli di tipo geom_ aggiungono tipologie di grafici e i più comuni sono:\n\ngeom_point() per grafici a dispersione;\ngeom_line() per grafici a linee;\ngeom_boxplot() per boxplot;\ngeom_hline() per linee orizzontali;\ngeom_vline() per linee verticali;\ngeom_bar() o geom_col() per grafici a barre;\ngeom_histogram() per istogrammi;\ngeom_density() per funzioni di densità.\n\nI livelli di tipo scale_ si utilizzano dopo i livelli geom_ per modificare le proprietà degli assi e delle scale cromatiche. Le funzioni più comuni sono:\n\nscale_x_continuous(), scale_y_continuous(): per assi numerici;\nscale_x_date(), scale_y_date(): per assi temporali;\nscale_color_manual(), scale_fill_manual(): per colori personalizzati;\nscale_size_continuous(), scale_shape_manual(): per dimensioni e forme.\n\nIl livello theme() è usato per personalizzare l’aspetto generale del grafico, in particolare viene usato spesso per gestire la posizione e lo stile della legenda. Deve essere utilizzato dopo i livelli geom_ e scale_ ma prima dei comandi per la scelta dello stile del grafico, come theme_bw().\nIn questo esempio si personalizza l’asse temporale e l’aspetto della legenda:\n\nmisure |&gt;\n  ggplot(aes(\n    x = data_campionamento,\n    y = piombo,\n    col = matrice\n  )) +\n  geom_point() +\n  geom_hline(yintercept = 0.12,\n             col = \"red\",\n             size = 1,\n             linetype = \"dashed\") +\n  scale_x_date(date_breaks = \"1 month\",          # una linea di graduazione ogni mese\n               date_labels = \"%d %b %Y\",         # formato tipo 5 mag 2025\n               guide = guide_axis(angle = 90)) + # ruoto le etichette\n  scale_color_manual(values = c(\"#E69F00\",       # imposto manualmente i colori\n                                \"#56B4E9\",\n                                \"#009E73\")) +\n  labs(\n    x = element_blank(),                         # tolgo il nome dell'asse x\n    y = \"Piombo (µg/l)\",\n    col = element_blank()                        # tolgo il titolo della legenda\n  ) +\n  theme_bw() +\n  theme(legend.position = \"top\",                 # metto la legenda in alto\n        legend.justification = \"left\",           # giustificata a sinistra\n        legend.direction = \"vertical\")           # orientata verticalmente\n#&gt; Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#&gt; ℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\nFigura 8.3: un grafico che mostra le concentrazioni di piombo misurate al variare del tempo in diverse tipologie di acque.\n\n\n\n\n\n\nEsercizioSoluzione\n\n\nUtilizzando il dataset pm_genova importato e modificato rispettivamente nei Capitoli 5 e 7, rappresentare la distribuzione dei valori medi giornalieri di PM10 per i diversi comuni. Raffrontare visivamente i valori medi giornalieri con il limite di \\(50\\, \\mu g/m^3\\).\n\n\n\nlibrary(data.table)\nlibrary(ggplot2)\n\npm_genova[inquinante == \"PM10\",\n          .(pm10 = mean(valore, na.rm = TRUE)),\n          by = .(comune,\n                 giorno = yday(inizio))] |&gt;\n  ggplot(aes(\n    x = comune,\n    y = pm10\n  )) +\n  geom_boxplot() +\n  geom_hline(yintercept = 50,\n             size = 1,\n             col = \"red\",\n             linetype = \"dashed\") +\n  labs(\n    x = element_blank(),\n    y = expression(\"Concentrazione media giornaliera di \" * PM[10] * ~  (mu * g / m^{3}))\n  ) +\n  theme_bw()\n  \n\n\n\n\n\n\n\nFigura 8.4: boxplot dei valori medi giornalieri di PM10 misurati nel 2024 per i comuni monitorati nella provincia di Genova.",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Visualizzare i dati con `ggplot2`</span>"
    ]
  },
  {
    "objectID": "quarto.html",
    "href": "quarto.html",
    "title": "9  Report riproducibili",
    "section": "",
    "text": "9.1 I documenti Quarto\nIn questo capitolo si utilizzerà Quarto, uno strumento potente per creare documenti dinamici e professionali con R, arrivando a integrare codice, testo e output in un unico file per produrre report chiari e personalizzati. All’interno dei report si inseriranno tabelle e grafici in modo efficace, migliorando la comunicazione e la riproducibilità dei risultati delle proprie analisi.\nA partire dal Capitolo 2 si è organizzato il codice in R utilizzando script e aggiungendo commenti per chiarire le parti più complesse. Tuttavia, in progetti di analisi dati complessi, è necessario integrare anche documentazione testuale per collegare il codice ai risultati. In questi casi, Quarto si rivela uno strumento utile.\nQuarto è una piattaforma open source che permette di creare documenti dinamici e riproducibili combinando testo, codice e risultati in un unico file .qmd. Supporta linguaggi come R, Python e Julia, e consente di generare output in vari formati (HTML, PDF, Word).\nQuarto permette di aggiornare automaticamente i risultati a ogni cambiamento di codice o dati, garantendo coerenza e riducendo il rischio di errori. Inoltre, supportando più linguaggi di programmazione, facilita lavori collaborativi, evitando di doversi preoccupare di conoscere tutti lo stesso codice. La sua natura riproducibile assicura trasparenza e tracciabilità, aspetti essenziali per l’affidabilità dei risultati.\nCreare un documento quarto da RStudio è semplice:\nQui si specifica il titolo, l’autore e il formato di output del documento. Sempre nell’intestazione è possibile aggiungere altri elementi, come ad esempio lang: it per specificare che il documento è redatto in italiano.\nOra si può iniziare a scrivere il primo documento alternando testo e codice.",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Report riproducibili</span>"
    ]
  },
  {
    "objectID": "quarto.html#sec-quarto",
    "href": "quarto.html#sec-quarto",
    "title": "9  Report riproducibili",
    "section": "",
    "text": "si segue File &gt; New File &gt; Quarto Document;\nsi inserisce il titolo e l’autore nel pannello di creazione;\nsi sceglie il formato di output (default HTML, ma puoi selezionare PDF, Word, ecc.);\nviene creato un file .qmd con un’intestazione YAML simile a:\n\n---\ntitle: \"Titolo del documento\"\nauthor: \"Nome Autore\"\nformat: html\n---\n\n\n\n9.1.1 Il testo\nAll’interno di un documento di quarto il testo è inserito semplicemente scrivendo al di sotto dell’intestazione e utilizzando la tipica sintassi markdown, ormai sempre più diffusa. Ecco un esempio:\n\n---\ntitle: \"Il mio primo documento con Quarto\"\nauthor: \"Proprio io\"\nformat: html\nlang: it\n---\n    \n# Questo è un titolo di livello uno {#sec-riferimento}\n\nOra scrivo semplicemente del testo poi metto una parola in *corsivo* e una in **neretto**.\n\n## Questo un sottotitolo di livello due\n\nQui faccio vedere che so organizzare le idee facendo un elenco puntato:\n\n- carote;\n- patate;\n- cipolle.\n\nFaccio anche un elenco numerato:\n\n1. arrivò il toro;\n2. che bevvé l'acqua;\n3. che spense il fuoco;\n4. che bruciò il bastone;\n5. che picchiò il cane;\n6. che morse il gatto;\n7. che mangiò il topo;\n8. che al mercato mio padre comprò.\n\n### Questo è un elenco di terzo livello\n\nPosso esagerare con un'equazione in linea $c^2 = \\sqrt{a^2 + b^2}$ o una fuori corpo:\n\n$$\ni \\hbar \\frac{\\partial \\Psi}{\\partial t} (\\mathbf{r}, t) = \\hat{H} \\Psi (\\mathbf{r}, t) \n$$\n\nE così finisce la @sec-riferimento.\nPer vedere il risultato, si può cliccare il tasto .\n\n\n9.1.2 Il codice\nPer inserire del codice all’interno del documento è sufficiente schiacciare i tasti Ctrl + Alt + I: lo spezzone (chunk) di codice inizierà con ```{r} e terminerà con ``` e al suo interno è possibile inserire del normale codice di R:\n```{r}\nsummary(mtcars)\n```\nÈ consigliabile associare a ogni spezzone di codice un’etichetta univoca che descriva brevemente cosa fa il codice e questo lo si può fare specificando l’opzione label, come di seguito:\n```{r}\n#| label: summary-mtcars\nsummary(mtcars)\n```\nIl campo label non ammette spazi e l’unico carattere speciale ammesso è -. Nel caso di spezzoni di codice che generano grafici o tabelle, è buona norma impostare l’etichetta rispettivamente come #| label: fig-qualcosa e #| label: tbl-qualcosa: così facendo si potrà fare riferimento nel testo alla figura e alla tabella scrivendo rispettivamente @fig-qualcosa o @tbl-qualcosa.\nOltre a label è possibile specificare altre opzioni che regolano la visibilità e il comportamento del codice. Tra le più usate ci sono:\n\necho: regola la visibilità del codice all’interno dello spezzone. Il valore predefinito è TRUE e comporta la visibilità nel documento finale sia del codice presente all’interno dello spezzone, sia del suo risultato. Impostando FALSE si vede solo il risultato del codice.\nmessage o warning: impostandoli su FALSE si evita l’inclusione di messaggio o avvisi all’interno del documento finale.\nfig-cap e tbl-cap: imposta la didascalia di figure e tabelle e accetta una stringa di testo tra virgolette.\n\nTutte le opzioni vanno specificate all’inizio dello spezzone e facendole precedere da #|.\nÈ anche possibile specificare piccole porzioni di codice il cui risultato verrà visualizzato in linea con il testo. Ecco un esempio:\nscrivendo\n\nil dataset mtcars contiene i dati di `r nrow(mtcars)` modelli di automobili, ciascuno classificato sulla base di `r ncol(mtcars)` variabili.\n\nviene visualizzato\n\nil dataset mtcars contiene i dati di 32 modelli di automobili, ciascuno classificato sulla base di 11 variabili.\n\n\n\n9.1.3 Le tabelle\nAll’interno di documenti Quarto è possibile visualizzare dataset come tabelle opportunamente formattate utilizzando il pacchetto gt. Tale pacchetto permette di personalizzare nel dettaglio la visualizzazione delle tabelle, impostando i nomi delle colonne, le colonne da unire e la formattazione dei valori numerici. Ecco un semplice esempio riadattato dalla documentazione ufficiale di gt:\n\nlibrary(gt)\n\nairquality |&gt;\n  head(20) |&gt;\n  gt() |&gt;\n  fmt_number(Wind, n_sigfig = 2) |&gt;                 # 2 cifre significative\n  cols_label(                                       # nomi delle colonne\n    Ozone = html(\"Ozono,&lt;br&gt;({{ppbV}})\"),\n    Solar.R = html(\"Solar R.,&lt;br&gt;({{cal/m^2}})\"),\n    Wind = html(\"Vento,&lt;br&gt;({{mph}})\"),\n    Temp = html(\"Temp,&lt;br&gt;({{degF}})\"),\n    Month = \"Mese\",\n    Day = \"Giorno\"\n  ) |&gt;                                              # sovra intestazione\n  tab_spanner(\n    label = \"Tempo\",\n    columns = c(Month, Day)\n  ) |&gt;\n  tab_spanner(\n    label = \"Misure\",\n    columns = c(Ozone, Solar.R, Wind, Temp)\n  )\n\n\n\nTabella 9.1: gt fa delle tabelle che spaccano.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMisure\n\n\nTempo\n\n\n\nOzono,\n(ppbV)\nSolar R.,\n(cal/m2)\nVento,\n(mph)\nTemp,\n(°F)\nMese\nGiorno\n\n\n\n\n41\n190\n7.4\n67\n5\n1\n\n\n36\n118\n8.0\n72\n5\n2\n\n\n12\n149\n13\n74\n5\n3\n\n\n18\n313\n12\n62\n5\n4\n\n\nNA\nNA\n14\n56\n5\n5\n\n\n28\nNA\n15\n66\n5\n6\n\n\n23\n299\n8.6\n65\n5\n7\n\n\n19\n99\n14\n59\n5\n8\n\n\n8\n19\n20\n61\n5\n9\n\n\nNA\n194\n8.6\n69\n5\n10\n\n\n7\nNA\n6.9\n74\n5\n11\n\n\n16\n256\n9.7\n69\n5\n12\n\n\n11\n290\n9.2\n66\n5\n13\n\n\n14\n274\n11\n68\n5\n14\n\n\n18\n65\n13\n58\n5\n15\n\n\n14\n334\n12\n64\n5\n16\n\n\n34\n307\n12\n66\n5\n17\n\n\n6\n78\n18\n57\n5\n18\n\n\n30\n322\n12\n68\n5\n19\n\n\n11\n44\n9.7\n62\n5\n20\n\n\n\n\n\n\n\n\n\n\n\n\n9.1.4 Unire i puntini\nNelle sezioni precedenti sono stati forniti tutti gli elementi per creare un documento di esempio. Per rendersi la vita più semplice, è possibile specificare nell’intestazione echo, warning e message come FALSE, così non si vedrà il codice senza doverlo ripetere all’interno di ogni spezzone.\n---\ntitle: \"Analisi importanti\"\nauthor: \"Pico de Paperis, Ph.D.\"\nlang: it\nformat: html\nexecute:\n  echo: false\n  message: false\n  warning: false\n---\n\n# Introduzione\n\nLe analisi del piombo, cadmio e arsenico sono di vitale importanza: \nfortuna che ci sono io che le faccio!\nSentendomi particolarmente generoso condivido con voi i risultati \ntrovati in alcuni campioni selezionati.\n\n# Metodo\n\n1. Ho acceso il computer;\n2. ho preso i campioni;\n3. li ho messi nello strumento;\n4. ho letto i numeri;\n5. ho calcolato $\\pi r^2$;\n6. ho trascritto i numeri;\n7. **applausi**.\n\n# Risultati {#sec-risultati}\n\nIn @tbl-misure trovate i miei risultati e in @fig-pbas c'è pure un bel grafico.\n\n```{r}\n#| label: carico-dati\nlibrary(data.table)\n\nmisure &lt;- data.table(\n  codice = c(\"22201/24\", \"22248/24\", \"22311/24\", \"22312/24\"),\n  data_campionamento = c(\"2024-01-15\", \"2024-02-20\", \"2024-03-10\", \"2024-03-10\") |&gt;\n    as.IDate(),\n  cadmio = c(0.05, 0.06, 0.04, 0.06),\n  piombo = c(0.1, 0.15, 0.12, 0.11),\n  arsenico = c(0.08, 0.09, 0.05, NA)\n    )\n```\n\n```{r}\n#| label: tbl-misure\n#| tbl-cap: \"La tabella con i risultati.\"\nlibrary(gt)\n\nmisure |&gt;\n  gt() |&gt;\n  fmt_number(\n    c(cadmio, piombo, arsenico),\n    n_sigfig = 2) |&gt;\n  cols_label(\n    codice = \"Codice campione\",\n    data_campionamento = \"Data di campionamento\",\n    cadmio = \"Cd\",\n    piombo = \"Pb\",\n    arsenico = \"As\"\n  ) |&gt;\n  tab_spanner(\n    label = \"Metalli (µg/l)\",\n    columns = c(cadmio, piombo, arsenico)\n  )\n```\n\n\n```{r}\n#| label: fig-pbas\n#| fig-cap: \"Grafico di dispersione della concentrazione di piombo e arsenico.\"\nlibrary(ggplot2)\n\nmisure |&gt;                          \n  ggplot(aes(x = piombo,            \n             y = arsenico)) +      \n  geom_point() +                    \n  geom_hline(yintercept = 0.07,\n              col = \"red\",\n              linetype = \"dashed\") +\n  labs(                             \n    title = \"Relazione tra piombo e arsenico nei campioni di acqua del 2024\",\n    x = \"Piombo (µg/l)\",\n    y = \"Arsenico (µg/l)\"\n  ) +\n  theme_bw()   \n```\n\n# Conclusioni\n\nCome mostrato nella @sec-risultati, sono proprio bravo.\n\n\n\n\n\n\nPer i più golosi\n\n\n\nAll’indirizzo quarto.org è possibile consultare la documentazione ufficiale.\n\n\n\nEsercizioSoluzione\n\n\nIncludere le modifiche eseguite sul dataset pm_genova e simulare un report in un documento di quarto.\n\n\n---\ntitle: \"Particolato atmosferico campionato nella provincia di Genova nel 2024\"\nauthor: \"Nome, Cognome\"\nlang: it\nformat: html\nexecute:\n  echo: false\n  message: false\n  warning: false\n---\n\n# Introduzione\n\nIl decreto legislativo 155/2010 attua la direttiva 2008/50/CE \nrelativa alla qualità dell'aria ambiente e per un'aria più pulita\nin Europa e prevede il monitoraggio delle concentrazioni in aria\ndi diverse specie. Tra queste figura il particolato atmosferico\ncon diametro aerodinamico inferiore a 10 μm (PM~10~) e 2,5 μm (PM~2,5~).\n\nARPAL gestisce la rete regionale ligure di rilevamento della qualità\ndell'aria e in questo report sono riassunti i valori di concentrazione\ndi PM~10~ e PM~2,5~ misurati nel 2024 presso i comuni monitorati\ndalle stazioni di monitoraggio collocate nella provincia di Genova.\n\n# Metodo\n\nDal sito [Ambiente in Liguria](https://www.banchedati.ambienteinliguria.it/)\nsono stati scaricati in formato .csv i dati relativi al PM~10~ e PM~2,5~ \nmisurati nel 2024 presso le stazioni di monitoraggio collocate\nnella provincia di Genova.\nA scopo didattico sono state rimosse le informazioni relative alle stazioni\ndi monitoraggio, lasciando il solo codice europeo della stazione.\nIl file risultante è stato quindi compresso in formato .gz.\n\n```{r}\n#| label: carico-dati-aria\nlibrary(data.table)\n\npm_genova &lt;- fread(\"data/2025-04-24_pm1025_ambiente_liguria.csv.gz\",\n                   skip = \"Codice europeo\",\n                   encoding = \"Latin-1\")   \n```\n\n```{r}\n#| label: cleaning-dati-aria\n\ncolnames(pm_genova) &lt;- colnames(pm_genova) |&gt; \n  tolower() |&gt;                  # trasforma in minuscolo\n  gsub(\" \", \"_\", x = _) |&gt;      # sostituisce gli spazi con uderscore\n  iconv(to = \"ASCII//TRANSLIT\") # rimuove accenti e caratteri speciali  \n\npm_genova[, valido := fcase(valido == \"SI\", TRUE,\n                            valido == \"NO\", FALSE,\n                            default = NA)]\n                            \npm_genova[, `:=` (\n  # standardizza le unità\n  udm = gsub(\"microg/m3\", \"µg/m³\", unita_di_misura),\n  # converte validato cor e certificato in valori logici\n  validato_cor = fcase(validato_cor == \"SI\", TRUE,\n                       validato_cor == \"NO\", FALSE,\n                       default = NA),\n  certificato = fcase(certificato == \"SI\", TRUE,\n                      certificato == \"NO\", FALSE,\n                      default = NA),\n  # converte le date specificando il formato di input\n  inizio = as.POSIXct(data_inizio, format = \"%d/%m/%Y %H:%M\", tz = \"GMT\"),\n  fine = as.POSIXct(data_fine, format = \"%d/%m/%Y %H:%M\", tz = \"GMT\"),\n  # elimina le vecchie colonne non più utili\n  unita_di_misura = NULL,\n  data_inizio = NULL,\n  data_fine = NULL\n)]\n\n```\n\nI dati relativi alle stazioni di monitoraggio italiane è stato scaricato\ndalla sezione [Dati e indicatori - Aria del sito dell'istituto superiore\nper la protezione e la ricerca ambientale\n(ISPRA)](https://www.isprambiente.gov.it/it/banche-dati/).\n\n```{r}\n#| label: carico-dati-stazioni\nlibrary(readxl)\n\nstazioni &lt;- read_excel(\"data/2025-04-24_anagrafica_stazioni.xlsx\",\n                       sheet = \"Tabella 1\") |&gt; \n  setDT() \n```\n\n```{r}\n#| label: join-data\n\npm_genova_completo &lt;- pm_genova[stazioni,\n                          # la lista identifica le colonne in relazione\n                          # in data.table .() equivale a list()\n                          on = .(codice_europeo = station_eu_code),\n                          nomatch = NULL]\n                          \npm_genova_completo[, `:=` (\n    tipo_zona = factor(tipo_zona),\n    tipo_stazione = factor(tipo_stazione)\n  )]\n```\n\nLe elaborazioni sono state eseguite con [R](https://www.r-project.org/).\n\n# Risultati {#sec-risultati}\n\nLa @tbl-misure riassume i valori di concentrazione di PM~10~ misurati\npresso le stazioni di monitoraggio della provincia di Genova nel 2024,\nmentre in @fig-misure sono mostrate le concentrazioni medie giornaliere\nraggruppate per comune.\n\n```{r}\n#| label: daily-data\n\npm_genova_daily &lt;- pm_genova_completo[,\n  .(avg = mean(valore, na.rm = TRUE),\n    sd = sd(valore, na.rm = TRUE),\n    min = min(valore, na.rm = TRUE),\n    max = max(valore, na.rm = TRUE),\n    n_valori = (!is.na(valore)) |&gt; length()),\n  by = .(codice_europeo,\n         comune,\n         nome_stazione,\n         giorno = yday(inizio),\n         inquinante)]\n```\n\n```{r}\n#| label: above50-data\n\npm_genova_above50 &lt;- pm_genova_daily[, .(avg = mean(avg, na.rm = TRUE),\n                                         val_50 = (avg &gt; 50) |&gt; sum(na.rm = TRUE)),\n                                      by = .(nome_stazione,\n                                             comune)][order(-val_50)]\n```\n\n```{r}\n#| label: tbl-misure\n#| tbl-cap: \"Concentrazione di PM~10~ in provincia di Genova nel 2024.\"\nlibrary(gt)\n\npm_genova_above50 |&gt;\n  gt() |&gt;\n  cols_label(\n    nome_stazione = \"Stazione\",\n    comune = \"Comune\",\n    avg = md(\"Media PM~10~ ({{:mu:g/m^3}})\"),\n    val_50 = \"n &gt; 50 {{:mu:g/m^3}}\"\n  ) |&gt;\n  fmt_number(\n    columns = avg,\n    decimals = 0\n  ) |&gt;\n  tab_footnote(\n  footnote = \"Media annuale dei valori di concentrazione medi giornalieri.\",\n  locations = cells_column_labels(columns = avg)\n  )\n  \n```\n\n\n```{r}\n#| label: fig-misure\n#| fig-cap: \"Concentrazione di PM~10~ e PM~2,5~ in provincia di Genova nel 2024.\"\nlibrary(ggplot2)\n\npm_genova_daily |&gt;\n  ggplot(\n  aes(x = comune, y = avg)\n  ) +\n  geom_boxplot() +\n  # limite solo per PM10\n  geom_hline(\n    data = pm_genova_daily[inquinante == \"PM10\"],\n    aes(yintercept = 50),\n    col = \"red\",\n    linetype = \"dashed\"\n    ) +\n  facet_wrap(vars(inquinante)) +\n  labs(\n    x = element_blank(),\n    y = expression(\"Concentrazione media giornaliera \" * (mu * g / m^{3}))\n  ) +\n  theme_bw()\n```\n\nLa stazione con più valori di PM~10~ superiori al limite giornaliero\ndi $50\\, \\mu g/m^3$ è \n`r pm_genova_above50[which.max(val_50), nome_stazione]`, nel comune di \n`r pm_genova_above50[which.max(val_50), comune]`, con \n`r pm_genova_above50[which.max(val_50), val_50]` superamenti.",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Report riproducibili</span>"
    ]
  },
  {
    "objectID": "dynamic.html",
    "href": "dynamic.html",
    "title": "10  Report parametrizzati",
    "section": "",
    "text": "10.1 Report parametrizzati\nIn questo capitolo si realizzeranno report personalizzati e flessibili utilizzando i parametri in documenti Quarto. Utilizzando template riutilizzabili si produrranno automaticamente report con script R o da linea di comando, migliorando l’efficienza, l’automazione e la riproducibilità del flusso di lavoro.\nI report parametrizzati in Quarto permettono di creare documenti altamente flessibili, in cui i parametri specificati dall’utente vengono utilizzati per generare contenuti dinamici. Questo è particolarmente utile quando si vuole creare report personalizzati, adattati a diverse condizioni o esigenze, senza dover riscrivere l’intero documento.\nIn Quarto, i parametri sono definiti nell’intestazione YAML del documento e vengono poi utilizzati all’interno del codice e del testo. Questo approccio rende facile la generazione automatica di report con diverse variabili, come per esempio l’analisi di diversi dataset, la modifica dei filtri o dei criteri di calcolo, o la personalizzazione dei contenuti visualizzati.",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Report parametrizzati</span>"
    ]
  },
  {
    "objectID": "dynamic.html#definizione-dei-parametri",
    "href": "dynamic.html#definizione-dei-parametri",
    "title": "10  Report parametrizzati",
    "section": "10.2 Definizione dei parametri",
    "text": "10.2 Definizione dei parametri\nPer definire i parametri in un documento Quarto, basta aggiungere una sezione params nell’intestazione YAML. Ogni parametro viene definito con un nome e un valore predefinito. Ecco un esempio di come configurare un report parametrizzato per analizzare i dati relativi alla qualità dell’aria:\n---\ntitle: \"Report sulla qualità dell'aria\"\nauthor: \"Nome, Cognome\"\nlang: it\nformat: html\nexecute:\n  echo: false\n  message: false\n  warning: false\nparams:\n  comune: \"Genova\"\n---\nIn questo caso si è definito solo un parametro: il nome del comune.",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Report parametrizzati</span>"
    ]
  },
  {
    "objectID": "dynamic.html#utilizzo-dei-parametri",
    "href": "dynamic.html#utilizzo-dei-parametri",
    "title": "10  Report parametrizzati",
    "section": "10.3 Utilizzo dei parametri",
    "text": "10.3 Utilizzo dei parametri\nUna volta definiti, i parametri possono essere utilizzati all’interno del codice o del testo del documento. In Quarto, è possibile fare riferimento ai parametri utilizzando la sintassi params$nome_parametro. Ecco un esempio che mostra come utilizzare questi parametri per caricare i dati e applicare un filtro sui valori di concentrazione:\n```{r}\n#| label: filtro-dati-aria\nlibrary(data.table)\n                  \npm_genova_completo[comune == params$comune]\n```",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Report parametrizzati</span>"
    ]
  },
  {
    "objectID": "dynamic.html#personalizzare-il-report",
    "href": "dynamic.html#personalizzare-il-report",
    "title": "10  Report parametrizzati",
    "section": "10.4 Personalizzare il report",
    "text": "10.4 Personalizzare il report\nUtilizzando i parametri, è possibile modificare dinamicamente anche il testo del report. Ad esempio, si può creare un’introduzione che si adatta ai parametri definiti, come mostrato qui:\n\n# Introduzione\n\nNel presente report vengono analizzati i dati relativi alle concentrazioni di PM~10~ e PM~2,5~ misurate nel comune di `r params$comune`.\nQuando il report viene generato, il testo verrà automaticamente aggiornato per riflettere i valori specificati nei parametri.",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Report parametrizzati</span>"
    ]
  },
  {
    "objectID": "dynamic.html#esempio-completo",
    "href": "dynamic.html#esempio-completo",
    "title": "10  Report parametrizzati",
    "section": "10.5 Esempio completo",
    "text": "10.5 Esempio completo\nEcco come si combinano tutti gli elementi sopra per creare un esempio completo di report parametrizzato in Quarto.\n---\ntitle: \"Report sulla qualità dell'aria\"\nauthor: \"Nome, Cognome\"\nlang: it\nformat: html\nexecute:\n  echo: false\n  message: false\n  warning: false\nparams:\n  comune: \"Genova\"\n---\n\n# Introduzione\n\nNel presente report vengono analizzati i dati relativi alle concentrazioni\ndi PM~10~ e PM~2,5~ misurate nel comune di `r params$comune`.\n\n# Metodo\n\nDal sito [Ambiente in Liguria](https://www.banchedati.ambienteinliguria.it/)\nsono stati scaricati in formato .csv i dati relativi al PM~10~ e PM~2,5~ \nmisurati nel 2024 presso le stazioni di monitoraggio collocate\nnella provincia di Genova.\nA scopo didattico sono state rimosse le informazioni relative alle stazioni\ndi monitoraggio, lasciando il solo codice europeo della stazione.\nIl file risultante è stato quindi compresso in formato .gz.\n\n```{r}\n#| label: carico-dati-aria\nlibrary(data.table)\n\npm_genova &lt;- fread(\"data/2025-04-24_pm1025_ambiente_liguria.csv.gz\",\n                   skip = \"Codice europeo\",\n                   encoding = \"Latin-1\")   \n```\n\n```{r}\n#| label: cleaning-dati-aria\n\ncolnames(pm_genova) &lt;- colnames(pm_genova) |&gt; \n  tolower() |&gt;                  # trasforma in minuscolo\n  gsub(\" \", \"_\", x = _) |&gt;      # sostituisce gli spazi con uderscore\n  iconv(to = \"ASCII//TRANSLIT\") # rimuove accenti e caratteri speciali  \n\npm_genova[, valido := fcase(valido == \"SI\", TRUE,\n                            valido == \"NO\", FALSE,\n                            default = NA)]\n                            \npm_genova[, `:=` (\n  # standardizza le unità\n  udm = gsub(\"microg/m3\", \"µg/m³\", unita_di_misura),\n  # converte validato cor e certificato in valori logici\n  validato_cor = fcase(validato_cor == \"SI\", TRUE,\n                       validato_cor == \"NO\", FALSE,\n                       default = NA),\n  certificato = fcase(certificato == \"SI\", TRUE,\n                      certificato == \"NO\", FALSE,\n                      default = NA),\n  # converte le date specificando il formato di input\n  inizio = as.POSIXct(data_inizio, format = \"%d/%m/%Y %H:%M\", tz = \"GMT\"),\n  fine = as.POSIXct(data_fine, format = \"%d/%m/%Y %H:%M\", tz = \"GMT\"),\n  # elimina le vecchie colonne non più utili\n  unita_di_misura = NULL,\n  data_inizio = NULL,\n  data_fine = NULL\n)]\n\n```\n\nI dati relativi alle stazioni di monitoraggio italiane è stato scaricato\ndalla sezione [Dati e indicatori - Aria del sito dell'istituto superiore\nper la protezione e la ricerca ambientale\n(ISPRA)](https://www.isprambiente.gov.it/it/banche-dati/).\n\n```{r}\n#| label: carico-dati-stazioni\nlibrary(readxl)\n\nstazioni &lt;- read_excel(\"data/2025-04-24_anagrafica_stazioni.xlsx\",\n                       sheet = \"Tabella 1\") |&gt; \n  setDT() \n```\n\n```{r}\n#| label: join-data\n\npm_genova_completo &lt;- pm_genova[stazioni,\n                          # la lista identifica le colonne in relazione\n                          # in data.table .() equivale a list()\n                          on = .(codice_europeo = station_eu_code),\n                          nomatch = NULL]\n                          \npm_genova_completo[, `:=` (\n    tipo_zona = factor(tipo_zona),\n    tipo_stazione = factor(tipo_stazione)\n  )]\n```\n\nLe elaborazioni sono state eseguite con [R](https://www.r-project.org/).\n\n# Risultati {#sec-risultati}\n\nIn @fig-misure sono mostrate le concentrazioni medie di PM~10~ e PM~2,5~\nmisurate nel comune di `r params$comune`.\n\n```{r}\n#| label: daily-data\n\npm_genova_daily &lt;- pm_genova_completo[comune == params$comune,\n  .(avg = mean(valore, na.rm = TRUE),\n    sd = sd(valore, na.rm = TRUE),\n    min = min(valore, na.rm = TRUE),\n    max = max(valore, na.rm = TRUE),\n    n_valori = (!is.na(valore)) |&gt; length()),\n  by = .(codice_europeo,\n         nome_stazione,\n         giorno = yday(inizio),\n         inquinante)]\n```\n\n```{r}\n#| label: above50-data\n\npm_genova_above50 &lt;- pm_genova_daily[\n  inquinante == \"PM10\",\n  .(val_50 = (avg &gt; 50) |&gt; sum(na.rm = TRUE)),\n  by = .(nome_stazione)]\n```\n\n```{r}\n#| label: fig-misure\n#| fig-cap: !expr paste0(\"PM~10~ e PM~2,5~ a \", params$comune, \".\")\nlibrary(ggplot2)\n\npm_genova_daily |&gt;\n  ggplot(\n  aes(x = inquinante, y = avg)\n  ) +\n  geom_boxplot() +\n  labs(\n    x = element_blank(),\n    y = expression(\"Concentrazione media giornaliera \" * (mu * g / m^{3}))\n  ) +\n  theme_bw()\n```\n\nLa stazione con più valori di PM~10~ superiori al limite giornaliero\ndi $50\\, \\mu g/m^3$ è \n`r pm_genova_above50[which.max(val_50), nome_stazione]` con \n`r pm_genova_above50[which.max(val_50), val_50]` superamenti.\nIl report è da salvare nel file report_dinamico.qmd.",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Report parametrizzati</span>"
    ]
  },
  {
    "objectID": "dynamic.html#creazione-di-report-multipli",
    "href": "dynamic.html#creazione-di-report-multipli",
    "title": "10  Report parametrizzati",
    "section": "10.6 Creazione di report multipli",
    "text": "10.6 Creazione di report multipli\nPer utilizzare report_dinamico.qmd come template per la creazione di report personalizzati ci sono due opzioni:\n\nda terminale con comandi come:\nquarto render report_dinamico.qmd -P comune:Busalla\nusare uno script di R:\n\n\n# i comuni per cui voglio ottenere il report\nlista_comuni &lt;- c(\"Busalla\", \"Genova\", \"Campomorone\")\n\n# definisco una funzione personalizzata per creare i report\nreport_aria &lt;- function(template,\n                        par_comune){\n  \nlibrary(quarto)\n  \n# sarebbe meglio acquisirli programmaticamente\ncomuni_validi &lt;- c(\"Busalla\", \"Campomorone\", \"Chiavari\",\n                     \"Genova\", \"Masone\", \"Rapallo\")\n  \n  stopifnot(file.exists(template))\n  stopifnot(par_comune %in% comuni_validi)\n  \n  output_file &lt;- paste0(Sys.Date(), \"_report_aria_\", par_comune, \".html\")\n  \n  quarto_render(input = template,\n                output_file = output_file,\n                execute_params = list(comune = par_comune))\n  \n}\n\nlapply(lista_comuni, function(x) {\n  report_aria(template = \"report_dinamico.qmd\", par_comune = x)\n})\n\nL’approccio da riga di comando è ideale per contesti automatizzati e ambienti non interattivi, come l’esecuzione pianificata o in risposta a eventi esterni. Al contrario, l’approccio tramite script R è più adatto alla generazione di report multipli, alla gestione dinamica dei parametri e a un controllo più fine sul flusso di lavoro e sull’organizzazione dei risultati.\n\nEsercizio\n\n\nStrutturare un template per report dinamici utile nel vostro contesto lavorativo. Una volta identificata l’applicazione di interesse riflettete su:\n\nQuali sono le parti fisse del report?\nQuali sono i parametri del report?\nIn quale modalità è meglio creare i report?\n\nIniziate a strutturare un report statico per uno dei casi di interesse e introducete i parametri solo in un secondo momento.",
    "crumbs": [
      "Visualizzazione e reportistica",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Report parametrizzati</span>"
    ]
  }
]