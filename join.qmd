# Unire diverse fonti di dati {#sec-join}

```{r}
#| echo: false
source("_common.R")
```

## Tipologie di unioni

Quando lavoriamo con dati, spesso ci troviamo nella situazione di dover unire due insiemi di dati in base a una o più colonne chiave. Questo processo si chiama *join* o *merge* ed è fondamentale per combinare informazioni provenienti da fonti diverse.

Per esempio, possiamo avere due `data.table`: - la prima si chiama `misure` e contiene le misure analitiche svolte su una serie di campioni; - la seconda si chiama `indirizzi` e contiene le informazioni relative al punto di prelievo. Per mettere in relazione le due tabelle serve una colonna in comune, nell'esempio mostrato sarà quella relativa al codice del campione:

```{r}
misure <- data.table(
  codice = c("22201/24", "22248/24", "22311/24", "22312/24"),
  data_campionamento = as.IDate(c("2024-01-15", "2024-02-20", "2024-03-10", "2024-03-10")),
  cadmio = c(0.05, 0.06, 0.04, 0.06),
  piombo = c(0.1, 0.15, 0.12, 0.11),
  arsenico = c(0.08, 0.09, 0.05, NA)
    )

indirizzi <- data.table(
  codice = c("22311/24", "22248/24", "22412/24"),
  comune = c("Paperopoli", "Topolinia", "Topolinia"),
  provincia = c("SV", "IM", "IM"),
  via = c("corso Papero", "via de Topis", "via Ratti"),
  civico = c("12", "11/10", "8R")
)
```

Non tutti i codici dei campioni presenti nella tabella `misure` compaiono anche nella tabella `indirizzi`. Viceversa, non tutti i codici dei campioni per cui è noto l'indirizzo risultano associati a delle misure. Per poter procedere con l'operazione di *join* è necessario capire cosa fare con i dati per cui non c'è corrispondenza tra le due tabelle: questa scelta definisce le diverse tipologie di *join*.

### Inner join {#sec-inner}

Se siamo interessati solo ai campioni per cui siano disponibili delle misure e sia noto l'indirizzo del punto di prelievo, effettueremo un *inner join*. In termini insiemistici equivale all'intersezione di due insiemi $A$ e $B$ ($A \cap B$), come mostrato in @fig-inner.

![Inner join ($A \cap B$): vengono restituite solo le righe di A che compaiono anche in B.](images/inner_join.png){#fig-inner}

Con `data.table` la sintassi è piuttosto semplice:

```{r}
misure[indirizzi, # le tabelle
       on = "codice", # la colonna chiave
       nomatch = NULL] # assegno NULL ai record senza corrispondenza
```

Nel caso in cui la colonna chiave abbia nomi diversi nelle due tabelle da unire, è possibile passare all'argomento `on` un vettore con i nomi delle colonne nelle due tabelle.

### Right e left join {#sec-left}

Se siamo interessati a tutti i campioni che dispongono di un indirizzo e a questi aggiungere, se disponibile, l'informazione sulle misure, opereremo un *right join*. Da un punto di vista insiemistico, immaginando che l'insieme $B$ sia quello contenente gli indirizzi e il $A$ quello dedicato alle misure, equivale a scrivere l'unione di $B$ con l'intersezione di $A$ con $B$ ($B\cup(A\cap B)$), come mostrato in @fig-right.

![Right join ($B \cup (A \cap B)$): vengono restituite tutte le righe di B, completate con le informazioni contenute in A, quando disponibili.](images/right_join.png){#fig-right}

Ecco come si fa:

```{r}
misure[indirizzi, # le tabelle
       on = "codice", # la colonna chiave
       nomatch = NA] # assegno NA ai record senza corrispondenza
```

È importante ricordare che le informazioni contenute nella tabella tra le parentesi quadre sono conservate integralmente, mentre le informazioni contenute nella tabella fuori dalle parentesi sono recuperate solo in caso di corrispondenza, altrimenti saranno riempite con `NA`.

Nel caso si voglia effettuare un *left join*, cioè mostrare tutte le misure effettuate, indicando l'indirizzo del punto di prelievo laddove disponibile, è sufficiente invertire le due tabelle all'interno dell'espressione:

```{r}
indirizzi[misure, # le tabelle
       on = "codice", # la colonna chiave
       nomatch = NA] # assegno NA ai record senza corrispondenza
```

::: {.callout-tip}

## Per i più frettolosi

Il valore predefinito dell'argomento `nomatch` è `NA`: possiamo quindi ometterlo quando facciamo *right* e *left join*.

:::

### Full join

Se siamo interessati a tutti i valori presenti nelle due tabelle, messi in relazione quando possibile o sostituiti da `NA` in caso di assenza di corrispondenza, possiamo ricorrere a un *full join*. In termini insiemistici equivale all'unione di due insiemi $A$ e $B$ ($A \cup B$), come mostrato in @fig-full.

![Full join ($A \cup B$): vengono restituite tutte le righe di A e B, in caso di mancanza di corrispondenza tra i valori si utilizzano `NA`.](images/full_join.png){#fig-full}

La sintassi usata per questo caso è differente dalle precedenti e viene utilizzata la funzione `merge()`:
```{r}
merge(misure, indirizzi, by = "codice", all = TRUE)
```

::: callout-tip
## Per i più golosi

Con il comando `vignette("datatable-joins")` è possible avere informazioni aggiuntive sull'unione di serie di dati con il pacchetto `data.table`.
:::

::: panel-tabset
## Esercizio


## Soluzione


:::

